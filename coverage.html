
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>simrunner: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rhino11/trafficsim/cmd/simrunner/main.go (0.0%)</option>
				
				<option value="file1">github.com/rhino11/trafficsim/cmd/validate-yaml/main.go (84.7%)</option>
				
				<option value="file2">github.com/rhino11/trafficsim/debug_attitude.go (0.0%)</option>
				
				<option value="file3">github.com/rhino11/trafficsim/internal/config/config.go (89.1%)</option>
				
				<option value="file4">github.com/rhino11/trafficsim/internal/config/factory.go (79.6%)</option>
				
				<option value="file5">github.com/rhino11/trafficsim/internal/models/airborne.go (76.1%)</option>
				
				<option value="file6">github.com/rhino11/trafficsim/internal/models/factory.go (91.7%)</option>
				
				<option value="file7">github.com/rhino11/trafficsim/internal/models/land.go (0.0%)</option>
				
				<option value="file8">github.com/rhino11/trafficsim/internal/models/maritime.go (0.0%)</option>
				
				<option value="file9">github.com/rhino11/trafficsim/internal/models/platform.go (47.9%)</option>
				
				<option value="file10">github.com/rhino11/trafficsim/internal/models/space.go (0.0%)</option>
				
				<option value="file11">github.com/rhino11/trafficsim/internal/output/cot.go (90.9%)</option>
				
				<option value="file12">github.com/rhino11/trafficsim/internal/output/multicast.go (70.0%)</option>
				
				<option value="file13">github.com/rhino11/trafficsim/internal/output/platform_converter.go (0.0%)</option>
				
				<option value="file14">github.com/rhino11/trafficsim/internal/server/server.go (44.7%)</option>
				
				<option value="file15">github.com/rhino11/trafficsim/internal/sim/engine.go (0.0%)</option>
				
				<option value="file16">github.com/rhino11/trafficsim/internal/sim/physics.go (66.9%)</option>
				
				<option value="file17">github.com/rhino11/trafficsim/internal/testutil/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
        "github.com/rhino11/trafficsim/internal/output"
        "github.com/rhino11/trafficsim/internal/server"
        "github.com/rhino11/trafficsim/internal/sim"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                configPath    = flag.String("config", "data/config.yaml", "Path to configuration file")
                webMode       = flag.Bool("web", false, "Run in web server mode")
                headlessMode  = flag.Bool("headless", false, "Run in headless mode (command-line only, no web interface)")
                port          = flag.String("port", "8080", "Port for web server")
                multicast     = flag.Bool("multicast", false, "Enable multicast transmission of platform updates")
                multicastAddr = flag.String("multicast-addr", "239.2.3.1", "Multicast address for platform updates")
                multicastPort = flag.String("multicast-port", "6969", "Multicast port for platform updates")
        )
        flag.Parse()

        fmt.Println("Global Traffic Simulator - Configuration-Driven Demo")
        fmt.Println("====================================================")

        // Validate flag combinations
        if *webMode &amp;&amp; *headlessMode </span><span class="cov0" title="0">{
                log.Fatal("Error: Cannot specify both -web and -headless modes")
        }</span>

        // Load configuration
        <span class="cov0" title="0">fmt.Printf("Loading configuration from: %s\n", *configPath)
        cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Create simulation engine
        <span class="cov0" title="0">engine := sim.NewEngine(cfg)

        // Setup multicast if enabled
        var multicastConn *net.UDPConn
        if *multicast </span><span class="cov0" title="0">{
                multicastConn, err = setupMulticast(*multicastAddr, *multicastPort)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to setup multicast: %v", err)
                }</span>
                <span class="cov0" title="0">defer multicastConn.Close()
                fmt.Printf("Multicast transmission enabled on %s:%s\n", *multicastAddr, *multicastPort)</span>
        }

        <span class="cov0" title="0">if *webMode </span><span class="cov0" title="0">{
                // Run web server mode
                fmt.Printf("Starting web server on port %s...\n", *port)

                // Load platforms from configuration (needed for web mode)
                fmt.Println("Loading platforms for web simulation...")
                if err := engine.LoadPlatformsFromConfig(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load platforms: %v", err)
                }</span>

                <span class="cov0" title="0">platforms := engine.GetAllPlatforms()
                fmt.Printf("Loaded %d platforms for web interface\n", len(platforms))

                // Start simulation engine for web mode
                if err := engine.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start simulation: %v", err)
                }</span>

                // Create server
                <span class="cov0" title="0">srv := server.NewServer(cfg, engine)

                // Start server
                if err := srv.Start(*port); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Run command-line mode (headless or regular CLI)
                if *headlessMode </span><span class="cov0" title="0">{
                        fmt.Println("Running in headless mode...")
                }</span>
                <span class="cov0" title="0">runCLISimulation(engine, cfg, multicastConn)</span>
        }
}

func setupMulticast(addr, port string) (*net.UDPConn, error) <span class="cov0" title="0">{
        // Parse multicast address
        multicastAddr, err := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%s", addr, port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve multicast address: %v", err)
        }</span>

        // Create UDP connection
        <span class="cov0" title="0">conn, err := net.DialUDP("udp", nil, multicastAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create multicast connection: %v", err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}

func runCLISimulation(engine *sim.Engine, cfg *config.Config, multicastConn *net.UDPConn) <span class="cov0" title="0">{
        fmt.Println("Starting traffic simulation...")

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                fmt.Println("\nReceived interrupt signal, shutting down...")
                cancel()
        }</span>()

        // Load platforms from configuration or create examples
        <span class="cov0" title="0">if err := engine.LoadPlatformsFromConfig(); err != nil </span><span class="cov0" title="0">{
                cancel() // Cancel context before fatal exit
                log.Fatalf("Failed to load platforms: %v", err)
        }</span>

        <span class="cov0" title="0">platforms := engine.GetAllPlatforms()
        fmt.Printf("Loaded %d platforms\n", len(platforms))

        // Display platform information
        for _, platform := range platforms </span><span class="cov0" title="0">{
                displayPlatformInfo(platform)
        }</span>

        // Start simulation
        <span class="cov0" title="0">if err := engine.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start simulation: %v", err)
        }</span>

        // Create CoT generator for multicast transmission
        <span class="cov0" title="0">var cotGenerator *output.CoTGenerator
        if multicastConn != nil </span><span class="cov0" title="0">{
                cotGenerator = output.NewCoTGenerator()
                fmt.Println("CoT message generation enabled for multicast transmission")
        }</span>

        // Run simulation monitoring loop
        <span class="cov0" title="0">ticker := time.NewTicker(1 * time.Second) // Status updates every second
        defer ticker.Stop()

        startTime := time.Now()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        fmt.Println("Simulation stopped")
                        engine.Stop()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Display status
                        elapsed := time.Since(startTime)
                        simTime := engine.GetSimulationTime()
                        platforms := engine.GetAllPlatforms()

                        fmt.Printf("Real time: %.1fs, Sim time: %.1fs, Platforms: %d\n",
                                elapsed.Seconds(), simTime, len(platforms))

                        // Display platform positions
                        if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                                displayPlatformStatus(platforms)
                        }</span>

                        // Send multicast updates if enabled
                        <span class="cov0" title="0">if multicastConn != nil &amp;&amp; cotGenerator != nil </span><span class="cov0" title="0">{
                                sendCoTMulticastUpdates(multicastConn, cotGenerator, platforms)
                        }</span>
                }
        }
}

func sendCoTMulticastUpdates(conn *net.UDPConn, generator *output.CoTGenerator, platforms []models.Platform) <span class="cov0" title="0">{
        for _, platform := range platforms </span><span class="cov0" title="0">{
                // Convert platform to CoT state
                cotState := output.PlatformToCoTState(platform)

                // Generate CoT XML message
                cotMessage, err := generator.GenerateCoTMessage(cotState)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to generate CoT message for %s: %v", platform.GetCallSign(), err)
                        continue</span>
                }

                // Send the CoT XML message
                <span class="cov0" title="0">_, err = conn.Write(cotMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send CoT message for %s: %v", platform.GetCallSign(), err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Sent CoT message for %s (Type: %s)", platform.GetCallSign(), cotState.CoTType)
                }</span>
        }
}

func displayPlatformInfo(platform models.Platform) <span class="cov0" title="0">{
        state := platform.GetState()
        fmt.Printf("  %s (%s) - %s\n", platform.GetName(), platform.GetClass(), platform.GetCallSign())
        fmt.Printf("    Type: %s | Position: %.4f,%.4f @ %.0fm\n",
                platform.GetType(), state.Position.Latitude, state.Position.Longitude, state.Position.Altitude)
        fmt.Printf("    Specs: L=%.1fm, W=%.1fm, H=%.1fm, Mass=%.0fkg\n",
                platform.GetLength(), platform.GetWidth(), platform.GetHeight(), platform.GetMass())
        fmt.Printf("    Performance: Max=%.1fm/s (%.1fkts), Max Alt=%.0fm\n",
                platform.GetMaxSpeed(), platform.GetMaxSpeed()*1.944, platform.GetMaxAltitude())
}</span>

func displayPlatformStatus(platforms []models.Platform) <span class="cov0" title="0">{
        for _, platform := range platforms </span><span class="cov0" title="0">{
                state := platform.GetState()
                fmt.Printf("  %s: Lat=%.4f, Lon=%.4f, Alt=%.0fm, Speed=%.1fm/s, Hdg=%.1f¬∞\n",
                        platform.GetCallSign(),
                        state.Position.Latitude,
                        state.Position.Longitude,
                        state.Position.Altitude,
                        state.Speed,
                        state.Heading,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
        "gopkg.in/yaml.v3"
)

// ValidationResult represents the result of validating a single file
type ValidationResult struct {
        File   string
        Valid  bool
        Errors []string
}

// ValidationSummary contains overall validation results
type ValidationSummary struct {
        TotalFiles   int
        ValidFiles   int
        InvalidFiles int
        Results      []ValidationResult
        FatalErrors  []string
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s &lt;directory_or_file&gt; [directory_or_file...]\n", os.Args[0])
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var allFiles []string

        // Collect all YAML files from provided paths
        for _, path := range os.Args[1:] </span><span class="cov0" title="0">{
                files, err := collectYAMLFiles(path)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error collecting files from %s: %v\n", path, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">allFiles = append(allFiles, files...)</span>
        }

        <span class="cov0" title="0">if len(allFiles) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No YAML files found to validate")
                return
        }</span>

        <span class="cov0" title="0">summary := validateFiles(allFiles)
        printSummary(summary)

        if summary.InvalidFiles &gt; 0 || len(summary.FatalErrors) &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// collectYAMLFiles recursively finds all YAML files in the given path
func collectYAMLFiles(path string) ([]string, error) <span class="cov8" title="1">{
        var files []string

        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                if isYAMLFile(path) </span><span class="cov8" title="1">{
                        files = append(files, path)
                }</span>
                <span class="cov8" title="1">return files, nil</span>
        }

        <span class="cov8" title="1">err = filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if !info.IsDir() &amp;&amp; isYAMLFile(filePath) </span><span class="cov8" title="1">{
                        files = append(files, filePath)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return files, err</span>
}

// isYAMLFile checks if a file has a YAML extension
func isYAMLFile(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        return ext == ".yaml" || ext == ".yml"
}</span>

// validateFiles validates all provided YAML files
func validateFiles(files []string) ValidationSummary <span class="cov8" title="1">{
        summary := ValidationSummary{
                TotalFiles: len(files),
                Results:    make([]ValidationResult, 0, len(files)),
        }

        for _, file := range files </span><span class="cov8" title="1">{
                result := validateFile(file)
                summary.Results = append(summary.Results, result)

                if result.Valid </span><span class="cov8" title="1">{
                        summary.ValidFiles++
                }</span> else<span class="cov8" title="1"> {
                        summary.InvalidFiles++
                }</span>
        }

        <span class="cov8" title="1">return summary</span>
}

// validateFilePath ensures the file path is safe and within allowed directories
func validateFilePath(filePath string) error <span class="cov8" title="1">{
        // Clean the path to prevent directory traversal
        cleanPath := filepath.Clean(filePath)

        // Get absolute path
        absPath, err := filepath.Abs(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file path: %v", err)
        }</span>

        // Define allowed base directories
        <span class="cov8" title="1">wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot determine working directory: %v", err)
        }</span>

        <span class="cov8" title="1">allowedDirs := []string{
                filepath.Join(wd, "data"),
                filepath.Join(wd, "configs"),
                wd, // Allow current directory
        }

        // Check if the file is within allowed directories
        allowed := false
        for _, allowedDir := range allowedDirs </span><span class="cov8" title="1">{
                absAllowedDir, err := filepath.Abs(allowedDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(absPath, absAllowedDir) </span><span class="cov8" title="1">{
                        allowed = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                return fmt.Errorf("file path not allowed: %s", absPath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFile validates a single YAML file based on its location and content
func validateFile(filePath string) ValidationResult <span class="cov8" title="1">{
        result := ValidationResult{
                File:   filePath,
                Valid:  true,
                Errors: []string{},
        }

        // Validate file path for security FIRST - before reading the file
        if err := validateFilePath(filePath); err != nil </span><span class="cov8" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, fmt.Sprintf("Security error: %v", err))
                return result
        }</span>

        // Read file content (now safe after validation)
        <span class="cov8" title="1">content, err := os.ReadFile(filePath) // #nosec G304 -- filePath is validated by validateFilePath() function
        if err != nil </span><span class="cov0" title="0">{
                result.Valid = false
                result.Errors = append(result.Errors, fmt.Sprintf("Failed to read file: %v", err))
                return result
        }</span>

        // Basic YAML syntax validation
        <span class="cov8" title="1">var yamlData interface{}
        if err := yaml.Unmarshal(content, &amp;yamlData); err != nil </span><span class="cov8" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, fmt.Sprintf("Invalid YAML syntax: %v", err))
                return result
        }</span>

        // Determine file type and validate accordingly
        <span class="cov8" title="1">fileType := determineFileType(filePath)

        switch fileType </span>{
        case "main_config":<span class="cov0" title="0">
                errors := validateMainConfig(content)
                result.Errors = append(result.Errors, errors...)</span>
        case "platform_definition":<span class="cov0" title="0">
                errors := validatePlatformDefinition(content, filePath)
                result.Errors = append(result.Errors, errors...)</span>
        case "scenario_config":<span class="cov0" title="0">
                errors := validateScenarioConfig(content)
                result.Errors = append(result.Errors, errors...)</span>
        case "unknown":<span class="cov8" title="1">
                // For unknown files, just validate YAML syntax (already done above)
                break</span>
        }

        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">return result</span>
}

// determineFileType analyzes the file path to determine what type of config it is
func determineFileType(filePath string) string <span class="cov8" title="1">{
        // Normalize path separators
        normalizedPath := filepath.ToSlash(filePath)

        if strings.Contains(normalizedPath, "data/config.yaml") || strings.HasSuffix(normalizedPath, "config.yaml") </span><span class="cov8" title="1">{
                return "main_config"
        }</span>

        <span class="cov8" title="1">if strings.Contains(normalizedPath, "data/platforms/") </span><span class="cov8" title="1">{
                return "platform_definition"
        }</span>

        <span class="cov8" title="1">if strings.Contains(normalizedPath, "data/configs/") </span><span class="cov8" title="1">{
                return "scenario_config"
        }</span>

        <span class="cov8" title="1">return "unknown"</span>
}

// validateMainConfig validates the main configuration file structure
func validateMainConfig(content []byte) []string <span class="cov8" title="1">{
        var errors []string

        var cfg config.Config
        if err := yaml.Unmarshal(content, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("Failed to parse main config: %v", err))
                return errors
        }</span>

        // Validate simulation config
        <span class="cov8" title="1">if cfg.Simulation.UpdateInterval == "" </span><span class="cov8" title="1">{
                errors = append(errors, "simulation.update_interval is required")
        }</span>

        <span class="cov8" title="1">if cfg.Simulation.TimeScale &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "simulation.time_scale must be positive")
        }</span>

        // Validate server config
        <span class="cov8" title="1">if cfg.Server.Port &lt; 1 || cfg.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("server.port must be between 1 and 65535, got %d", cfg.Server.Port))
        }</span>

        // Validate platform types exist
        <span class="cov8" title="1">totalPlatformTypes := len(cfg.Platforms.AirborneTypes) +
                len(cfg.Platforms.MaritimeTypes) +
                len(cfg.Platforms.LandTypes) +
                len(cfg.Platforms.SpaceTypes)

        if totalPlatformTypes == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "At least one platform type must be defined")
        }</span>

        // Validate scenario references
        <span class="cov8" title="1">for scenarioName, scenario := range cfg.Platforms.Scenarios </span><span class="cov8" title="1">{
                for i, instance := range scenario.Instances </span><span class="cov8" title="1">{
                        if !cfg.Platforms.HasType(instance.TypeID) </span><span class="cov8" title="1">{
                                errors = append(errors, fmt.Sprintf("scenario %s, instance %d: references unknown platform type '%s'",
                                        scenarioName, i, instance.TypeID))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// validatePlatformDefinition validates platform definition files
func validatePlatformDefinition(content []byte, filePath string) []string <span class="cov8" title="1">{
        var errors []string

        // Try to parse as a platform type definition
        var platformData struct {
                PlatformTypes map[string]models.PlatformTypeDefinition `yaml:"platform_types"`
        }

        if err := yaml.Unmarshal(content, &amp;platformData); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("Failed to parse platform definition: %v", err))
                return errors
        }</span>

        <span class="cov8" title="1">if len(platformData.PlatformTypes) == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "No platform types defined in file")
                return errors
        }</span>

        // Validate each platform type
        <span class="cov8" title="1">for typeName, platformType := range platformData.PlatformTypes </span><span class="cov8" title="1">{
                platformErrors := validatePlatformType(typeName, platformType, filePath)
                errors = append(errors, platformErrors...)
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// validatePlatformType validates individual platform type definitions
func validatePlatformType(typeName string, platform models.PlatformTypeDefinition, filePath string) []string <span class="cov8" title="1">{
        var errors []string

        // Required fields validation
        if platform.Class == "" </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': class is required", typeName))
        }</span>

        <span class="cov8" title="1">if platform.Category == "" </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': category is required", typeName))
        }</span>

        // Performance validation
        <span class="cov8" title="1">if platform.Performance.MaxSpeed &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': max_speed must be positive", typeName))
        }</span>

        <span class="cov8" title="1">if platform.Performance.CruiseSpeed &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': cruise_speed must be positive", typeName))
        }</span>

        <span class="cov8" title="1">if platform.Performance.CruiseSpeed &gt; platform.Performance.MaxSpeed </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': cruise_speed cannot exceed max_speed", typeName))
        }</span>

        // Physical characteristics validation
        <span class="cov8" title="1">if platform.Physical.Length &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': length must be positive", typeName))
        }</span>

        <span class="cov8" title="1">if platform.Physical.Width &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': width must be positive", typeName))
        }</span>

        <span class="cov8" title="1">if platform.Physical.Mass &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("platform '%s': mass must be positive", typeName))
        }</span>

        // Domain-specific validation
        <span class="cov8" title="1">errors = append(errors, validateDomainSpecific(typeName, platform, filePath)...)

        return errors</span>
}

// validateDomainSpecific performs domain-specific validation based on file location
func validateDomainSpecific(typeName string, platform models.PlatformTypeDefinition, filePath string) []string <span class="cov8" title="1">{
        var errors []string

        normalizedPath := filepath.ToSlash(filePath)

        if strings.Contains(normalizedPath, "airborne/") </span><span class="cov8" title="1">{
                // Airborne-specific validation
                if platform.Performance.MaxAltitude &lt;= 0 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("airborne platform '%s': max_altitude must be positive", typeName))
                }</span>

                <span class="cov8" title="1">if platform.Performance.ClimbRate &lt;= 0 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("airborne platform '%s': climb_rate must be positive", typeName))
                }</span>
        }

        <span class="cov8" title="1">if strings.Contains(normalizedPath, "maritime/") </span><span class="cov8" title="1">{
                // Maritime-specific validation
                if platform.Physical.Draft &lt;= 0 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("maritime platform '%s': draft must be positive", typeName))
                }</span>
        }

        <span class="cov8" title="1">if strings.Contains(normalizedPath, "space/") </span><span class="cov8" title="1">{
                // Space-specific validation
                if platform.Performance.OrbitalVelocity &lt;= 0 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("space platform '%s': orbital_velocity must be positive", typeName))
                }</span>

                <span class="cov8" title="1">if platform.Performance.OrbitalAltitude &lt;= 0 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("space platform '%s': orbital_altitude must be positive", typeName))
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// validateScenarioConfig validates scenario configuration files
func validateScenarioConfig(content []byte) []string <span class="cov8" title="1">{
        var errors []string

        var scenarioData struct {
                Metadata struct {
                        Name        string `yaml:"name"`
                        Description string `yaml:"description"`
                        Duration    int    `yaml:"duration"`
                } `yaml:"metadata"`
                Platforms []struct {
                        ID            string `yaml:"id"`
                        Type          string `yaml:"type"`
                        StartPosition struct {
                                Latitude  float64 `yaml:"latitude"`
                                Longitude float64 `yaml:"longitude"`
                                Altitude  float64 `yaml:"altitude"`
                        } `yaml:"start_position"`
                } `yaml:"platforms"`
        }

        if err := yaml.Unmarshal(content, &amp;scenarioData); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("Failed to parse scenario config: %v", err))
                return errors
        }</span>

        // Validate metadata
        <span class="cov8" title="1">if scenarioData.Metadata.Name == "" </span><span class="cov8" title="1">{
                errors = append(errors, "metadata.name is required")
        }</span>

        <span class="cov8" title="1">if scenarioData.Metadata.Duration &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "metadata.duration must be positive")
        }</span>

        // Validate platforms
        <span class="cov8" title="1">platformIDs := make(map[string]bool)
        for i, platform := range scenarioData.Platforms </span><span class="cov8" title="1">{
                if platform.ID == "" </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("platform %d: id is required", i))
                }</span> else<span class="cov8" title="1"> {
                        if platformIDs[platform.ID] </span><span class="cov8" title="1">{
                                errors = append(errors, fmt.Sprintf("platform %d: duplicate id '%s'", i, platform.ID))
                        }</span>
                        <span class="cov8" title="1">platformIDs[platform.ID] = true</span>
                }

                <span class="cov8" title="1">if platform.Type == "" </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("platform %d (%s): type is required", i, platform.ID))
                }</span>

                // Validate coordinates
                <span class="cov8" title="1">if platform.StartPosition.Latitude &lt; -90 || platform.StartPosition.Latitude &gt; 90 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("platform %d (%s): latitude must be between -90 and 90", i, platform.ID))
                }</span>

                <span class="cov8" title="1">if platform.StartPosition.Longitude &lt; -180 || platform.StartPosition.Longitude &gt; 180 </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("platform %d (%s): longitude must be between -180 and 180", i, platform.ID))
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// printSummary prints the validation results
func printSummary(summary ValidationSummary) <span class="cov8" title="1">{
        fmt.Printf("\n=== YAML Validation Summary ===\n")
        fmt.Printf("Total files: %d\n", summary.TotalFiles)
        fmt.Printf("Valid files: %d\n", summary.ValidFiles)
        fmt.Printf("Invalid files: %d\n", summary.InvalidFiles)

        if len(summary.FatalErrors) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("\nFatal Errors:\n")
                for _, err := range summary.FatalErrors </span><span class="cov8" title="1">{
                        fmt.Printf("  ‚ùå %s\n", err)
                }</span>
        }

        <span class="cov8" title="1">if summary.InvalidFiles &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("\nValidation Errors:\n")
                for _, result := range summary.Results </span><span class="cov8" title="1">{
                        if !result.Valid </span><span class="cov8" title="1">{
                                fmt.Printf("\nüìÅ %s:\n", result.File)
                                for _, err := range result.Errors </span><span class="cov8" title="1">{
                                        fmt.Printf("  ‚ùå %s\n", err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if summary.InvalidFiles == 0 &amp;&amp; len(summary.FatalErrors) == 0 </span><span class="cov8" title="1">{
                fmt.Printf("\n‚úÖ All YAML files are valid!\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "math"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

func main() <span class="cov0" title="0">{
        startPos := models.Position{Latitude: 40.0, Longitude: -74.0, Altitude: 10000}
        dest := models.Position{Latitude: 40.1, Longitude: -74.0, Altitude: 10000}

        aircraft := models.NewBoeing737_800("TEST-004", "TEST101", startPos)
        if err := aircraft.SetDestination(dest); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error setting destination: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">aircraft.UniversalPlatform.State.Speed = 200

        fmt.Printf("Initial heading: %.1f¬∞\n", aircraft.UniversalPlatform.State.Heading)

        // Calculate bearing manually to debug
        lat1 := startPos.Latitude * math.Pi / 180.0
        lat2 := dest.Latitude * math.Pi / 180.0
        deltaLon := (dest.Longitude - startPos.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        for bearing &lt; 0 </span><span class="cov0" title="0">{
                bearing += 360
        }</span>

        <span class="cov0" title="0">fmt.Printf("Bearing to destination: %.1f¬∞\n", bearing)

        headingError := bearing - aircraft.UniversalPlatform.State.Heading
        fmt.Printf("Heading error: %.1f¬∞\n", headingError)

        fmt.Printf("Initial roll: %.3f¬∞\n", aircraft.UniversalPlatform.State.Physics.Attitude.Roll)

        // Test what happens during a full Update call
        if err := aircraft.Update(time.Second); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating aircraft: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("Roll after Update: %.3f¬∞\n", aircraft.UniversalPlatform.State.Physics.Attitude.Roll)
        fmt.Printf("Heading after Update: %.1f¬∞\n", aircraft.UniversalPlatform.State.Heading)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config represents the main configuration structure
type Config struct {
        Simulation SimulationConfig `yaml:"simulation"`
        Platforms  PlatformRegistry `yaml:"platforms"`
        Server     ServerConfig     `yaml:"server"`
        Output     OutputConfig     `yaml:"output"`
}

// SimulationConfig contains simulation runtime parameters
type SimulationConfig struct {
        UpdateInterval string       `yaml:"update_interval" default:"1s"`
        TimeScale      float64      `yaml:"time_scale" default:"1.0"`
        MaxDuration    string       `yaml:"max_duration" default:"1h"`
        StartTime      string       `yaml:"start_time,omitempty"`
        BoundingBox    *BoundingBox `yaml:"bounding_box,omitempty"`
}

// BoundingBox defines simulation area limits
type BoundingBox struct {
        North float64 `yaml:"north"`
        South float64 `yaml:"south"`
        East  float64 `yaml:"east"`
        West  float64 `yaml:"west"`
}

// ServerConfig contains web server settings
type ServerConfig struct {
        Port    int    `yaml:"port" default:"8080"`
        Host    string `yaml:"host" default:"localhost"`
        WebRoot string `yaml:"web_root" default:"web"`
}

// OutputConfig contains CoT and other output settings
type OutputConfig struct {
        CoT     CoTConfig     `yaml:"cot"`
        Logging LoggingConfig `yaml:"logging"`
}

// CoTConfig contains Cursor-on-Target output settings
type CoTConfig struct {
        Enabled    bool   `yaml:"enabled" default:"true"`
        Endpoint   string `yaml:"endpoint" default:"udp://239.2.3.1:6969"`
        UpdateRate string `yaml:"update_rate" default:"5s"`
}

// LoggingConfig contains logging settings
type LoggingConfig struct {
        Level  string `yaml:"level" default:"info"`
        Format string `yaml:"format" default:"text"`
        File   string `yaml:"file,omitempty"`
}

// PlatformRegistry contains all platform type definitions and scenarios
type PlatformRegistry struct {
        // Platform type definitions (the "database tables")
        AirborneTypes PlatformTypeDefinitions `yaml:"airborne_types"`
        MaritimeTypes PlatformTypeDefinitions `yaml:"maritime_types"`
        LandTypes     PlatformTypeDefinitions `yaml:"land_types"`
        SpaceTypes    PlatformTypeDefinitions `yaml:"space_types"`

        // Scenario definitions (instances to create)
        Scenarios map[string]ScenarioConfig `yaml:"scenarios"`
}

// PlatformTypeDefinitions represents a collection of platform type definitions
type PlatformTypeDefinitions map[string]PlatformTypeDefinition

// PlatformTypeDefinition defines a real-world platform type with all its characteristics
type PlatformTypeDefinition struct {
        // Basic identification
        Name     string `yaml:"name"`
        Class    string `yaml:"class"`
        Type     string `yaml:"type"`     // airborne, maritime, land, space
        Category string `yaml:"category"` // commercial, military, civilian

        // Performance characteristics
        MaxSpeed       float64 `yaml:"max_speed"`                 // m/s
        CruiseSpeed    float64 `yaml:"cruise_speed"`              // m/s
        MaxAltitude    float64 `yaml:"max_altitude"`              // meters
        ServiceCeiling float64 `yaml:"service_ceiling,omitempty"` // meters

        // Physical characteristics
        Length float64 `yaml:"length"` // meters
        Width  float64 `yaml:"width"`  // meters (wingspan for aircraft, beam for ships)
        Height float64 `yaml:"height"` // meters
        Mass   float64 `yaml:"mass"`   // kg

        // Type-specific characteristics
        Draft        float64 `yaml:"draft,omitempty"`         // meters (ships)
        Displacement float64 `yaml:"displacement,omitempty"`  // tonnes (ships)
        FuelCapacity float64 `yaml:"fuel_capacity,omitempty"` // liters (land/air)
        Range        float64 `yaml:"range,omitempty"`         // meters
        MaxGradient  float64 `yaml:"max_gradient,omitempty"`  // degrees (land)

        // Orbital characteristics (space)
        OrbitalPeriod float64 `yaml:"orbital_period,omitempty"` // seconds
        Apogee        float64 `yaml:"apogee,omitempty"`         // meters
        Perigee       float64 `yaml:"perigee,omitempty"`        // meters
        Inclination   float64 `yaml:"inclination,omitempty"`    // degrees

        // Call sign patterns
        CallSignPrefix string `yaml:"callsign_prefix,omitempty"`
        CallSignFormat string `yaml:"callsign_format,omitempty"` // e.g., "{prefix}{id}"
}

// ScenarioConfig defines a simulation scenario with platform instances
type ScenarioConfig struct {
        Name        string             `yaml:"name"`
        Description string             `yaml:"description,omitempty"`
        Duration    string             `yaml:"duration,omitempty"`
        Instances   []PlatformInstance `yaml:"instances"`
}

// PlatformInstance defines a specific platform instance in a scenario
type PlatformInstance struct {
        ID          string          `yaml:"id"`
        TypeID      string          `yaml:"type_id"`            // References PlatformTypeDefinition
        Name        string          `yaml:"name"`               // Display name/flight number
        CallSign    string          `yaml:"callsign,omitempty"` // Override callsign
        StartPos    Position        `yaml:"start_position"`
        Destination *Position       `yaml:"destination,omitempty"`
        Route       []Position      `yaml:"route,omitempty"`
        Behavior    *BehaviorConfig `yaml:"behavior,omitempty"`
}

// Position represents a 3D position
type Position struct {
        Latitude  float64 `yaml:"latitude"`
        Longitude float64 `yaml:"longitude"`
        Altitude  float64 `yaml:"altitude"`
}

// BehaviorConfig defines platform-specific behavior parameters
type BehaviorConfig struct {
        Patrol        *PatrolBehavior     `yaml:"patrol,omitempty"`
        CircuitFlight *CircuitBehavior    `yaml:"circuit,omitempty"`
        RandomWalk    *RandomWalkBehavior `yaml:"random_walk,omitempty"`
}

// PatrolBehavior defines patrol pattern behavior
type PatrolBehavior struct {
        Pattern   string     `yaml:"pattern"` // "line", "box", "circle"
        Points    []Position `yaml:"points"`
        Speed     float64    `yaml:"speed,omitempty"`
        LoopCount int        `yaml:"loop_count,omitempty"` // -1 for infinite
}

// CircuitBehavior defines circuit flight pattern
type CircuitBehavior struct {
        Center Position `yaml:"center"`
        Radius float64  `yaml:"radius"`
        Speed  float64  `yaml:"speed,omitempty"`
}

// RandomWalkBehavior defines random movement
type RandomWalkBehavior struct {
        Area        BoundingBox `yaml:"area"`
        MaxDistance float64     `yaml:"max_distance"`
        Speed       float64     `yaml:"speed,omitempty"`
}

// LoadConfig loads configuration from a YAML file
func LoadConfig(filename string) (*Config, error) <span class="cov8" title="1">{
        // Validate filename to prevent path traversal attacks
        if filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("absolute paths not allowed for config files")
        }</span>

        // Clean the path to prevent directory traversal
        <span class="cov8" title="1">cleanPath := filepath.Clean(filename)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path traversal not allowed in config filename")
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov8" title="1">if err := applyDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply defaults: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := validateConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// applyDefaults applies default values to configuration
func applyDefaults(config *Config) error <span class="cov8" title="1">{
        // Apply simulation defaults
        if config.Simulation.UpdateInterval == "" </span><span class="cov8" title="1">{
                config.Simulation.UpdateInterval = "1s"
        }</span>
        <span class="cov8" title="1">if config.Simulation.TimeScale == 0 </span><span class="cov8" title="1">{
                config.Simulation.TimeScale = 1.0
        }</span>
        <span class="cov8" title="1">if config.Simulation.MaxDuration == "" </span><span class="cov8" title="1">{
                config.Simulation.MaxDuration = "1h"
        }</span>

        // Apply server defaults
        <span class="cov8" title="1">if config.Server.Port == 0 </span><span class="cov8" title="1">{
                config.Server.Port = 8080
        }</span>
        <span class="cov8" title="1">if config.Server.Host == "" </span><span class="cov8" title="1">{
                config.Server.Host = "localhost"
        }</span>
        <span class="cov8" title="1">if config.Server.WebRoot == "" </span><span class="cov8" title="1">{
                config.Server.WebRoot = "web"
        }</span>

        // Apply output defaults
        <span class="cov8" title="1">if config.Output.CoT.UpdateRate == "" </span><span class="cov8" title="1">{
                config.Output.CoT.UpdateRate = "5s"
        }</span>
        <span class="cov8" title="1">if config.Output.CoT.Endpoint == "" </span><span class="cov8" title="1">{
                config.Output.CoT.Endpoint = "udp://239.2.3.1:6969"
        }</span>
        <span class="cov8" title="1">if config.Output.Logging.Level == "" </span><span class="cov8" title="1">{
                config.Output.Logging.Level = "info"
        }</span>
        <span class="cov8" title="1">if config.Output.Logging.Format == "" </span><span class="cov8" title="1">{
                config.Output.Logging.Format = "text"
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateConfig validates the configuration
func validateConfig(config *Config) error <span class="cov8" title="1">{
        // Validate server port
        if config.Server.Port &lt; 1 || config.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", config.Server.Port)
        }</span>

        // Validate time scale
        <span class="cov8" title="1">if config.Simulation.TimeScale &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid time scale: %f", config.Simulation.TimeScale)
        }</span>

        // Validate platform type references in scenarios
        <span class="cov8" title="1">for scenarioName, scenario := range config.Platforms.Scenarios </span><span class="cov8" title="1">{
                for i, instance := range scenario.Instances </span><span class="cov8" title="1">{
                        if !config.Platforms.HasType(instance.TypeID) </span><span class="cov0" title="0">{
                                return fmt.Errorf("scenario %s, instance %d: unknown platform type %s",
                                        scenarioName, i, instance.TypeID)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// HasType checks if a platform type exists in the registry
func (pr *PlatformRegistry) HasType(typeID string) bool <span class="cov8" title="1">{
        if _, exists := pr.AirborneTypes[typeID]; exists </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if _, exists := pr.MaritimeTypes[typeID]; exists </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if _, exists := pr.LandTypes[typeID]; exists </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if _, exists := pr.SpaceTypes[typeID]; exists </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// GetType retrieves a platform type definition by ID
func (pr *PlatformRegistry) GetType(typeID string) (*PlatformTypeDefinition, error) <span class="cov8" title="1">{
        if def, exists := pr.AirborneTypes[typeID]; exists </span><span class="cov8" title="1">{
                return &amp;def, nil
        }</span>
        <span class="cov8" title="1">if def, exists := pr.MaritimeTypes[typeID]; exists </span><span class="cov8" title="1">{
                return &amp;def, nil
        }</span>
        <span class="cov8" title="1">if def, exists := pr.LandTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov8" title="1">if def, exists := pr.SpaceTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("platform type not found: %s", typeID)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

// Platform type constants
const (
        PlatformTypeAirborne = "airborne"
        PlatformTypeMaritime = "maritime"
        PlatformTypeLand     = "land"
        PlatformTypeSpace    = "space"
        CategoryMilitary     = "military"
)

// PlatformFactory creates platform instances from configuration data
type PlatformFactory struct {
        registry *PlatformRegistry
}

// NewPlatformFactory creates a new platform factory
func NewPlatformFactory(registry *PlatformRegistry) *PlatformFactory <span class="cov8" title="1">{
        return &amp;PlatformFactory{
                registry: registry,
        }
}</span>

// CreatePlatform creates a universal platform instance from configuration
func (f *PlatformFactory) CreatePlatform(instance PlatformInstance) (models.Platform, error) <span class="cov8" title="1">{
        // Get the platform type definition
        typeDef, err := f.registry.GetType(instance.TypeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get platform type %s: %w", instance.TypeID, err)
        }</span>

        // Convert config position to models position
        <span class="cov8" title="1">startPos := models.Position{
                Latitude:  instance.StartPos.Latitude,
                Longitude: instance.StartPos.Longitude,
                Altitude:  instance.StartPos.Altitude,
        }

        // Generate call sign if not provided
        callSign := instance.CallSign
        if callSign == "" </span><span class="cov8" title="1">{
                callSign = f.generateCallSign(typeDef, instance.ID)
        }</span>

        // Determine platform type from configuration
        <span class="cov8" title="1">platformType := f.determinePlatformType(typeDef.Type)

        // Convert PlatformTypeDefinition to models.PlatformTypeDefinition
        modelTypeDef := f.convertToModelTypeDefinition(typeDef)

        // Create platform configuration
        platformConfig := &amp;models.PlatformConfiguration{
                ID:            instance.ID,
                Type:          typeDef.Type,
                Name:          instance.Name,
                StartPosition: startPos,
                Mission: models.MissionConfiguration{
                        Type:       "standard",
                        Parameters: make(map[string]interface{}),
                },
        }

        // Create universal platform
        platform := &amp;models.UniversalPlatform{
                ID:           instance.ID,
                PlatformType: platformType,
                TypeDef:      modelTypeDef,
                Config:       platformConfig,
                CallSign:     callSign,
                State: models.PlatformState{
                        ID:          instance.ID,
                        Position:    startPos,
                        Velocity:    models.Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                FuelRemaining: modelTypeDef.Physical.FuelCapacity,
                MissionTime:   0,
        }

        return platform, nil</span>
}

// CreateScenario creates all platforms for a given scenario - only loads specified platforms
func (f *PlatformFactory) CreateScenario(scenarioName string) ([]models.Platform, error) <span class="cov8" title="1">{
        scenario, exists := f.registry.Scenarios[scenarioName]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scenario not found: %s", scenarioName)
        }</span>

        <span class="cov8" title="1">var platforms []models.Platform

        // Only create platforms that are explicitly defined in the scenario
        for _, instance := range scenario.Instances </span><span class="cov8" title="1">{
                // Verify the platform type exists in configuration
                if !f.registry.HasType(instance.TypeID) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("platform type %s not found in configuration for instance %s",
                                instance.TypeID, instance.ID)
                }</span>

                <span class="cov8" title="1">platform, err := f.CreatePlatform(instance)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create platform %s: %w", instance.ID, err)
                }</span>

                // Set destination if specified
                <span class="cov8" title="1">if instance.Destination != nil </span><span class="cov0" title="0">{
                        dest := models.Position{
                                Latitude:  instance.Destination.Latitude,
                                Longitude: instance.Destination.Longitude,
                                Altitude:  instance.Destination.Altitude,
                        }
                        if err := platform.SetDestination(dest); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to set destination for %s: %w", instance.ID, err)
                        }</span>
                }

                <span class="cov8" title="1">platforms = append(platforms, platform)</span>
        }

        <span class="cov8" title="1">return platforms, nil</span>
}

// GetAvailablePlatformTypes returns only the platform types that are actually configured
func (f *PlatformFactory) GetAvailablePlatformTypes() map[string][]string <span class="cov8" title="1">{
        available := make(map[string][]string)

        // Only include platform types that are defined in the configuration
        if len(f.registry.AirborneTypes) &gt; 0 </span><span class="cov8" title="1">{
                var airborneTypes []string
                for typeID := range f.registry.AirborneTypes </span><span class="cov8" title="1">{
                        airborneTypes = append(airborneTypes, typeID)
                }</span>
                <span class="cov8" title="1">available["airborne"] = airborneTypes</span>
        }

        <span class="cov8" title="1">if len(f.registry.MaritimeTypes) &gt; 0 </span><span class="cov8" title="1">{
                var maritimeTypes []string
                for typeID := range f.registry.MaritimeTypes </span><span class="cov8" title="1">{
                        maritimeTypes = append(maritimeTypes, typeID)
                }</span>
                <span class="cov8" title="1">available["maritime"] = maritimeTypes</span>
        }

        <span class="cov8" title="1">if len(f.registry.LandTypes) &gt; 0 </span><span class="cov8" title="1">{
                var landTypes []string
                for typeID := range f.registry.LandTypes </span><span class="cov8" title="1">{
                        landTypes = append(landTypes, typeID)
                }</span>
                <span class="cov8" title="1">available["land"] = landTypes</span>
        }

        <span class="cov8" title="1">if len(f.registry.SpaceTypes) &gt; 0 </span><span class="cov0" title="0">{
                var spaceTypes []string
                for typeID := range f.registry.SpaceTypes </span><span class="cov0" title="0">{
                        spaceTypes = append(spaceTypes, typeID)
                }</span>
                <span class="cov0" title="0">available["space"] = spaceTypes</span>
        }

        <span class="cov8" title="1">return available</span>
}

// ValidateScenario validates that all platforms in a scenario reference valid types
func (f *PlatformFactory) ValidateScenario(scenarioName string) error <span class="cov8" title="1">{
        scenario, exists := f.registry.Scenarios[scenarioName]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("scenario not found: %s", scenarioName)
        }</span>

        <span class="cov8" title="1">for i, instance := range scenario.Instances </span><span class="cov8" title="1">{
                if !f.registry.HasType(instance.TypeID) </span><span class="cov8" title="1">{
                        return fmt.Errorf("scenario %s, instance %d (%s): unknown platform type %s",
                                scenarioName, i, instance.ID, instance.TypeID)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateCallSign generates a call sign based on the platform type definition
func (f *PlatformFactory) generateCallSign(typeDef *PlatformTypeDefinition, instanceID string) string <span class="cov8" title="1">{
        if typeDef.CallSignPrefix != "" </span><span class="cov8" title="1">{
                if typeDef.CallSignFormat != "" </span><span class="cov8" title="1">{
                        // Use custom format
                        callSign := strings.ReplaceAll(typeDef.CallSignFormat, "{prefix}", typeDef.CallSignPrefix)
                        callSign = strings.ReplaceAll(callSign, "{id}", instanceID)
                        return callSign
                }</span>
                // Default format: prefix + last 3 chars of ID
                <span class="cov8" title="1">suffix := instanceID
                if len(instanceID) &gt; 3 </span><span class="cov8" title="1">{
                        suffix = instanceID[len(instanceID)-3:]
                }</span>
                <span class="cov8" title="1">return typeDef.CallSignPrefix + suffix</span>
        }

        // Fallback to instance ID
        <span class="cov8" title="1">return instanceID</span>
}

// determinePlatformType converts string type to PlatformType enum
func (f *PlatformFactory) determinePlatformType(typeStr string) models.PlatformType <span class="cov8" title="1">{
        switch typeStr </span>{
        case "airborne":<span class="cov8" title="1">
                return models.PlatformTypeAirborne</span>
        case "maritime":<span class="cov8" title="1">
                return models.PlatformTypeMaritime</span>
        case "land":<span class="cov8" title="1">
                return models.PlatformTypeLand</span>
        case "space":<span class="cov8" title="1">
                return models.PlatformTypeSpace</span>
        default:<span class="cov8" title="1">
                return models.PlatformTypeAirborne</span> // Default fallback
        }
}

// convertToModelTypeDefinition converts config type definition to models type definition
func (f *PlatformFactory) convertToModelTypeDefinition(configDef *PlatformTypeDefinition) *models.PlatformTypeDefinition <span class="cov8" title="1">{
        return &amp;models.PlatformTypeDefinition{
                Class:    configDef.Class,
                Category: configDef.Category,
                Performance: models.PerformanceCharacteristics{
                        MaxSpeed:        configDef.MaxSpeed,
                        CruiseSpeed:     configDef.CruiseSpeed,
                        MaxAltitude:     configDef.MaxAltitude,
                        FuelConsumption: calculateFuelConsumption(configDef),
                        TurningRadius:   calculateTurningRadius(configDef),
                        Acceleration:    calculateAcceleration(configDef),
                        MaxGradient:     configDef.MaxGradient,
                        ClimbRate:       calculateClimbRate(configDef),

                        // Orbital characteristics
                        OrbitalVelocity: configDef.MaxSpeed, // Use max speed as orbital velocity for space platforms
                        OrbitalPeriod:   configDef.OrbitalPeriod,
                        OrbitalAltitude: configDef.MaxAltitude, // Use max altitude as orbital altitude
                        Inclination:     configDef.Inclination,
                        Eccentricity:    0.0, // Assume circular orbits for simplicity
                },
                Physical: models.PhysicalCharacteristics{
                        Length:       configDef.Length,
                        Width:        configDef.Width,
                        Height:       configDef.Height,
                        Mass:         configDef.Mass,
                        FuelCapacity: configDef.FuelCapacity,
                        Draft:        configDef.Draft,
                },
                Operational: models.OperationalCharacteristics{
                        Range: configDef.Range,
                },
                CallsignConf: models.CallsignConfiguration{
                        Prefix: configDef.CallSignPrefix,
                        Format: configDef.CallSignFormat,
                },
        }
}</span>

// Helper functions to calculate missing performance characteristics

func calculateFuelConsumption(def *PlatformTypeDefinition) float64 <span class="cov8" title="1">{
        // Estimate fuel consumption based on platform characteristics
        if def.FuelCapacity &gt; 0 &amp;&amp; def.Range &gt; 0 </span><span class="cov0" title="0">{
                // Fuel consumption rate in liters per meter
                fuelRate := def.FuelCapacity / def.Range
                // Convert to liters per second at cruise speed
                return fuelRate * def.CruiseSpeed
        }</span>
        <span class="cov8" title="1">return 0.1</span> // Default minimal fuel consumption
}

func calculateTurningRadius(def *PlatformTypeDefinition) float64 <span class="cov8" title="1">{
        // Estimate turning radius based on platform type and size
        switch def.Type </span>{
        case "airborne":<span class="cov8" title="1">
                // Aircraft turning radius based on speed and banking
                if def.CruiseSpeed &gt; 0 </span><span class="cov8" title="1">{
                        // Assume 30 degree bank angle for commercial aircraft
                        bankAngle := 30.0 * math.Pi / 180.0
                        return (def.CruiseSpeed * def.CruiseSpeed) / (9.81 * math.Tan(bankAngle))
                }</span>
                <span class="cov8" title="1">return def.Length * 10</span> // Fallback: 10x length
        case "maritime":<span class="cov8" title="1">
                // Ship turning radius
                return def.Length * 5</span> // Ships typically turn in 5-10 ship lengths
        case "land":<span class="cov0" title="0">
                // Vehicle turning radius
                return def.Length * 2</span> // Vehicles can turn tighter
        case "space":<span class="cov0" title="0">
                // Orbital mechanics - very large turning radius
                return def.MaxAltitude</span> // Use orbital altitude as turning "radius"
        default:<span class="cov0" title="0">
                return def.Length * 3</span>
        }
}

func calculateAcceleration(def *PlatformTypeDefinition) float64 <span class="cov8" title="1">{
        // Estimate acceleration based on platform type
        switch def.Type </span>{
        case "airborne":<span class="cov8" title="1">
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 5.0 // Military aircraft: higher acceleration
                }</span>
                <span class="cov8" title="1">return 2.0</span> // Commercial aircraft: moderate acceleration
        case "maritime":<span class="cov8" title="1">
                return 0.5</span> // Ships: slow acceleration
        case "land":<span class="cov0" title="0">
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 3.0 // Military vehicles: good acceleration
                }</span>
                <span class="cov0" title="0">return 2.0</span> // Civilian vehicles: moderate acceleration
        case "space":<span class="cov0" title="0">
                return 0.01</span> // Space platforms: very low acceleration
        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

func calculateClimbRate(def *PlatformTypeDefinition) float64 <span class="cov8" title="1">{
        // Estimate climb rate for aircraft
        if def.Type == "airborne" </span><span class="cov8" title="1">{
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 20.0 // Military aircraft: higher climb rate
                }</span>
                <span class="cov8" title="1">return 10.0</span> // Commercial aircraft: standard climb rate
        }
        <span class="cov8" title="1">return 0.0</span> // Non-aircraft don't climb
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// AirbornePlatform represents aircraft platforms with enhanced physics
type AirbornePlatform struct {
        // Embed UniversalPlatform for base functionality
        UniversalPlatform

        // Enhanced flight characteristics (aircraft-specific)
        MaxRollRate     float64 // degrees/second
        MaxPitchRate    float64 // degrees/second
        MaxYawRate      float64 // degrees/second
        MaxBankAngle    float64 // degrees
        MaxPitchAngle   float64 // degrees
        MaxLoadFactor   float64 // g-force
        StallSpeed      float64 // m/s
        MaxAcceleration float64 // m/s¬≤
        MaxDeceleration float64 // m/s¬≤

        // Physical characteristics (additional to base)
        WingArea        float64         // m¬≤
        WingLoading     float64         // kg/m¬≤
        CenterOfGravity CenterOfGravity // center of mass location

        // Flight state
        FlightPhase FlightPhase // takeoff, climb, cruise, descent, approach, landing
}

// FlightPhase represents the current phase of flight
type FlightPhase string

const (
        FlightPhaseTakeoff  FlightPhase = "takeoff"
        FlightPhaseClimb    FlightPhase = "climb"
        FlightPhaseCruise   FlightPhase = "cruise"
        FlightPhaseDescent  FlightPhase = "descent"
        FlightPhaseApproach FlightPhase = "approach"
        FlightPhaseLanding  FlightPhase = "landing"
        FlightPhaseParked   FlightPhase = "parked"
)

// Core Platform interface implementation - delegate to embedded UniversalPlatform
func (a *AirbornePlatform) GetID() string           <span class="cov8" title="1">{ return a.UniversalPlatform.GetID() }</span>
func (a *AirbornePlatform) GetType() PlatformType   <span class="cov8" title="1">{ return a.UniversalPlatform.GetType() }</span>
func (a *AirbornePlatform) GetClass() string        <span class="cov8" title="1">{ return a.UniversalPlatform.GetClass() }</span>
func (a *AirbornePlatform) GetName() string         <span class="cov8" title="1">{ return a.UniversalPlatform.GetName() }</span>
func (a *AirbornePlatform) GetCallSign() string     <span class="cov0" title="0">{ return a.UniversalPlatform.GetCallSign() }</span>
func (a *AirbornePlatform) GetState() PlatformState <span class="cov8" title="1">{ return a.UniversalPlatform.GetState() }</span>
func (a *AirbornePlatform) GetMaxSpeed() float64    <span class="cov8" title="1">{ return a.UniversalPlatform.GetMaxSpeed() }</span>
func (a *AirbornePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return a.UniversalPlatform.GetMaxAltitude() }</span>
func (a *AirbornePlatform) GetLength() float64      <span class="cov8" title="1">{ return a.UniversalPlatform.GetLength() }</span>
func (a *AirbornePlatform) GetWidth() float64       <span class="cov0" title="0">{ return a.UniversalPlatform.GetWidth() }</span>
func (a *AirbornePlatform) GetHeight() float64      <span class="cov0" title="0">{ return a.UniversalPlatform.GetHeight() }</span>
func (a *AirbornePlatform) GetMass() float64        <span class="cov0" title="0">{ return a.UniversalPlatform.GetMass() }</span>

func (a *AirbornePlatform) UpdateState(state PlatformState) <span class="cov8" title="1">{
        a.UniversalPlatform.UpdateState(state)
}</span>

func (a *AirbornePlatform) SetDestination(pos Position) error <span class="cov8" title="1">{
        return a.UniversalPlatform.SetDestination(pos)
}</span>

// Enhanced 3D physics methods
func (a *AirbornePlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        // Initialize physics state with aircraft characteristics
        a.UniversalPlatform.State.Physics = PhysicsState{
                Position:            a.UniversalPlatform.State.Position,
                Velocity:            a.UniversalPlatform.State.Velocity,
                Acceleration:        Acceleration{},
                Attitude:            Attitude{Yaw: a.UniversalPlatform.State.Heading},
                AngularVelocity:     AngularVelocity{},
                AngularAcceleration: AngularAcceleration{},
                Mass:                a.UniversalPlatform.GetMass(),
                MomentOfInertia:     a.calculateMomentOfInertia(),
                Forces:              Forces{Weight: a.UniversalPlatform.GetMass() * 9.81},
                Torques:             Torques{},
        }
}</span>

func (a *AirbornePlatform) calculateMomentOfInertia() MomentOfInertia <span class="cov0" title="0">{
        // Calculate realistic moment of inertia for aircraft
        mass := a.UniversalPlatform.GetMass()
        length := a.UniversalPlatform.GetLength()
        width := a.UniversalPlatform.GetWidth()
        height := a.UniversalPlatform.GetHeight()

        return MomentOfInertia{
                Ixx: mass * (width*width + height*height) / 20,   // Roll axis
                Iyy: mass * (length*length + height*height) / 20, // Pitch axis
                Izz: mass * (length*length + width*width) / 20,   // Yaw axis
        }
}</span>

func (a *AirbornePlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov0" title="0">{
        // Use the existing enhanced Update method which already includes 3D physics
        return a.Update(deltaTime)
}</span>

func (a *AirbornePlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return a.UniversalPlatform.State.Physics
}</span>

func (a *AirbornePlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        a.UniversalPlatform.State.Physics = physics
        // Update legacy compatibility fields
        a.UniversalPlatform.State.Position = physics.Position
        a.UniversalPlatform.State.Velocity = physics.Velocity
        a.UniversalPlatform.State.Heading = physics.Attitude.Yaw
}</span>

// Update implements enhanced aircraft physics and flight dynamics
func (a *AirbornePlatform) Update(deltaTime time.Duration) error <span class="cov8" title="1">{
        if a.UniversalPlatform.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">dt := deltaTime.Seconds()

        // Calculate 3D distance and bearing to destination
        deltaLat := a.UniversalPlatform.Destination.Latitude - a.UniversalPlatform.State.Position.Latitude
        deltaLon := a.UniversalPlatform.Destination.Longitude - a.UniversalPlatform.State.Position.Longitude
        deltaAlt := a.UniversalPlatform.Destination.Altitude - a.UniversalPlatform.State.Position.Altitude

        distance := math.Sqrt(deltaLat*deltaLat + deltaLon*deltaLon)
        distance3D := math.Sqrt(distance*distance + (deltaAlt/111320)*(deltaAlt/111320))

        if distance3D &lt; 0.001 </span><span class="cov0" title="0">{ // Close enough
                a.UniversalPlatform.Destination = nil
                return nil
        }</span>

        // Initialize physics if not already done
        <span class="cov8" title="1">if a.UniversalPlatform.State.Physics.Mass == 0 </span><span class="cov0" title="0">{
                a.Initialize3DPhysics()
        }</span>

        // Enhanced flight physics
        <span class="cov8" title="1">a.updateFlightPhase()
        a.updateFlightDynamics(dt)

        // Apply aerodynamic forces and moments
        a.calculateAerodynamicForces()
        a.updateAttitude(dt)

        // Update position based on velocity
        a.updatePosition(dt)

        a.UniversalPlatform.State.LastUpdated = time.Now()
        return nil</span>
}

// updateFlightPhase determines the current phase of flight
func (a *AirbornePlatform) updateFlightPhase() <span class="cov8" title="1">{
        // If we have a destination and are at low altitude with low speed, start takeoff
        if a.UniversalPlatform.Destination != nil &amp;&amp; a.UniversalPlatform.State.Position.Altitude &lt; 100 &amp;&amp; a.UniversalPlatform.State.Speed &lt; 50 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseTakeoff
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &lt; 100 &amp;&amp; a.UniversalPlatform.State.Speed &lt; 50 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseParked
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &lt; 300 &amp;&amp; a.UniversalPlatform.State.Velocity.Up &gt; 0 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseTakeoff
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Velocity.Up &gt; 5 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseClimb
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Velocity.Up &lt; -5 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseDescent
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &gt; 1000 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseCruise
        }</span> else<span class="cov0" title="0"> {
                a.FlightPhase = FlightPhaseApproach
        }</span>
}

// updateFlightDynamics applies realistic flight dynamics
func (a *AirbornePlatform) updateFlightDynamics(dt float64) <span class="cov8" title="1">{
        // Calculate target velocity based on flight phase
        var targetSpeed float64
        var targetAltitude float64

        cruiseSpeed := a.UniversalPlatform.GetMaxSpeed() * 0.9  // Use 90% of max speed as cruise
        cruiseAlt := a.UniversalPlatform.GetMaxAltitude() * 0.8 // Use 80% of max altitude as cruise

        switch a.FlightPhase </span>{
        case FlightPhaseTakeoff:<span class="cov8" title="1">
                targetSpeed = math.Min(cruiseSpeed*0.8, a.UniversalPlatform.State.Speed+a.MaxAcceleration*dt)
                targetAltitude = a.UniversalPlatform.State.Position.Altitude + 10*dt</span> // 10 m/s climb rate
        case FlightPhaseClimb:<span class="cov0" title="0">
                targetSpeed = cruiseSpeed
                targetAltitude = math.Min(a.UniversalPlatform.Destination.Altitude, a.UniversalPlatform.State.Position.Altitude+15*dt)</span>
        case FlightPhaseCruise:<span class="cov8" title="1">
                targetSpeed = cruiseSpeed
                targetAltitude = cruiseAlt</span>
        case FlightPhaseDescent:<span class="cov0" title="0">
                targetSpeed = cruiseSpeed * 0.9
                targetAltitude = math.Max(a.UniversalPlatform.Destination.Altitude, a.UniversalPlatform.State.Position.Altitude-12*dt)</span>
        case FlightPhaseApproach:<span class="cov0" title="0">
                targetSpeed = math.Max(a.StallSpeed*1.3, cruiseSpeed*0.6)
                targetAltitude = a.UniversalPlatform.Destination.Altitude</span>
        default:<span class="cov0" title="0">
                targetSpeed = 0
                targetAltitude = a.UniversalPlatform.State.Position.Altitude</span>
        }

        // Apply acceleration constraints
        <span class="cov8" title="1">speedDiff := targetSpeed - a.UniversalPlatform.State.Speed
        maxSpeedChange := a.MaxAcceleration * dt

        if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed = targetSpeed
        }</span> else<span class="cov8" title="1"> if speedDiff &gt; 0 </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed += maxSpeedChange
        }</span> else<span class="cov0" title="0"> {
                a.UniversalPlatform.State.Speed -= math.Min(maxSpeedChange, a.MaxDeceleration*dt)
        }</span>

        // Ensure minimum flying speed
        <span class="cov8" title="1">if a.UniversalPlatform.State.Position.Altitude &gt; 50 &amp;&amp; a.UniversalPlatform.State.Speed &lt; a.StallSpeed </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed = a.StallSpeed
        }</span>

        // Calculate climb/descent rate
        <span class="cov8" title="1">altDiff := targetAltitude - a.UniversalPlatform.State.Position.Altitude
        a.UniversalPlatform.State.Velocity.Up = math.Max(-15, math.Min(15, altDiff/dt))</span> // Limit vertical speed
}

// calculateAerodynamicForces computes forces acting on the aircraft
func (a *AirbornePlatform) calculateAerodynamicForces() <span class="cov8" title="1">{
        // Air density at altitude (simplified)
        airDensity := 1.225 * math.Exp(-a.UniversalPlatform.State.Position.Altitude/8400) // kg/m¬≥

        // Dynamic pressure
        dynamicPressure := 0.5 * airDensity * a.UniversalPlatform.State.Speed * a.UniversalPlatform.State.Speed

        // Lift force (simplified)
        liftCoeff := 0.8 // Typical cruise lift coefficient
        a.UniversalPlatform.State.Physics.Forces.Lift = liftCoeff * dynamicPressure * a.WingArea

        // Drag force
        dragCoeff := 0.025 + (liftCoeff*liftCoeff)/(math.Pi*8*0.8) // Induced drag
        a.UniversalPlatform.State.Physics.Forces.Drag = dragCoeff * dynamicPressure * a.WingArea

        // Weight
        gravity := 9.81
        a.UniversalPlatform.State.Physics.Forces.Weight = a.UniversalPlatform.GetMass() * gravity

        // Thrust (to maintain speed)
        a.UniversalPlatform.State.Physics.Forces.Thrust = a.UniversalPlatform.State.Physics.Forces.Drag

        // Calculate accelerations
        mass := a.UniversalPlatform.GetMass()
        a.UniversalPlatform.State.Physics.Acceleration.North = (a.UniversalPlatform.State.Physics.Forces.Thrust - a.UniversalPlatform.State.Physics.Forces.Drag) / mass
        a.UniversalPlatform.State.Physics.Acceleration.Up = (a.UniversalPlatform.State.Physics.Forces.Lift - a.UniversalPlatform.State.Physics.Forces.Weight) / mass
}</span>

// updateAttitude updates aircraft orientation based on flight dynamics
func (a *AirbornePlatform) updateAttitude(dt float64) <span class="cov8" title="1">{
        // Calculate desired bank angle for turns
        if a.UniversalPlatform.Destination != nil </span><span class="cov8" title="1">{
                desiredHeading := a.calculateBearing(a.UniversalPlatform.State.Position, *a.UniversalPlatform.Destination)
                headingError := desiredHeading - a.UniversalPlatform.State.Heading

                // Normalize heading error to [-180, 180]
                for headingError &gt; 180 </span><span class="cov8" title="1">{
                        headingError -= 360
                }</span>
                <span class="cov8" title="1">for headingError &lt; -180 </span><span class="cov0" title="0">{
                        headingError += 360
                }</span>

                // Calculate bank angle for coordinated turn - use a proportional controller
                // Larger heading errors require more bank angle
                <span class="cov8" title="1">maxBankForTurn := math.Min(a.MaxBankAngle, 30) // Limit to 30 degrees for normal flight

                // Use a gain factor to make the aircraft more responsive to heading errors
                bankGain := 1.5 // Adjust this to make turns more or less aggressive
                desiredBank := math.Max(-maxBankForTurn, math.Min(maxBankForTurn, headingError*bankGain))

                // Only bank if there's a significant heading error (more than 2 degrees)
                if math.Abs(headingError) &gt; 2.0 </span><span class="cov8" title="1">{
                        // Apply roll rate limits
                        rollError := desiredBank - a.UniversalPlatform.State.Physics.Attitude.Roll
                        maxRollChange := a.MaxRollRate * dt

                        if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll = desiredBank
                        }</span> else<span class="cov8" title="1"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                        }</span> else<span class="cov8" title="1"> {
                                a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Level off if close to desired heading
                        rollError := -a.UniversalPlatform.State.Physics.Attitude.Roll
                        maxRollChange := a.MaxRollRate * dt

                        if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll = 0
                        }</span> else<span class="cov0" title="0"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                        }</span> else<span class="cov0" title="0"> {
                                a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                        }</span>
                }

                // Calculate turn rate from bank angle (coordinated turn formula)
                <span class="cov8" title="1">if a.UniversalPlatform.State.Speed &gt; 0 &amp;&amp; math.Abs(a.UniversalPlatform.State.Physics.Attitude.Roll) &gt; 1.0 </span><span class="cov8" title="1">{
                        // Turn rate = (g * tan(bank_angle)) / velocity (in radians/second)
                        bankRad := a.UniversalPlatform.State.Physics.Attitude.Roll * math.Pi / 180
                        turnRate := (9.81 * math.Tan(bankRad)) / a.UniversalPlatform.State.Speed * 180 / math.Pi // Convert to degrees/second
                        a.UniversalPlatform.State.Physics.AngularVelocity.YawRate = turnRate
                        a.UniversalPlatform.State.Heading += turnRate * dt

                        // Normalize heading to [0, 360)
                        if a.UniversalPlatform.State.Heading &gt;= 360 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Heading -= 360
                        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Heading &lt; 0 </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Heading += 360
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // No destination - level off the aircraft
                rollError := -a.UniversalPlatform.State.Physics.Attitude.Roll
                maxRollChange := a.MaxRollRate * dt

                if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Roll = 0
                }</span> else<span class="cov0" title="0"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                }</span> else<span class="cov0" title="0"> {
                        a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                }</span>
        }

        // Calculate pitch angle based on climb/descent
        <span class="cov8" title="1">if a.UniversalPlatform.State.Speed &gt; 0 </span><span class="cov8" title="1">{
                desiredPitch := math.Atan(a.UniversalPlatform.State.Velocity.Up/a.UniversalPlatform.State.Speed) * 180 / math.Pi
                desiredPitch = math.Max(-a.MaxPitchAngle, math.Min(a.MaxPitchAngle, desiredPitch))

                pitchError := desiredPitch - a.UniversalPlatform.State.Physics.Attitude.Pitch
                maxPitchChange := a.MaxPitchRate * dt

                if math.Abs(pitchError) &lt;= maxPitchChange </span><span class="cov8" title="1">{
                        a.UniversalPlatform.State.Physics.Attitude.Pitch = desiredPitch
                }</span> else<span class="cov0" title="0"> if pitchError &gt; 0 </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Pitch += maxPitchChange
                }</span> else<span class="cov0" title="0"> {
                        a.UniversalPlatform.State.Physics.Attitude.Pitch -= maxPitchChange
                }</span>
        }

        // Update yaw to match heading
        <span class="cov8" title="1">a.UniversalPlatform.State.Physics.Attitude.Yaw = a.UniversalPlatform.State.Heading
        // Update roll for compatibility
        a.UniversalPlatform.State.Roll = a.UniversalPlatform.State.Physics.Attitude.Roll</span>
}

// updatePosition calculates new position based on current heading and speed
func (a *AirbornePlatform) updatePosition(deltaSeconds float64) <span class="cov8" title="1">{
        if a.UniversalPlatform.State.Speed &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert heading to radians (0¬∞ = North, 90¬∞ = East)
        <span class="cov8" title="1">headingRad := a.UniversalPlatform.State.Heading * math.Pi / 180.0

        // Calculate distance moved
        distance := a.UniversalPlatform.State.Speed * deltaSeconds

        // Earth radius in meters
        earthRadius := 6371000.0

        // Calculate new position
        deltaLat := (distance * math.Cos(headingRad)) / earthRadius * 180.0 / math.Pi

        // Split long calculation for longitude delta
        latRad := a.UniversalPlatform.State.Position.Latitude * math.Pi / 180.0
        deltaLon := (distance * math.Sin(headingRad)) / earthRadius * 180.0 / math.Pi / math.Cos(latRad)

        a.UniversalPlatform.State.Position.Latitude += deltaLat
        a.UniversalPlatform.State.Position.Longitude += deltaLon

        // Update altitude based on climb rate
        climbRate := a.UniversalPlatform.State.Velocity.Up
        a.UniversalPlatform.State.Position.Altitude += climbRate * deltaSeconds

        // Sync with physics state
        a.UniversalPlatform.State.Physics.Position = a.UniversalPlatform.State.Position
        a.UniversalPlatform.State.Physics.Velocity.North = a.UniversalPlatform.State.Speed * math.Cos(headingRad)
        a.UniversalPlatform.State.Physics.Velocity.East = a.UniversalPlatform.State.Speed * math.Sin(headingRad)
        a.UniversalPlatform.State.Physics.Velocity.Up = climbRate</span>
}

// calculateBearing calculates bearing from one position to another
func (a *AirbornePlatform) calculateBearing(from, to Position) float64 <span class="cov8" title="1">{
        lat1 := from.Latitude * math.Pi / 180.0
        lat2 := to.Latitude * math.Pi / 180.0
        deltaLon := (to.Longitude - from.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi

        // Normalize to [0, 360)
        for bearing &lt; 0 </span><span class="cov8" title="1">{
                bearing += 360
        }</span>
        <span class="cov8" title="1">for bearing &gt;= 360 </span><span class="cov0" title="0">{
                bearing -= 360
        }</span>

        <span class="cov8" title="1">return bearing</span>
}

// Aircraft factory functions with enhanced physics parameters

// NewBoeing737_800 creates a Boeing 737-800 with realistic physics
func NewBoeing737_800(id, flightNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 79010.0   // kg
        wingArea := 124.6 // m¬≤

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "Boeing 737-800",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      257,   // m/s (500 kts)
                        CruiseSpeed:   230,   // m/s (447 kts)
                        MaxAltitude:   12500, // meters (41,000 ft)
                        ClimbRate:     15,    // m/s
                        Acceleration:  1.5,   // m/s¬≤
                        TurningRadius: 1000,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 39.5, // meters
                        Width:  35.8, // wingspan
                        Height: 12.5, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: flightNumber,
                Type: "Boeing 737-800",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     flightNumber,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 15.0 * 15.0,
                                        Iyy: mass * 20.0 * 20.0,
                                        Izz: mass * 20.0 * 20.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       15,  // degrees/second
                MaxPitchRate:      5,   // degrees/second
                MaxYawRate:        3,   // degrees/second
                MaxBankAngle:      30,  // degrees (normal ops)
                MaxPitchAngle:     15,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        77,  // m/s (150 kts)
                MaxAcceleration:   1.5, // m/s¬≤
                MaxDeceleration:   3.0, // m/s¬≤
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 18.0, Y: 0, Z: 2.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewAirbusA320 creates an Airbus A320 with realistic physics
func NewAirbusA320(id, flightNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 78000.0   // kg
        wingArea := 122.6 // m¬≤

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "Airbus A320",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      257,   // m/s (500 kts)
                        CruiseSpeed:   230,   // m/s (447 kts)
                        MaxAltitude:   12000, // meters (39,370 ft)
                        ClimbRate:     15,    // m/s
                        Acceleration:  1.5,   // m/s¬≤
                        TurningRadius: 1000,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 37.6, // meters
                        Width:  36.0, // wingspan
                        Height: 11.8, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: flightNumber,
                Type: "Airbus A320",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     flightNumber,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 18.0 * 18.0,
                                        Iyy: mass * 19.0 * 19.0,
                                        Izz: mass * 19.0 * 19.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       15,  // degrees/second
                MaxPitchRate:      5,   // degrees/second
                MaxYawRate:        3,   // degrees/second
                MaxBankAngle:      30,  // degrees
                MaxPitchAngle:     15,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        77,  // m/s (150 kts)
                MaxAcceleration:   1.5, // m/s¬≤
                MaxDeceleration:   3.0, // m/s¬≤
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 17.0, Y: 0, Z: 2.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewF16FightingFalcon creates an F-16 with enhanced military flight dynamics
func NewF16FightingFalcon(id, tailNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 19187.0   // kg
        wingArea := 27.87 // m¬≤

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "F-16 Fighting Falcon",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      617,   // m/s (Mach 2.0+ at altitude)
                        CruiseSpeed:   257,   // m/s (500 kts)
                        MaxAltitude:   15240, // meters (50,000 ft)
                        ClimbRate:     25,    // m/s
                        Acceleration:  8.0,   // m/s¬≤
                        TurningRadius: 500,   // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 15.0, // meters
                        Width:  10.0, // wingspan
                        Height: 5.1,  // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: tailNumber,
                Type: "F-16 Fighting Falcon",
        }

        callSign := fmt.Sprintf("VIPER%s", tailNumber[len(tailNumber)-3:])

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     callSign,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 5.0 * 5.0,
                                        Iyy: mass * 7.5 * 7.5,
                                        Izz: mass * 7.5 * 7.5,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       720,  // degrees/second (highly maneuverable)
                MaxPitchRate:      40,   // degrees/second
                MaxYawRate:        20,   // degrees/second
                MaxBankAngle:      90,   // degrees (fighter aircraft)
                MaxPitchAngle:     60,   // degrees
                MaxLoadFactor:     9.0,  // g-force
                StallSpeed:        93,   // m/s (180 kts)
                MaxAcceleration:   8.0,  // m/s¬≤ (high thrust-to-weight)
                MaxDeceleration:   15.0, // m/s¬≤ (air brakes)
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 7.5, Y: 0, Z: 1.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewC130Hercules creates a C-130 military transport with cargo aircraft characteristics
func NewC130Hercules(id, tailNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 70300.0   // kg
        wingArea := 162.1 // m¬≤

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "C-130 Hercules",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      190,   // m/s (370 kts)
                        CruiseSpeed:   160,   // m/s (310 kts)
                        MaxAltitude:   10060, // meters (33,000 ft)
                        ClimbRate:     8,     // m/s
                        Acceleration:  1.0,   // m/s¬≤
                        TurningRadius: 1500,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 29.8, // meters
                        Width:  40.4, // wingspan
                        Height: 11.7, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: tailNumber,
                Type: "C-130 Hercules",
        }

        callSign := fmt.Sprintf("HERKY%s", tailNumber[len(tailNumber)-2:])

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     callSign,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 20.0 * 20.0,
                                        Iyy: mass * 15.0 * 15.0,
                                        Izz: mass * 25.0 * 25.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       10,  // degrees/second (large aircraft)
                MaxPitchRate:      3,   // degrees/second
                MaxYawRate:        2,   // degrees/second
                MaxBankAngle:      25,  // degrees (transport aircraft)
                MaxPitchAngle:     10,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        61,  // m/s (119 kts)
                MaxAcceleration:   1.0, // m/s¬≤
                MaxDeceleration:   2.5, // m/s¬≤
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 14.9, Y: 0, Z: 3.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "fmt"
        "time"
)

// UnifiedPlatformFactory provides factory functions for creating UniversalPlatform instances
// with realistic configurations for different platform types

// Helper function to create base platform structure
func createBasePlatform(id string, platformType PlatformType, typeDef *PlatformTypeDefinition,
        config *PlatformConfiguration, startPos Position, callSign string, fuelRemaining float64) *UniversalPlatform <span class="cov8" title="1">{
        return &amp;UniversalPlatform{
                ID:           id,
                PlatformType: platformType,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position:        startPos,
                                Mass:            typeDef.Physical.Mass,
                                MomentOfInertia: calculateMomentOfInertia(typeDef.Physical.Mass, platformType),
                        },
                },
                CallSign:      callSign,
                FuelRemaining: fuelRemaining,
                MissionTime:   0,
                SystemStatus:  createSystemStatus(platformType, typeDef.Class),
                lastPosition:  startPos,
                acceleration:  0,
        }
}</span>

// Helper function to calculate moment of inertia based on platform type
func calculateMomentOfInertia(mass float64, platformType PlatformType) MomentOfInertia <span class="cov8" title="1">{
        switch platformType </span>{
        case PlatformTypeAirborne:<span class="cov8" title="1">
                return MomentOfInertia{
                        Ixx: mass * 5.0 * 5.0,
                        Iyy: mass * 7.5 * 7.5,
                        Izz: mass * 7.5 * 7.5,
                }</span>
        case PlatformTypeLand:<span class="cov8" title="1">
                return MomentOfInertia{
                        Ixx: mass * 1.8 * 1.8,
                        Iyy: mass * 4.9 * 4.9,
                        Izz: mass * 4.9 * 4.9,
                }</span>
        case PlatformTypeMaritime:<span class="cov8" title="1">
                return MomentOfInertia{
                        Ixx: mass * 10.0 * 10.0,
                        Iyy: mass * 77.5 * 77.5,
                        Izz: mass * 77.5 * 77.5,
                }</span>
        case PlatformTypeSpace:<span class="cov8" title="1">
                return MomentOfInertia{
                        Ixx: mass * 2.5 * 2.5,
                        Iyy: mass * 2.5 * 2.5,
                        Izz: mass * 2.5 * 2.5,
                }</span>
        default:<span class="cov0" title="0">
                return MomentOfInertia{
                        Ixx: mass * 5.0 * 5.0,
                        Iyy: mass * 5.0 * 5.0,
                        Izz: mass * 5.0 * 5.0,
                }</span>
        }
}

// Helper function to create system status based on platform type and class
func createSystemStatus(platformType PlatformType, class string) SystemStatus <span class="cov8" title="1">{
        // Determine if this is a civilian/commercial platform
        isCivilian := isCivilianPlatform(class)

        switch platformType </span>{
        case PlatformTypeAirborne, PlatformTypeLand, PlatformTypeMaritime:<span class="cov8" title="1">
                weaponStatus := WeaponStatusArmed
                weaponSystemOperational := true
                weaponSystemEfficiency := 1.0

                // Civilian platforms should not be armed
                if isCivilian </span><span class="cov8" title="1">{
                        weaponStatus = WeaponStatusNA
                        weaponSystemOperational = false
                        weaponSystemEfficiency = 0.0
                }</span>

                <span class="cov8" title="1">return SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.98},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.99},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.95},
                        WeaponSystem:        SystemState{Operational: weaponSystemOperational, Efficiency: weaponSystemEfficiency},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        weaponStatus,
                }</span>
        case PlatformTypeSpace:<span class="cov8" title="1">
                return SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.95},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.98},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.97},
                        WeaponSystem:        SystemState{Operational: false, Efficiency: 0.0},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        WeaponStatusNA,
                }</span>
        default:<span class="cov0" title="0">
                return SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 1.0},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 1.0},
                        WeaponSystem:        SystemState{Operational: false, Efficiency: 0.0},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        WeaponStatusNA,
                }</span>
        }
}

// Helper function to determine if a platform class represents a civilian platform
func isCivilianPlatform(class string) bool <span class="cov8" title="1">{
        civilianClasses := []string{
                "Civilian Car",
                "Commercial Aircraft",
                "Commercial Ship",
                "Cargo Aircraft",
                "Passenger Aircraft",
                "Commercial Truck",
                "Civilian Vehicle",
        }

        for _, civilianClass := range civilianClasses </span><span class="cov8" title="1">{
                if class == civilianClass </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Aircraft Factories

// NewBoeing737_800Universal creates a Boeing 737-800 using UniversalPlatform
func NewBoeing737_800Universal(id, flightNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 79010.0   // kg
        wingArea := 124.6 // m¬≤

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Boeing 737-800",
                Category: "commercial",
                Physical: PhysicalCharacteristics{
                        Length:      39.5,
                        Width:       35.8, // wingspan
                        Height:      12.5,
                        Mass:        mass,
                        WingArea:    wingArea,
                        FrontalArea: 15.0, // Estimated
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:          257,     // m/s (500 kts)
                        CruiseSpeed:       230,     // m/s (447 kts)
                        MaxAltitude:       12500,   // meters (41,000 ft)
                        FuelConsumption:   3.5,     // kg/s fuel consumption rate
                        TurningRadius:     3000,    // meters turning radius
                        Acceleration:      1.5,     // m/s¬≤
                        ClimbRate:         12.0,    // m/s climb rate
                        Range:             5665000, // meters range
                        MaxThrustToWeight: 0.28,    // Typical for commercial aircraft
                        MaxRollRate:       15,      // degrees/second
                        MaxPitchRate:      5,       // degrees/second
                        MaxYawRate:        3,       // degrees/second
                        MaxBankAngle:      30,      // degrees (normal ops)
                        MaxPitchAngle:     15,      // degrees
                        MaxLoadFactor:     2.5,     // g-force
                        StallSpeed:        77,      // m/s (150 kts)
                        MaxAcceleration:   1.5,     // m/s¬≤
                        MaxDeceleration:   3.0,     // m/s¬≤
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    100000, // 100km weather radar
                        OpticalRange:  50000,  // 50km visibility
                        InfraredRange: 20000,  // 20km
                },
                Operational: OperationalCharacteristics{
                        Range:             5665000, // meters (3,060 nm)
                        PassengerCapacity: 189,
                        CrewCapacity:      6,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "airborne",
                Name:          flightNumber,
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeAirborne, typeDef, config, startPos, flightNumber, 26000)

        return platform
}</span>

// NewF16FightingFalconUniversal creates an F-16 using UniversalPlatform
func NewF16FightingFalconUniversal(id, tailNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 19187.0   // kg
        wingArea := 27.87 // m¬≤

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "F-16 Fighting Falcon",
                Category: "military",
                Physical: PhysicalCharacteristics{
                        Length:       15.0,
                        Width:        10.0, // wingspan
                        Height:       5.1,
                        Mass:         mass,
                        WingArea:     wingArea,
                        FrontalArea:  8.0,  // Estimated
                        FuelCapacity: 3200, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:          617,   // m/s (Mach 2.0+ at altitude)
                        CruiseSpeed:       257,   // m/s (500 kts)
                        MaxAltitude:       15240, // meters (50,000 ft)
                        MaxThrustToWeight: 1.2,   // High performance fighter
                        MaxRollRate:       720,   // degrees/second
                        MaxPitchRate:      40,    // degrees/second
                        MaxYawRate:        20,    // degrees/second
                        MaxBankAngle:      90,    // degrees
                        MaxPitchAngle:     60,    // degrees
                        MaxLoadFactor:     9.0,   // g-force
                        StallSpeed:        93,    // m/s (180 kts)
                        MaxAcceleration:   8.0,   // m/s¬≤
                        MaxDeceleration:   15.0,  // m/s¬≤
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    200000, // 200km air-to-air radar
                        OpticalRange:  50000,  // 50km
                        InfraredRange: 100000, // 100km IRST
                },
                Operational: OperationalCharacteristics{
                        Range:         2220000, // meters (1,200 nm)
                        CrewCapacity:  1,
                        WeaponSystems: []string{"AIM-120", "AIM-9", "20mm Cannon"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "airborne",
                Name:          tailNumber,
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeAirborne, typeDef, config, startPos, fmt.Sprintf("VIPER%s", tailNumber[len(tailNumber)-3:]), 3200)

        return platform
}</span>

// Land Vehicle Factories

// NewM1A2AbramsUniversal creates an M1A2 Abrams tank using UniversalPlatform
func NewM1A2AbramsUniversal(id, unitDesignation string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 62000.0 // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "M1A2 Abrams MBT",
                Category: "military",
                Physical: PhysicalCharacteristics{
                        Length:       9.8,
                        Width:        3.7,
                        Height:       2.4,
                        Mass:         mass,
                        FrontalArea:  8.9,  // width √ó height
                        FuelCapacity: 1900, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        20,   // m/s (45 mph)
                        CruiseSpeed:     13.4, // m/s (30 mph)
                        MaxAltitude:     0,    // Ground vehicle
                        MaxAcceleration: 2.0,  // m/s¬≤
                        MaxDeceleration: 8.0,  // m/s¬≤
                        MaxGradient:     30.0, // degrees
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      false, // Ground vehicles don't typically have radar
                        HasCompass:    true,
                        RadarRange:    0,
                        OpticalRange:  5000,  // 5km visual
                        InfraredRange: 10000, // 10km thermal imaging
                },
                Operational: OperationalCharacteristics{
                        Range:         426000, // meters (265 miles)
                        CrewCapacity:  4,
                        WeaponSystems: []string{"120mm M256", "M240 Machine Gun"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "land",
                Name:          unitDesignation,
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeLand, typeDef, config, startPos, fmt.Sprintf("ARMOR%s", id[len(id)-2:]), 1900)

        return platform
}</span>

// Maritime Factories

// NewArleighBurkeDestroyerUniversal creates an Arleigh Burke destroyer using UniversalPlatform
func NewArleighBurkeDestroyerUniversal(id, shipName string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 0 // Sea level
        mass := 9200000.0     // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Arleigh Burke-class",
                Category: "naval",
                Physical: PhysicalCharacteristics{
                        Length:       155,
                        Width:        20, // beam
                        Height:       18, // above waterline
                        Mass:         mass,
                        WetArea:      3100,    // underwater hull area
                        Draft:        6.3,     // depth below waterline
                        FuelCapacity: 1200000, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        15.4, // m/s (30+ knots)
                        CruiseSpeed:     10.3, // m/s (20 knots)
                        MaxAcceleration: 0.5,  // m/s¬≤
                        MaxDeceleration: 2.0,  // m/s¬≤
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    300000, // 300km long-range naval radar
                        OpticalRange:  50000,  // 50km
                        InfraredRange: 100000, // 100km
                },
                Operational: OperationalCharacteristics{
                        Range:         8000000, // meters (4,320 nm)
                        CrewCapacity:  323,
                        WeaponSystems: []string{"Tomahawk", "Standard Missile", "5\" Gun"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "maritime",
                Name:          fmt.Sprintf("USS %s", shipName),
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeMaritime, typeDef, config, startPos, fmt.Sprintf("NAVY%s", id[len(id)-3:]), 1200000)

        return platform
}</span>

// Space Platform Factories

// NewStarlinkSatelliteUniversal creates a Starlink satellite using UniversalPlatform
func NewStarlinkSatelliteUniversal(id, satelliteNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 550000 // 550 km altitude
        mass := 260.0              // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Starlink Satellite",
                Category: "communications",
                Physical: PhysicalCharacteristics{
                        Length:         2.8,
                        Width:          1.9,
                        Height:         0.32,
                        Mass:           mass,
                        SolarPanelArea: 32.0, // m¬≤
                        FuelCapacity:   50,   // kg xenon propellant
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        7590,   // m/s orbital velocity
                        CruiseSpeed:     7590,   // same as max for satellites
                        MaxAltitude:     550000, // meters
                        OrbitalPeriod:   5760,   // seconds (96 minutes)
                        OrbitalVelocity: 7590,   // m/s
                        OrbitalAltitude: 550000, // meters
                        Inclination:     53.0,   // degrees
                        MaxAcceleration: 0.001,  // m/s¬≤ (ion thrusters)
                        MaxDeceleration: 0.001,  // m/s¬≤
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        false, // Satellites don't use GPS
                        HasRadar:      false,
                        HasCompass:    false, // Not useful in space
                        RadarRange:    0,
                        OpticalRange:  1000000, // 1000km space observation
                        InfraredRange: 500000,  // 500km
                },
                Operational: OperationalCharacteristics{
                        MissionLife:    5.0, // years
                        FrequencyBands: []string{"Ku-band", "Ka-band"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "space",
                Name:          fmt.Sprintf("Starlink-%s", satelliteNumber),
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeSpace, typeDef, config, startPos, fmt.Sprintf("STARLINK%s", id[len(id)-3:]), 50)

        return platform
}</span>

// Additional factory functions for comprehensive coverage

// NewCivilianCarUniversal creates a civilian passenger car
func NewCivilianCarUniversal(id, model string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 1500.0 // kg typical passenger car

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Civilian Car", // Changed from model to "Civilian Car"
                Category: "civilian",
                Physical: PhysicalCharacteristics{
                        Length:       4.5,
                        Width:        1.8,
                        Height:       1.4,
                        Mass:         mass,
                        FrontalArea:  2.5, // typical car
                        FuelCapacity: 60,  // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        50,  // m/s (112 mph)
                        CruiseSpeed:     25,  // m/s (56 mph)
                        MaxAcceleration: 3.0, // m/s¬≤
                        MaxDeceleration: 8.0, // m/s¬≤
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      false, // Basic civilian car
                        HasCompass:    true,
                        RadarRange:    0,
                        OpticalRange:  1000, // 1km visual
                        InfraredRange: 0,
                },
                Operational: OperationalCharacteristics{
                        Range:             600000, // meters (600 km)
                        PassengerCapacity: 5,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "land",
                Name:          fmt.Sprintf("Vehicle %s", id),
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeLand, typeDef, config, startPos, fmt.Sprintf("CAR%s", id[len(id)-3:]), 60)

        return platform
}</span>

// NewContainerShipUniversal creates a large container vessel
func NewContainerShipUniversal(id, shipName string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 0 // Sea level
        mass := 200000000.0   // kg (200,000 tonnes)

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Commercial Ship", // Changed from "Ultra Large Container Vessel" to "Commercial Ship"
                Category: "commercial",
                Physical: PhysicalCharacteristics{
                        Length:       400,
                        Width:        59, // beam
                        Height:       73, // above waterline
                        Mass:         mass,
                        WetArea:      24000,    // large underwater hull
                        Draft:        16,       // deep draft
                        FuelCapacity: 15000000, // liters (massive fuel capacity)
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        12.9,     // m/s (25 knots)
                        CruiseSpeed:     10.3,     // m/s (20 knots)
                        MaxAcceleration: 0.1,      // m/s¬≤ (very slow acceleration)
                        MaxDeceleration: 0.5,      // m/s¬≤
                        Range:           24000000, // meters (global range) - FIXED: Added missing Range field
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    50000, // 50km navigation radar
                        OpticalRange:  20000, // 20km
                        InfraredRange: 10000, // 10km
                },
                Operational: OperationalCharacteristics{
                        Range:         24000000, // meters (global range)
                        CrewCapacity:  25,
                        CargoCapacity: 24000, // containers
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "maritime",
                Name:          shipName,
                StartPosition: startPos,
        }

        platform := createBasePlatform(id, PlatformTypeMaritime, typeDef, config, startPos, fmt.Sprintf("CARGO%s", id[len(id)-3:]), 15000000)

        return platform
}</span>

// Utility functions for platform creation

// CreatePlatformFromConfig creates a UniversalPlatform from configuration data
func CreatePlatformFromConfig(config map[string]interface{}) (*UniversalPlatform, error) <span class="cov8" title="1">{
        // This would parse configuration and create appropriate platform
        // Implementation would depend on configuration format
        // For now, return a basic platform

        id, ok := config["id"].(string)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing or invalid platform ID")
        }</span>

        <span class="cov8" title="1">platformType, ok := config["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing or invalid platform type")
        }</span>

        <span class="cov8" title="1">var pos Position
        if posData, ok := config["position"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if lat, ok := posData["latitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Latitude = lat
                }</span>
                <span class="cov8" title="1">if lon, ok := posData["longitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Longitude = lon
                }</span>
                <span class="cov8" title="1">if alt, ok := posData["altitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Altitude = alt
                }</span>
        }

        // Create basic platform based on type
        <span class="cov8" title="1">switch platformType </span>{
        case "airborne":<span class="cov8" title="1">
                return NewBoeing737_800Universal(id, id, pos), nil</span>
        case "land":<span class="cov0" title="0">
                return NewCivilianCarUniversal(id, "Generic Car", pos), nil</span>
        case "maritime":<span class="cov0" title="0">
                return NewContainerShipUniversal(id, "Generic Ship", pos), nil</span>
        case "space":<span class="cov0" title="0">
                return NewStarlinkSatelliteUniversal(id, id, pos), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown platform type: %s", platformType)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "fmt"
        "time"
)

// Constants to reduce string duplication
const (
        DefaultHeading       = 0
        DefaultSpeed         = 0
        ArmorCallsignPrefix  = "ARMOR"
        HumveeCallsignPrefix = "HUMVEE"
        TruckCallsignPrefix  = "TRUCK"
        PatrolCallsignPrefix = "PATROL"
)

// LandPlatform represents ground vehicles and installations
type LandPlatform struct {
        // Embed UniversalPlatform for base functionality
        UniversalPlatform

        // Land-specific characteristics
        MaxGradient     float64 // degrees (max slope)
        GroundClearance float64 // meters
        TurningRadius   float64 // meters
        FuelConsumption float64 // liters per km
        CargoCapacity   float64 // kg
        CrewCapacity    int

        // Terrain capabilities
        OffRoadCapable bool
        WaterFording   float64 // max depth in meters
        ClimbAngle     float64 // degrees
}

// Core Platform interface implementation - delegate to embedded UniversalPlatform
func (l *LandPlatform) GetID() string           <span class="cov0" title="0">{ return l.UniversalPlatform.GetID() }</span>
func (l *LandPlatform) GetType() PlatformType   <span class="cov0" title="0">{ return l.UniversalPlatform.GetType() }</span>
func (l *LandPlatform) GetClass() string        <span class="cov0" title="0">{ return l.UniversalPlatform.GetClass() }</span>
func (l *LandPlatform) GetName() string         <span class="cov0" title="0">{ return l.UniversalPlatform.GetName() }</span>
func (l *LandPlatform) GetCallSign() string     <span class="cov0" title="0">{ return l.UniversalPlatform.GetCallSign() }</span>
func (l *LandPlatform) GetState() PlatformState <span class="cov0" title="0">{ return l.UniversalPlatform.GetState() }</span>
func (l *LandPlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return l.UniversalPlatform.GetMaxSpeed() }</span>
func (l *LandPlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return l.UniversalPlatform.GetMaxAltitude() }</span>
func (l *LandPlatform) GetLength() float64      <span class="cov0" title="0">{ return l.UniversalPlatform.GetLength() }</span>
func (l *LandPlatform) GetWidth() float64       <span class="cov0" title="0">{ return l.UniversalPlatform.GetWidth() }</span>
func (l *LandPlatform) GetHeight() float64      <span class="cov0" title="0">{ return l.UniversalPlatform.GetHeight() }</span>
func (l *LandPlatform) GetMass() float64        <span class="cov0" title="0">{ return l.UniversalPlatform.GetMass() }</span>

func (l *LandPlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        l.UniversalPlatform.UpdateState(state)
}</span>

func (l *LandPlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        return l.UniversalPlatform.SetDestination(pos)
}</span>

// Enhanced 3D physics methods
func (l *LandPlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        l.UniversalPlatform.Initialize3DPhysics()
}</span>

func (l *LandPlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov0" title="0">{
        return l.UniversalPlatform.Update3DPhysics(deltaTime)
}</span>

func (l *LandPlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return l.UniversalPlatform.GetPhysicsState()
}</span>

func (l *LandPlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        l.UniversalPlatform.SetPhysicsState(physics)
}</span>

// Update uses the base UniversalPlatform movement but can be enhanced with land-specific logic
func (l *LandPlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        // Use enhanced land movement from UniversalPlatform
        return l.UniversalPlatform.Update(deltaTime)
}</span>

// createLandPlatformBase creates a base UniversalPlatform for land vehicles
func createLandPlatformBase(id, name, platformType, callsign string, startPos Position, typeDef *PlatformTypeDefinition) UniversalPlatform <span class="cov0" title="0">{
        return UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeLand,
                TypeDef:      typeDef,
                Config: &amp;PlatformConfiguration{
                        ID:            id,
                        Type:          platformType,
                        Name:          name,
                        StartPosition: startPos,
                },
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position:        startPos,
                                Mass:            typeDef.Physical.Mass,
                                MomentOfInertia: calculateMomentOfInertia(typeDef.Physical.Mass, PlatformTypeLand),
                        },
                },
                CallSign:      callsign,
                FuelRemaining: typeDef.Physical.FuelCapacity,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 1.0, LastCheck: time.Now()},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0, LastCheck: time.Now()},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 1.0, LastCheck: time.Now()},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 1.0, LastCheck: time.Now()},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0, LastCheck: time.Now()},
                        WeaponStatus:        WeaponStatusSafe,
                },
                lastPosition: startPos,
                acceleration: 0,
        }
}</span>

// CreateM1A2Tank creates an M1A2 Abrams main battle tank
func CreateM1A2Tank(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", ArmorCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Main Battle Tank",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      18.6, // m/s (67 km/h)
                        CruiseSpeed:   11.1, // m/s (40 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 8.4,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 9.77,  // meters
                        Width:  3.66,  // meters
                        Height: 2.44,  // meters
                        Mass:   62000, // kg
                },
        }

        base := createLandPlatformBase(id, "M1A2 Abrams", "Main Battle Tank", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       60,    // degrees
                GroundClearance:   0.432, // meters
                TurningRadius:     8.4,   // meters
                FuelConsumption:   2.6,   // liters per km
                CargoCapacity:     1000,  // kg
                CrewCapacity:      4,
                OffRoadCapable:    true,
                WaterFording:      1.2, // meters
                ClimbAngle:        60,  // degrees
        }</span>
}

// CreateM2Bradley creates an M2 Bradley Infantry Fighting Vehicle
func CreateM2Bradley(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", ArmorCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Infantry Fighting Vehicle",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      18.3, // m/s (66 km/h)
                        CruiseSpeed:   11.1, // m/s (40 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 6.0,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 6.55,  // meters
                        Width:  3.6,   // meters
                        Height: 2.98,  // meters
                        Mass:   27600, // kg
                },
        }

        base := createLandPlatformBase(id, "M2 Bradley", "Infantry Fighting Vehicle", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       60,    // degrees
                GroundClearance:   0.432, // meters
                TurningRadius:     6.0,   // meters
                FuelConsumption:   1.5,   // liters per km
                CargoCapacity:     2000,  // kg
                CrewCapacity:      9,     // 3 crew + 6 infantry
                OffRoadCapable:    true,
                WaterFording:      1.0, // meters
                ClimbAngle:        60,  // degrees
        }</span>
}

// CreateHumvee creates a High Mobility Multipurpose Wheeled Vehicle
func CreateHumvee(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", HumveeCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Utility Vehicle",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      31.4, // m/s (113 km/h)
                        CruiseSpeed:   19.4, // m/s (70 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 7.6,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 4.57, // meters
                        Width:  2.16, // meters
                        Height: 1.75, // meters
                        Mass:   2359, // kg
                },
        }

        base := createLandPlatformBase(id, "HMMWV", "Utility Vehicle", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       60,    // degrees
                GroundClearance:   0.406, // meters
                TurningRadius:     7.6,   // meters
                FuelConsumption:   0.8,   // liters per km
                CargoCapacity:     1200,  // kg
                CrewCapacity:      4,
                OffRoadCapable:    true,
                WaterFording:      0.76, // meters
                ClimbAngle:        60,   // degrees
        }</span>
}

// CreateLAV25 creates a Light Armored Vehicle-25
func CreateLAV25(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", ArmorCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Light Armored Vehicle",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      27.8, // m/s (100 km/h)
                        CruiseSpeed:   16.7, // m/s (60 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 5.5,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 6.39,  // meters
                        Width:  2.5,   // meters
                        Height: 2.69,  // meters
                        Mass:   12900, // kg
                },
        }

        base := createLandPlatformBase(id, "LAV-25", "Light Armored Vehicle", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       60,   // degrees
                GroundClearance:   0.5,  // meters
                TurningRadius:     5.5,  // meters
                FuelConsumption:   1.2,  // liters per km
                CargoCapacity:     1500, // kg
                CrewCapacity:      6,    // 3 crew + 3 marines
                OffRoadCapable:    true,
                WaterFording:      1.5, // meters (amphibious)
                ClimbAngle:        60,  // degrees
        }</span>
}

// CreateM35Truck creates an M35 2.5-ton cargo truck
func CreateM35Truck(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", TruckCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Cargo Truck",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      25.0, // m/s (90 km/h)
                        CruiseSpeed:   16.7, // m/s (60 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 8.7,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 6.71, // meters
                        Width:  2.44, // meters
                        Height: 2.94, // meters
                        Mass:   6350, // kg empty
                },
        }

        base := createLandPlatformBase(id, "M35 Truck", "Cargo Truck", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       30,    // degrees
                GroundClearance:   0.279, // meters
                TurningRadius:     8.7,   // meters
                FuelConsumption:   0.6,   // liters per km
                CargoCapacity:     2268,  // kg (5000 lbs)
                CrewCapacity:      3,     // driver + 2 passengers
                OffRoadCapable:    true,
                WaterFording:      0.76, // meters
                ClimbAngle:        30,   // degrees
        }</span>
}

// CreateM1126Stryker creates an M1126 Stryker Infantry Carrier Vehicle
func CreateM1126Stryker(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", ArmorCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Infantry Carrier Vehicle",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      27.8, // m/s (100 km/h)
                        CruiseSpeed:   19.4, // m/s (70 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 7.0,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 6.95,  // meters
                        Width:  2.72,  // meters
                        Height: 2.64,  // meters
                        Mass:   16470, // kg
                },
        }

        base := createLandPlatformBase(id, "M1126 Stryker", "Infantry Carrier Vehicle", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       60,    // degrees
                GroundClearance:   0.533, // meters
                TurningRadius:     7.0,   // meters
                FuelConsumption:   1.1,   // liters per km
                CargoCapacity:     1800,  // kg
                CrewCapacity:      11,    // 2 crew + 9 infantry
                OffRoadCapable:    true,
                WaterFording:      1.0, // meters
                ClimbAngle:        60,  // degrees
        }</span>
}

// CreateMRAP creates a Mine-Resistant Ambush Protected vehicle
func CreateMRAP(id string, callsign string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        if callsign == "" </span><span class="cov0" title="0">{
                callsign = fmt.Sprintf("%s-%s", PatrolCallsignPrefix, id)
        }</span>

        <span class="cov0" title="0">typeDef := &amp;PlatformTypeDefinition{
                Class:    "Mine-Resistant Vehicle",
                Category: "military",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      29.2, // m/s (105 km/h)
                        CruiseSpeed:   19.4, // m/s (70 km/h)
                        MaxAltitude:   4267, // meters
                        TurningRadius: 8.0,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 6.7,   // meters
                        Width:  2.7,   // meters
                        Height: 2.7,   // meters
                        Mass:   14500, // kg
                },
        }

        base := createLandPlatformBase(id, "MRAP", "Mine-Resistant Vehicle", callsign, startPos, typeDef)

        return &amp;LandPlatform{
                UniversalPlatform: base,
                MaxGradient:       30,    // degrees
                GroundClearance:   0.406, // meters
                TurningRadius:     8.0,   // meters
                FuelConsumption:   1.0,   // liters per km
                CargoCapacity:     1000,  // kg
                CrewCapacity:      6,     // crew + passengers
                OffRoadCapable:    true,
                WaterFording:      0.6, // meters
                ClimbAngle:        30,  // degrees
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "fmt"
        "time"
)

// MaritimePlatform represents naval and commercial vessels
type MaritimePlatform struct {
        // Embed UniversalPlatform for base functionality
        UniversalPlatform

        // Maritime-specific characteristics
        Draft         float64 // meters (depth below waterline)
        Displacement  float64 // tonnes
        Beam          float64 // width at widest point
        CrewSize      int
        CargoCapacity float64 // tonnes

        // Naval capabilities
        SonarRange     float64 // meters
        RadarRange     float64 // meters
        WeaponSystems  []string
        ArmorThickness float64 // mm

        // Propulsion
        PropulsionType string // diesel, gas turbine, nuclear, etc.
        Screws         int    // number of propellers
        Rudders        int    // number of rudders
}

// Core Platform interface implementation - delegate to embedded UniversalPlatform
func (m *MaritimePlatform) GetID() string           <span class="cov0" title="0">{ return m.UniversalPlatform.GetID() }</span>
func (m *MaritimePlatform) GetType() PlatformType   <span class="cov0" title="0">{ return m.UniversalPlatform.GetType() }</span>
func (m *MaritimePlatform) GetClass() string        <span class="cov0" title="0">{ return m.UniversalPlatform.GetClass() }</span>
func (m *MaritimePlatform) GetName() string         <span class="cov0" title="0">{ return m.UniversalPlatform.GetName() }</span>
func (m *MaritimePlatform) GetCallSign() string     <span class="cov0" title="0">{ return m.UniversalPlatform.GetCallSign() }</span>
func (m *MaritimePlatform) GetState() PlatformState <span class="cov0" title="0">{ return m.UniversalPlatform.GetState() }</span>
func (m *MaritimePlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return m.UniversalPlatform.GetMaxSpeed() }</span>
func (m *MaritimePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return 0 }</span> // Ships don't fly
func (m *MaritimePlatform) GetLength() float64      <span class="cov0" title="0">{ return m.UniversalPlatform.GetLength() }</span>
func (m *MaritimePlatform) GetWidth() float64       <span class="cov0" title="0">{ return m.UniversalPlatform.GetWidth() }</span>
func (m *MaritimePlatform) GetHeight() float64      <span class="cov0" title="0">{ return m.UniversalPlatform.GetHeight() }</span>
func (m *MaritimePlatform) GetMass() float64        <span class="cov0" title="0">{ return m.UniversalPlatform.GetMass() }</span>

func (m *MaritimePlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        // Keep ships at sea level
        state.Position.Altitude = 0
        m.UniversalPlatform.UpdateState(state)
}</span>

func (m *MaritimePlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        // Force maritime platforms to sea level
        pos.Altitude = 0
        return m.UniversalPlatform.SetDestination(pos)
}</span>

// Enhanced 3D physics methods
func (m *MaritimePlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        m.UniversalPlatform.Initialize3DPhysics()
        // Ensure ship stays at sea level
        m.UniversalPlatform.State.Position.Altitude = 0
        m.UniversalPlatform.State.Physics.Position.Altitude = 0
}</span>

func (m *MaritimePlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov0" title="0">{
        err := m.UniversalPlatform.Update3DPhysics(deltaTime)
        // Ensure ship stays at sea level
        m.UniversalPlatform.State.Position.Altitude = 0
        m.UniversalPlatform.State.Physics.Position.Altitude = 0
        return err
}</span>

func (m *MaritimePlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return m.UniversalPlatform.GetPhysicsState()
}</span>

func (m *MaritimePlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        // Ensure ship stays at sea level
        physics.Position.Altitude = 0
        m.UniversalPlatform.SetPhysicsState(physics)
}</span>

// Update uses the base UniversalPlatform movement with maritime constraints
func (m *MaritimePlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        err := m.UniversalPlatform.Update(deltaTime)
        // Ensure ship stays at sea level
        m.UniversalPlatform.State.Position.Altitude = 0
        return err
}</span>

// Ship factory functions using UniversalPlatform base

// NewArleighBurkeDestroyer creates an Arleigh Burke-class destroyer (US Navy)
func NewArleighBurkeDestroyer(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0 // Ensure at sea level

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Arleigh Burke-class",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      15.4,    // m/s (30+ knots)
                        CruiseSpeed:   10.3,    // m/s (20 knots)
                        Acceleration:  0.5,     // m/s¬≤
                        TurningRadius: 800,     // meters
                        Range:         7400000, // meters (4000 nautical miles)
                },
                Physical: PhysicalCharacteristics{
                        Length: 155,     // meters
                        Width:  20,      // meters
                        Height: 18,      // meters
                        Mass:   9200000, // kg
                        Draft:  6.3,     // meters
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("USS %s", shipName),
                Type: "Arleigh Burke-class",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("NAVY%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;MaritimePlatform{
                UniversalPlatform: universalPlatform,
                Draft:             6.3,  // meters
                Displacement:      9200, // tonnes
                Beam:              20,   // meters
                CrewSize:          330,
                CargoCapacity:     0,      // combat vessel
                SonarRange:        50000,  // meters
                RadarRange:        180000, // meters
                WeaponSystems:     []string{"Aegis Combat System", "VLS Missiles", "5-inch Gun"},
                ArmorThickness:    25, // mm
                PropulsionType:    "Gas Turbine",
                Screws:            2,
                Rudders:           1,
        }
}</span>

// NewTiconderogaCruiser creates a Ticonderoga-class cruiser (US Navy)
func NewTiconderogaCruiser(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Ticonderoga-class",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      15.4,    // m/s (30+ knots)
                        CruiseSpeed:   10.3,    // m/s (20 knots)
                        Acceleration:  0.5,     // m/s¬≤
                        TurningRadius: 900,     // meters
                        Range:         9250000, // meters (5000 nautical miles)
                },
                Physical: PhysicalCharacteristics{
                        Length: 173,     // meters
                        Width:  16.8,    // meters
                        Height: 20,      // meters
                        Mass:   9800000, // kg
                        Draft:  10.2,    // meters
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("USS %s", shipName),
                Type: "Ticonderoga-class",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("NAVY%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;MaritimePlatform{
                UniversalPlatform: universalPlatform,
                Draft:             10.2, // meters
                Displacement:      9800, // tonnes
                Beam:              16.8, // meters
                CrewSize:          400,
                CargoCapacity:     0,      // combat vessel
                SonarRange:        50000,  // meters
                RadarRange:        200000, // meters
                WeaponSystems:     []string{"Aegis Combat System", "VLS Missiles", "5-inch Gun", "Tomahawk Missiles"},
                ArmorThickness:    30, // mm
                PropulsionType:    "Gas Turbine",
                Screws:            2,
                Rudders:           1,
        }
}</span>

// NewContainerShip creates a large container vessel (commercial)
func NewContainerShip(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Ultra Large Container Vessel",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      12.9,     // m/s (25 knots)
                        CruiseSpeed:   10.3,     // m/s (20 knots)
                        Acceleration:  0.1,      // m/s¬≤
                        TurningRadius: 2000,     // meters
                        Range:         18500000, // meters (10000 nautical miles)
                },
                Physical: PhysicalCharacteristics{
                        Length: 400,       // meters
                        Width:  59,        // meters
                        Height: 73,        // meters
                        Mass:   200000000, // kg
                        Draft:  16,        // meters
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: shipName,
                Type: "Ultra Large Container Vessel",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("CARGO%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;MaritimePlatform{
                UniversalPlatform: universalPlatform,
                Draft:             16,     // meters
                Displacement:      200000, // tonnes
                Beam:              59,     // meters
                CrewSize:          25,
                CargoCapacity:     200000,     // tonnes
                SonarRange:        5000,       // meters
                RadarRange:        50000,      // meters
                WeaponSystems:     []string{}, // unarmed commercial vessel
                ArmorThickness:    0,          // mm
                PropulsionType:    "Diesel",
                Screws:            1,
                Rudders:           1,
        }
}</span>

// NewOilTanker creates a large crude oil tanker (commercial)
func NewOilTanker(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Very Large Crude Carrier",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      8.2,      // m/s (16 knots)
                        CruiseSpeed:   6.7,      // m/s (13 knots)
                        Acceleration:  0.05,     // m/s¬≤
                        TurningRadius: 3000,     // meters
                        Range:         22200000, // meters (12000 nautical miles)
                },
                Physical: PhysicalCharacteristics{
                        Length: 330,       // meters
                        Width:  60,        // meters
                        Height: 35,        // meters
                        Mass:   320000000, // kg
                        Draft:  22,        // meters
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: shipName,
                Type: "Very Large Crude Carrier",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("TANKER%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;MaritimePlatform{
                UniversalPlatform: universalPlatform,
                Draft:             22,     // meters
                Displacement:      320000, // tonnes
                Beam:              60,     // meters
                CrewSize:          30,
                CargoCapacity:     320000,     // tonnes
                SonarRange:        2000,       // meters
                RadarRange:        25000,      // meters
                WeaponSystems:     []string{}, // unarmed commercial vessel
                ArmorThickness:    0,          // mm
                PropulsionType:    "Diesel",
                Screws:            1,
                Rudders:           1,
        }
}</span>

// NewCoastGuardCutter creates a Coast Guard cutter
func NewCoastGuardCutter(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Legend-class Cutter",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      14.4,    // m/s (28 knots)
                        CruiseSpeed:   10.3,    // m/s (20 knots)
                        Acceleration:  0.8,     // m/s¬≤
                        TurningRadius: 600,     // meters
                        Range:         5550000, // meters (3000 nautical miles)
                },
                Physical: PhysicalCharacteristics{
                        Length: 127,     // meters
                        Width:  16.4,    // meters
                        Height: 15,      // meters
                        Mass:   4500000, // kg
                        Draft:  6.7,     // meters
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("USCGC %s", shipName),
                Type: "Legend-class Cutter",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("COASTGUARD%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;MaritimePlatform{
                UniversalPlatform: universalPlatform,
                Draft:             6.7,  // meters
                Displacement:      4500, // tonnes
                Beam:              16.4, // meters
                CrewSize:          150,
                CargoCapacity:     500,    // tonnes
                SonarRange:        20000,  // meters
                RadarRange:        100000, // meters
                WeaponSystems:     []string{"57mm Gun", "Close-in Weapons System"},
                ArmorThickness:    15, // mm
                PropulsionType:    "Diesel",
                Screws:            2,
                Rudders:           1,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// String constants to fix linting issues
const (
        WeaponStatusArmed = "ARMED"
        WeaponStatusSafe  = "SAFE"
        WeaponStatusNA    = "N/A"

        PlatformTypeMilitary   = "military"
        PlatformTypeCommercial = "commercial"
        PlatformTypeCivilian   = "civilian"

        TestPlatformID = "TEST001"

        Boeing737Class  = "Boeing 737-800"
        AirbusA320Class = "Airbus A320"
        F16Class        = "F-16 Fighting Falcon"
        C130Class       = "C-130 Hercules"
)

// PlatformType represents the category of platform
type PlatformType string

const (
        PlatformTypeAirborne PlatformType = "airborne"
        PlatformTypeMaritime PlatformType = "maritime"
        PlatformTypeLand     PlatformType = "land"
        PlatformTypeSpace    PlatformType = "space"
)

// Acceleration represents 3D acceleration vector
type Acceleration struct {
        North float64 `json:"north"` // m/s¬≤
        East  float64 `json:"east"`  // m/s¬≤
        Up    float64 `json:"up"`    // m/s¬≤
}

// Attitude represents rotational orientation in 3D space
type Attitude struct {
        Roll  float64 `json:"roll"`  // degrees, rotation around longitudinal axis
        Pitch float64 `json:"pitch"` // degrees, rotation around lateral axis
        Yaw   float64 `json:"yaw"`   // degrees, rotation around vertical axis (same as heading)
}

// AngularVelocity represents rotational rates
type AngularVelocity struct {
        RollRate  float64 `json:"roll_rate"`  // degrees/second
        PitchRate float64 `json:"pitch_rate"` // degrees/second
        YawRate   float64 `json:"yaw_rate"`   // degrees/second
}

// AngularAcceleration represents rotational accelerations
type AngularAcceleration struct {
        RollAccel  float64 `json:"roll_accel"`  // degrees/second¬≤
        PitchAccel float64 `json:"pitch_accel"` // degrees/second¬≤
        YawAccel   float64 `json:"yaw_accel"`   // degrees/second¬≤
}

// PhysicsState represents comprehensive 3D physics state
type PhysicsState struct {
        Position            Position            `json:"position"`
        Velocity            Velocity            `json:"velocity"`
        Acceleration        Acceleration        `json:"acceleration"`
        Attitude            Attitude            `json:"attitude"`
        AngularVelocity     AngularVelocity     `json:"angular_velocity"`
        AngularAcceleration AngularAcceleration `json:"angular_acceleration"`
        Mass                float64             `json:"mass"`              // kg
        MomentOfInertia     MomentOfInertia     `json:"moment_of_inertia"` // kg‚ãÖm¬≤
        Forces              Forces              `json:"forces"`            // N
        Torques             Torques             `json:"torques"`           // N‚ãÖm
}

// MomentOfInertia represents rotational inertia in 3 axes
type MomentOfInertia struct {
        Ixx float64 `json:"ixx"` // kg‚ãÖm¬≤ around x-axis (roll)
        Iyy float64 `json:"iyy"` // kg‚ãÖm¬≤ around y-axis (pitch)
        Izz float64 `json:"izz"` // kg‚ãÖm¬≤ around z-axis (yaw)
}

// Forces represents applied forces in 3D
type Forces struct {
        Thrust float64 `json:"thrust"` // N, forward force
        Drag   float64 `json:"drag"`   // N, opposing motion
        Lift   float64 `json:"lift"`   // N, upward force (aircraft)
        Weight float64 `json:"weight"` // N, gravitational force
        Normal float64 `json:"normal"` // N, surface reaction force
}

// Torques represents applied torques in 3D
type Torques struct {
        Roll  float64 `json:"roll"`  // N‚ãÖm around longitudinal axis
        Pitch float64 `json:"pitch"` // N‚ãÖm around lateral axis
        Yaw   float64 `json:"yaw"`   // N‚ãÖm around vertical axis
}

// PlatformState represents the current state of a platform (backwards compatible)
type PlatformState struct {
        ID          string    `json:"id"`
        Position    Position  `json:"position"`
        Velocity    Velocity  `json:"velocity"`
        Heading     float64   `json:"heading"` // degrees, 0-360 (maintained for compatibility)
        Speed       float64   `json:"speed"`   // m/s (maintained for compatibility)
        Roll        float64   `json:"roll"`    // degrees, banking angle for aircraft
        LastUpdated time.Time `json:"lastUpdated"`

        // Enhanced physics state
        Physics PhysicsState `json:"physics"`
}

// PerformanceCharacteristics holds configurable performance data
type PerformanceCharacteristics struct {
        MaxSpeed        float64 `yaml:"max_speed"`
        CruiseSpeed     float64 `yaml:"cruise_speed"`
        MaxAltitude     float64 `yaml:"max_altitude,omitempty"`
        FuelConsumption float64 `yaml:"fuel_consumption"`
        TurningRadius   float64 `yaml:"turning_radius,omitempty"`
        Acceleration    float64 `yaml:"acceleration"`
        MaxGradient     float64 `yaml:"max_gradient,omitempty"`
        ClimbRate       float64 `yaml:"climb_rate,omitempty"`
        StallSpeed      float64 `yaml:"stall_speed,omitempty"`
        Range           float64 `yaml:"range"`

        // Enhanced performance characteristics
        MaxAcceleration   float64 `yaml:"max_acceleration,omitempty"`     // m/s¬≤
        MaxDeceleration   float64 `yaml:"max_deceleration,omitempty"`     // m/s¬≤
        MaxRollRate       float64 `yaml:"max_roll_rate,omitempty"`        // degrees/second
        MaxPitchRate      float64 `yaml:"max_pitch_rate,omitempty"`       // degrees/second
        MaxYawRate        float64 `yaml:"max_yaw_rate,omitempty"`         // degrees/second
        MaxBankAngle      float64 `yaml:"max_bank_angle,omitempty"`       // degrees
        MaxPitchAngle     float64 `yaml:"max_pitch_angle,omitempty"`      // degrees
        MaxThrustToWeight float64 `yaml:"max_thrust_to_weight,omitempty"` // ratio
        MaxLoadFactor     float64 `yaml:"max_load_factor,omitempty"`      // g-force

        // Control surface effectiveness
        ElevatorAuthority float64 `yaml:"elevator_authority,omitempty"` // degrees
        RudderAuthority   float64 `yaml:"rudder_authority,omitempty"`   // degrees
        AileronAuthority  float64 `yaml:"aileron_authority,omitempty"`  // degrees

        // Orbital characteristics for space platforms
        OrbitalVelocity float64 `yaml:"orbital_velocity,omitempty"`
        OrbitalPeriod   float64 `yaml:"orbital_period,omitempty"`
        OrbitalAltitude float64 `yaml:"orbital_altitude,omitempty"`
        Inclination     float64 `yaml:"inclination,omitempty"`
        Eccentricity    float64 `yaml:"eccentricity,omitempty"`
}

// PhysicalCharacteristics holds physical properties
type PhysicalCharacteristics struct {
        Length          float64 `yaml:"length"`
        Width           float64 `yaml:"width"`
        Height          float64 `yaml:"height"`
        Mass            float64 `yaml:"mass"`
        FuelCapacity    float64 `yaml:"fuel_capacity,omitempty"`
        Draft           float64 `yaml:"draft,omitempty"`            // Maritime
        GroundClearance float64 `yaml:"ground_clearance,omitempty"` // Land
        SolarPanelArea  float64 `yaml:"solar_panel_area,omitempty"` // Space

        // Enhanced physical characteristics for realistic physics
        CenterOfGravity CenterOfGravity `yaml:"center_of_gravity,omitempty"`
        EmptyWeight     float64         `yaml:"empty_weight,omitempty"` // kg
        MaxWeight       float64         `yaml:"max_weight,omitempty"`   // kg
        WingArea        float64         `yaml:"wing_area,omitempty"`    // m¬≤ (aircraft)
        WetArea         float64         `yaml:"wet_area,omitempty"`     // m¬≤ (ships)
        FrontalArea     float64         `yaml:"frontal_area,omitempty"` // m¬≤ (land vehicles)
}

// CenterOfGravity represents the center of mass location
type CenterOfGravity struct {
        X float64 `yaml:"x"` // meters from nose/bow/front
        Y float64 `yaml:"y"` // meters from centerline (positive = starboard/right)
        Z float64 `yaml:"z"` // meters from keel/ground (positive = up)
}

// CallsignConfiguration defines how callsigns are generated
type CallsignConfiguration struct {
        Prefix      string   `yaml:"prefix"`
        Format      string   `yaml:"format"`
        NumberRange [2]int   `yaml:"number_range,omitempty"`
        Names       []string `yaml:"names,omitempty"`
        Modules     []string `yaml:"modules,omitempty"`
}

// PlatformTypeDefinition defines the characteristics of a platform type
type PlatformTypeDefinition struct {
        Class        string                     `yaml:"class"`
        Category     string                     `yaml:"category"`
        Performance  PerformanceCharacteristics `yaml:"performance"`
        Physical     PhysicalCharacteristics    `yaml:"physical"`
        Operational  OperationalCharacteristics `yaml:"operational"`
        Sensors      SensorCharacteristics      `yaml:"sensors"`
        CallsignConf CallsignConfiguration      `yaml:"callsign_config"`
}

// SensorCharacteristics defines sensor capabilities
type SensorCharacteristics struct {
        HasGPS        bool    `yaml:"has_gps"`
        HasRadar      bool    `yaml:"has_radar"`
        HasCompass    bool    `yaml:"has_compass"`
        RadarRange    float64 `yaml:"radar_range,omitempty"`    // meters
        SonarRange    float64 `yaml:"sonar_range,omitempty"`    // meters
        OpticalRange  float64 `yaml:"optical_range,omitempty"`  // meters
        InfraredRange float64 `yaml:"infrared_range,omitempty"` // meters
}

// MissionConfiguration defines platform-specific mission parameters
type MissionConfiguration struct {
        Type       string                 `yaml:"type"`
        Parameters map[string]interface{} `yaml:",inline"`
}

// PlatformConfiguration represents a configured platform instance
type PlatformConfiguration struct {
        ID            string               `yaml:"id"`
        Type          string               `yaml:"type"`
        Name          string               `yaml:"name"`
        StartPosition Position             `yaml:"start_position"`
        Mission       MissionConfiguration `yaml:"mission"`
}

// UniversalPlatform implements the Platform interface using configuration data
type UniversalPlatform struct {
        ID           string                  `json:"id"`
        PlatformType PlatformType            `json:"platform_type"`
        TypeDef      *PlatformTypeDefinition `json:"type_def"`
        Config       *PlatformConfiguration  `json:"config"`
        State        PlatformState           `json:"state"`
        CallSign     string                  `json:"call_sign"`

        // Navigation
        Destination *Position  `json:"destination,omitempty"`
        Route       []Position `json:"route,omitempty"`

        // Runtime state
        FuelRemaining float64       `json:"fuel_remaining"`
        MissionTime   time.Duration `json:"mission_time"`
        SystemStatus  SystemStatus  `json:"system_status"`

        // Physics state
        lastPosition  Position `json:"-"`    // Internal field, don't serialize
        acceleration  float64  `json:"-"`    // Internal field, don't serialize
        Mass          float64  `json:"mass"` // Mass for physics calculations
        AngularForces struct { // Angular forces for attitude control
                X float64 `json:"x"`
                Y float64 `json:"y"`
                Z float64 `json:"z"`
        } `json:"angular_forces"`
}

// SystemStatus represents the operational status of various platform systems
type SystemStatus struct {
        PowerSystem         SystemState `json:"power_system"`
        PropulsionSystem    SystemState `json:"propulsion_system"`
        NavigationSystem    SystemState `json:"navigation_system"`
        CommunicationSystem SystemState `json:"communication_system"`
        SensorSystem        SystemState `json:"sensor_system"`
        WeaponSystem        SystemState `json:"weapon_system,omitempty"`
        LifeSupport         SystemState `json:"life_support,omitempty"`
        FuelSystem          SystemState `json:"fuel_system"`
        WeaponStatus        string      `json:"weapon_status"` // "ARMED", "SAFE", "N/A"
}

// SystemState represents the operational state of a system
type SystemState struct {
        Operational bool      `json:"operational"`
        Efficiency  float64   `json:"efficiency"` // 0.0 to 1.0
        LastCheck   time.Time `json:"last_check"`
        Notes       string    `json:"notes,omitempty"`
}

// Platform interface implementation
func (up *UniversalPlatform) GetID() string <span class="cov8" title="1">{
        return up.ID
}</span>

func (up *UniversalPlatform) GetType() PlatformType <span class="cov8" title="1">{
        return up.PlatformType
}</span>

func (up *UniversalPlatform) GetClass() string <span class="cov8" title="1">{
        return up.TypeDef.Class
}</span>

func (up *UniversalPlatform) GetName() string <span class="cov8" title="1">{
        return up.Config.Name
}</span>

func (up *UniversalPlatform) GetCallSign() string <span class="cov0" title="0">{
        return up.CallSign
}</span>

func (up *UniversalPlatform) GetState() PlatformState <span class="cov8" title="1">{
        return up.State
}</span>

func (up *UniversalPlatform) UpdateState(state PlatformState) <span class="cov8" title="1">{
        up.State = state
}</span>

func (up *UniversalPlatform) GetMaxSpeed() float64 <span class="cov8" title="1">{
        return up.TypeDef.Performance.MaxSpeed
}</span>

func (up *UniversalPlatform) GetMaxAltitude() float64 <span class="cov8" title="1">{
        if up.TypeDef.Performance.OrbitalAltitude &gt; 0 </span><span class="cov0" title="0">{
                return up.TypeDef.Performance.OrbitalAltitude
        }</span>
        <span class="cov8" title="1">return up.TypeDef.Performance.MaxAltitude</span>
}

func (up *UniversalPlatform) GetLength() float64 <span class="cov8" title="1">{
        return up.TypeDef.Physical.Length
}</span>

func (up *UniversalPlatform) GetWidth() float64 <span class="cov0" title="0">{
        return up.TypeDef.Physical.Width
}</span>

func (up *UniversalPlatform) GetHeight() float64 <span class="cov0" title="0">{
        return up.TypeDef.Physical.Height
}</span>

func (up *UniversalPlatform) GetMass() float64 <span class="cov8" title="1">{
        return up.TypeDef.Physical.Mass
}</span>

func (up *UniversalPlatform) SetDestination(pos Position) error <span class="cov8" title="1">{
        up.Destination = &amp;pos
        return nil
}</span>

// GetPerformanceCharacteristic allows access to any performance parameter
func (up *UniversalPlatform) GetPerformanceCharacteristic(name string) (float64, error) <span class="cov8" title="1">{
        switch name </span>{
        case "cruise_speed":<span class="cov8" title="1">
                return up.TypeDef.Performance.CruiseSpeed, nil</span>
        case "fuel_consumption":<span class="cov8" title="1">
                return up.TypeDef.Performance.FuelConsumption, nil</span>
        case "turning_radius":<span class="cov8" title="1">
                return up.TypeDef.Performance.TurningRadius, nil</span>
        case "acceleration":<span class="cov8" title="1">
                return up.TypeDef.Performance.Acceleration, nil</span>
        case "climb_rate":<span class="cov8" title="1">
                return up.TypeDef.Performance.ClimbRate, nil</span>
        case "orbital_period":<span class="cov8" title="1">
                return up.TypeDef.Performance.OrbitalPeriod, nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("unknown performance characteristic: %s", name)</span>
        }
}

// Update updates the platform's state for the given time step
func (up *UniversalPlatform) Update(deltaTime time.Duration) error <span class="cov8" title="1">{
        deltaSeconds := deltaTime.Seconds()

        // Update mission time
        up.MissionTime += deltaTime

        // Consume fuel if engines are running
        if up.State.Speed &gt; 0 || up.Destination != nil </span><span class="cov8" title="1">{
                fuelRate := up.TypeDef.Performance.FuelConsumption
                if fuelRate &gt; 0 </span><span class="cov8" title="1">{
                        fuelConsumed := fuelRate * deltaSeconds
                        up.FuelRemaining = math.Max(0, up.FuelRemaining-fuelConsumed)
                }</span>
        }

        // If no destination but has velocity, update position from current velocity
        <span class="cov8" title="1">if up.Destination == nil </span><span class="cov8" title="1">{
                if up.State.Velocity.North != 0 || up.State.Velocity.East != 0 || up.State.Velocity.Up != 0 </span><span class="cov8" title="1">{
                        up.updatePositionFromVelocity(deltaSeconds)
                        up.State.LastUpdated = time.Now()
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Update based on platform type
        <span class="cov8" title="1">switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov8" title="1">
                return up.updateAirborneMovement(deltaSeconds)</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                return up.updateMaritimeMovement(deltaSeconds)</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                return up.updateLandMovement(deltaSeconds)</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                return up.updateSpaceMovement(deltaSeconds)</span>
        default:<span class="cov0" title="0">
                return up.updateGenericMovement(deltaSeconds)</span>
        }
}

func (up *UniversalPlatform) updateAirborneMovement(deltaSeconds float64) error <span class="cov8" title="1">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                // Even without destination, update position if there's velocity
                if up.State.Velocity.North != 0 || up.State.Velocity.East != 0 || up.State.Velocity.Up != 0 </span><span class="cov0" title="0">{
                        up.updatePositionFromVelocity(deltaSeconds)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Enhanced aircraft movement with realistic climb rates and banking
        <span class="cov8" title="1">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 100 </span><span class="cov0" title="0">{ // 100 meter threshold
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Calculate desired heading
        <span class="cov8" title="1">desiredHeading := up.calculateBearing(*up.Destination)

        // Apply turning constraints
        if up.TypeDef.Performance.TurningRadius &gt; 0 </span><span class="cov0" title="0">{
                up.applyTurningConstraints(desiredHeading, deltaSeconds)
        }</span> else<span class="cov8" title="1"> {
                up.State.Heading = desiredHeading
        }</span>

        // Calculate altitude change with climb rate constraints
        <span class="cov8" title="1">altitudeDiff := up.Destination.Altitude - up.State.Position.Altitude
        if math.Abs(altitudeDiff) &gt; 10 </span><span class="cov0" title="0">{
                climbRate := up.TypeDef.Performance.ClimbRate
                if climbRate == 0 </span><span class="cov0" title="0">{
                        climbRate = 10.0 // Default 10 m/s
                }</span>

                <span class="cov0" title="0">maxAltChange := climbRate * deltaSeconds
                if math.Abs(altitudeDiff) &lt;= maxAltChange </span><span class="cov0" title="0">{
                        up.State.Position.Altitude = up.Destination.Altitude
                        up.State.Velocity.Up = 0
                }</span> else<span class="cov0" title="0"> if altitudeDiff &gt; 0 </span><span class="cov0" title="0">{
                        up.State.Position.Altitude += maxAltChange
                        up.State.Velocity.Up = climbRate
                }</span> else<span class="cov0" title="0"> {
                        up.State.Position.Altitude -= maxAltChange
                        up.State.Velocity.Up = -climbRate
                }</span>
        }

        // Apply acceleration constraints
        <span class="cov8" title="1">targetSpeed := up.TypeDef.Performance.CruiseSpeed
        if up.TypeDef.Performance.Acceleration &gt; 0 </span><span class="cov8" title="1">{
                up.applyAccelerationConstraints(targetSpeed, deltaSeconds)
        }</span> else<span class="cov0" title="0"> {
                up.State.Speed = targetSpeed
        }</span>

        // Update position based on current heading and speed
        <span class="cov8" title="1">up.updatePositionFromHeadingAndSpeed(deltaSeconds)

        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateMaritimeMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Maritime movement with ship dynamics
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 10 </span><span class="cov0" title="0">{ // 10 meter threshold for ships
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Ships have turning constraints based on their size and speed
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)

        // Use turning radius for maritime movement calculations
        if up.TypeDef.Performance.TurningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius := up.TypeDef.Physical.Length * 5 // Default: 5x ship length
                up.TypeDef.Performance.TurningRadius = turningRadius
        }</span>

        <span class="cov0" title="0">up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Calculate movement with maritime characteristics
        targetSpeed := up.TypeDef.Performance.MaxSpeed * 0.9 // Ships can maintain near max speed in open water

        // Apply acceleration with maritime characteristics
        acceleration := up.TypeDef.Performance.Acceleration
        if acceleration == 0 </span><span class="cov0" title="0">{
                acceleration = 0.5 // Default slow acceleration for ships
        }</span>
        <span class="cov0" title="0">up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        up.updatePositionFromHeadingAndSpeed(deltaSeconds)
        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateLandMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Land movement with terrain and gradient constraints
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 10 </span><span class="cov0" title="0">{ // 10 meter threshold for land vehicles
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Apply gradient constraints for altitude changes
        altitudeDiff := up.Destination.Altitude - up.State.Position.Altitude
        horizontalDist := up.calculateHorizontalDistance(*up.Destination)

        if horizontalDist &gt; 0 </span><span class="cov0" title="0">{
                gradient := math.Atan(altitudeDiff/horizontalDist) * 180.0 / math.Pi
                maxGradient := up.TypeDef.Performance.MaxGradient
                if maxGradient == 0 </span><span class="cov0" title="0">{
                        maxGradient = 30.0 // Default 30 degree max gradient
                }</span>

                <span class="cov0" title="0">if math.Abs(gradient) &gt; maxGradient </span><span class="cov0" title="0">{
                        // Reduce speed when climbing steep grades
                        up.State.Speed *= (maxGradient / math.Abs(gradient))
                }</span>
        }

        <span class="cov0" title="0">targetSpeed := up.TypeDef.Performance.CruiseSpeed
        up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        up.updatePositionFromHeadingAndSpeed(deltaSeconds)
        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateSpaceMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Space movement with orbital mechanics
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 100 </span><span class="cov0" title="0">{ // 100 meter threshold for satellites
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Satellites move in predictable orbital paths
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)

        // Space vehicles have different movement characteristics
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Calculate movement with orbital velocity
        targetSpeed := up.TypeDef.Performance.MaxSpeed * 0.8 // Most satellites maintain consistent orbital speed

        // Maintain orbital altitude
        up.State.Position.Altitude = up.TypeDef.Performance.OrbitalAltitude
        up.State.Speed = targetSpeed
        up.State.Heading = 90 // Generally eastward

        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateGenericMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Generic movement for unknown platform types
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 50 </span><span class="cov0" title="0">{ // 50 meter threshold
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Calculate desired heading
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Apply generic acceleration
        targetSpeed := up.TypeDef.Performance.CruiseSpeed
        up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        // Update position based on current heading and speed
        up.updatePositionFromHeadingAndSpeed(deltaSeconds)

        up.State.LastUpdated = time.Now()
        return nil</span>
}

// Physics helper functions

func (up *UniversalPlatform) calculateGreatCircleDistance(target Position) float64 <span class="cov8" title="1">{
        // Haversine formula for great circle distance
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLat := (target.Latitude - up.State.Position.Latitude) * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := 6371000.0 // meters
        distance := earthRadius * c

        // Add altitude difference
        altDiff := target.Altitude - up.State.Position.Altitude
        return math.Sqrt(distance*distance + altDiff*altDiff)
}</span>

func (up *UniversalPlatform) calculateHorizontalDistance(target Position) float64 <span class="cov8" title="1">{
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLat := (target.Latitude - up.State.Position.Latitude) * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := 6371000.0 // meters
        return earthRadius * c
}</span>

func (up *UniversalPlatform) calculateBearing(target Position) float64 <span class="cov8" title="1">{
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        return math.Mod(bearing+360, 360) // Normalize to 0-360
}</span>

func (up *UniversalPlatform) applyTurningConstraints(desiredHeading, deltaSeconds float64) <span class="cov8" title="1">{
        currentHeading := up.State.Heading
        headingDiff := desiredHeading - currentHeading

        // Normalize heading difference to -180 to 180
        for headingDiff &gt; 180 </span><span class="cov0" title="0">{
                headingDiff -= 360
        }</span>
        <span class="cov8" title="1">for headingDiff &lt; -180 </span><span class="cov0" title="0">{
                headingDiff += 360
        }</span>

        // Calculate maximum turn rate based on turning radius and speed
        <span class="cov8" title="1">if up.TypeDef.Performance.TurningRadius &gt; 0 &amp;&amp; up.State.Speed &gt; 0 </span><span class="cov8" title="1">{
                maxTurnRate := (up.State.Speed / up.TypeDef.Performance.TurningRadius) * 180.0 / math.Pi // deg/s
                maxTurnChange := maxTurnRate * deltaSeconds

                if math.Abs(headingDiff) &lt;= maxTurnChange </span><span class="cov0" title="0">{
                        up.State.Heading = desiredHeading
                }</span> else<span class="cov8" title="1"> if headingDiff &gt; 0 </span><span class="cov8" title="1">{
                        up.State.Heading = math.Mod(currentHeading+maxTurnChange, 360)
                }</span> else<span class="cov0" title="0"> {
                        up.State.Heading = math.Mod(currentHeading-maxTurnChange+360, 360)
                }</span>
        } else<span class="cov0" title="0"> {
                up.State.Heading = desiredHeading
        }</span>
}

func (up *UniversalPlatform) applyAccelerationConstraints(targetSpeed, deltaSeconds float64) <span class="cov8" title="1">{
        speedDiff := targetSpeed - up.State.Speed

        if up.TypeDef.Performance.Acceleration &gt; 0 </span><span class="cov8" title="1">{
                maxSpeedChange := up.TypeDef.Performance.Acceleration * deltaSeconds

                if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov0" title="0">{
                        up.State.Speed = targetSpeed
                }</span> else<span class="cov8" title="1"> if speedDiff &gt; 0 </span><span class="cov8" title="1">{
                        up.State.Speed += maxSpeedChange
                }</span> else<span class="cov8" title="1"> {
                        up.State.Speed -= maxSpeedChange
                }</span>
        } else<span class="cov0" title="0"> {
                up.State.Speed = targetSpeed
        }</span>

        // Ensure speed doesn't exceed maximum
        <span class="cov8" title="1">if up.State.Speed &gt; up.TypeDef.Performance.MaxSpeed </span><span class="cov8" title="1">{
                up.State.Speed = up.TypeDef.Performance.MaxSpeed
        }</span>

        // Ensure speed isn't negative
        <span class="cov8" title="1">if up.State.Speed &lt; 0 </span><span class="cov0" title="0">{
                up.State.Speed = 0
        }</span>
}

func (up *UniversalPlatform) updatePositionFromHeadingAndSpeed(deltaSeconds float64) <span class="cov8" title="1">{
        // Convert heading to radians (0 degrees = North, 90 degrees = East)
        // Navigation heading: 0¬∞ = North, 90¬∞ = East, 180¬∞ = South, 270¬∞ = West
        headingRad := up.State.Heading * math.Pi / 180.0

        // Calculate distance moved
        distance := up.State.Speed * deltaSeconds

        // Earth radius in meters
        earthRadius := 6371000.0

        // Calculate new position using proper navigation calculations
        // North component: distance * cos(heading)
        // East component: distance * sin(heading)
        deltaLat := distance * math.Cos(headingRad) / earthRadius * 180.0 / math.Pi
        deltaLon := distance * math.Sin(headingRad) / earthRadius * 180.0 / math.Pi / math.Cos(up.State.Position.Latitude*math.Pi/180.0)

        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon

        // Calculate velocity components for state tracking
        up.State.Velocity.North = up.State.Speed * math.Cos(headingRad)
        up.State.Velocity.East = up.State.Speed * math.Sin(headingRad)
        up.State.Velocity.Up = 0 // Will be calculated separately for altitude changes
}</span>

// updatePositionFromVelocity updates position based on current velocity components
func (up *UniversalPlatform) updatePositionFromVelocity(deltaSeconds float64) <span class="cov8" title="1">{
        // Earth radius in meters
        earthRadius := 6371000.0

        // Convert North/East velocity to lat/lon changes
        deltaLat := up.State.Velocity.North * deltaSeconds / earthRadius * 180.0 / math.Pi
        deltaLon := up.State.Velocity.East * deltaSeconds / (earthRadius * math.Cos(up.State.Position.Latitude*math.Pi/180.0)) * 180.0 / math.Pi
        deltaAlt := up.State.Velocity.Up * deltaSeconds

        // Update position
        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon
        up.State.Position.Altitude += deltaAlt

        // Sync physics state
        up.State.Physics.Position = up.State.Position

        // Update heading and speed from velocity
        if up.State.Velocity.East != 0 || up.State.Velocity.North != 0 </span><span class="cov8" title="1">{
                up.State.Heading = math.Atan2(up.State.Velocity.East, up.State.Velocity.North) * 180.0 / math.Pi
                if up.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                        up.State.Heading += 360
                }</span>
        }

        <span class="cov8" title="1">up.State.Speed = math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East)</span>
}

// OperationalCharacteristics holds mission and operational data
type OperationalCharacteristics struct {
        Range             float64  `yaml:"range"`
        CrewCapacity      int      `yaml:"crew_capacity,omitempty"`
        PassengerCapacity int      `yaml:"passenger_capacity,omitempty"`
        CargoCapacity     float64  `yaml:"cargo_capacity,omitempty"`
        MissionLife       float64  `yaml:"mission_life,omitempty"`    // Space platforms
        SensorRange       float64  `yaml:"sensor_range,omitempty"`    // Naval platforms
        WeaponSystems     []string `yaml:"weapon_systems,omitempty"`  // Military platforms
        FrequencyBands    []string `yaml:"frequency_bands,omitempty"` // Satellites
}

// Platform interface defines the contract for all platform types
type Platform interface {
        // Core identification
        GetID() string
        GetType() PlatformType
        GetClass() string // e.g., "Boeing 737-800", "Arleigh Burke-class"
        GetName() string  // e.g., "United 1234", "USS Cole"

        // State management
        GetState() PlatformState
        UpdateState(state PlatformState)

        // Behavior
        Update(deltaTime time.Duration) error
        SetDestination(pos Position) error

        // Properties
        GetMaxSpeed() float64    // m/s
        GetMaxAltitude() float64 // meters (for applicable platforms)
        GetCallSign() string

        // Real-world characteristics
        GetLength() float64 // meters
        GetWidth() float64  // meters
        GetHeight() float64 // meters
        GetMass() float64   // kg

        // Enhanced 3D physics methods
        Initialize3DPhysics()
        Update3DPhysics(deltaTime time.Duration) error
        GetPhysicsState() PhysicsState
        SetPhysicsState(physics PhysicsState)
}

// Enhanced 3D physics methods for UniversalPlatform

// Initialize3DPhysics sets up realistic physics parameters based on platform type
func (up *UniversalPlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        // Initialize physics state with platform characteristics
        up.State.Physics = PhysicsState{
                Position:            up.State.Position,
                Velocity:            up.State.Velocity,
                Acceleration:        Acceleration{},
                Attitude:            Attitude{Yaw: up.State.Heading},
                AngularVelocity:     AngularVelocity{},
                AngularAcceleration: AngularAcceleration{},
                Mass:                up.TypeDef.Physical.Mass,
                MomentOfInertia:     up.calculateMomentOfInertia(),
                Forces:              Forces{Weight: up.TypeDef.Physical.Mass * 9.81},
                Torques:             Torques{},
        }
}</span>

// calculateMomentOfInertia estimates moment of inertia based on platform geometry
func (up *UniversalPlatform) calculateMomentOfInertia() MomentOfInertia <span class="cov0" title="0">{
        mass := up.TypeDef.Physical.Mass
        length := up.TypeDef.Physical.Length
        width := up.TypeDef.Physical.Width
        height := up.TypeDef.Physical.Height

        // Simplified calculations for different platform types
        switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov0" title="0">
                // Aircraft approximated as elongated ellipsoid
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 20,   // Roll axis
                        Iyy: mass * (length*length + height*height) / 20, // Pitch axis
                        Izz: mass * (length*length + width*width) / 20,   // Yaw axis
                }</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                // Ship approximated as rectangular prism
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                // Vehicle approximated as box
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                // Satellite approximated as uniform distribution
                avgDim := (length + width + height) / 3
                return MomentOfInertia{
                        Ixx: mass * avgDim * avgDim / 6,
                        Iyy: mass * avgDim * avgDim / 6,
                        Izz: mass * avgDim * avgDim / 6,
                }</span>
        default:<span class="cov0" title="0">
                // Default calculation
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        }
}

// Update3DPhysics applies 3D physics simulation to the platform
func (up *UniversalPlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov8" title="1">{
        deltaSeconds := deltaTime.Seconds()

        // Apply platform-specific forces
        switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov8" title="1">
                up.applyAerodynamicForces()
                up.applyThrustForces()
                up.applyGravity()</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                up.applyGroundForces()
                up.applyEngineForces()
                up.applyGravity()</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                up.applyHydrodynamicForces()
                up.applyPropulsionForces()
                up.applyBuoyancyAndGravity()</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                up.applyOrbitalForces()
                up.applyThrusterForces()</span>
        default:<span class="cov0" title="0">
                up.applyBasicForces()</span>
        }

        // Integrate forces to acceleration and velocity
        <span class="cov8" title="1">up.integrateForces(deltaSeconds)

        // Integrate velocity to position
        up.integrateVelocity(deltaSeconds)

        // Update attitude from angular forces
        up.updateAttitudeFromForces(deltaSeconds)

        // Update timestamp
        up.State.LastUpdated = time.Now()

        return nil</span>
}

// Force represents a 3D force vector
type Force struct {
        X float64 `json:"x"` // Forward/backward force (N)
        Y float64 `json:"y"` // Left/right force (N)
        Z float64 `json:"z"` // Up/down force (N)
}

// Force application methods
func (up *UniversalPlatform) applyAerodynamicForces() <span class="cov8" title="1">{
        // Basic aerodynamic forces - can be expanded later
        // For now, apply basic drag opposing motion
        speed := math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East + up.State.Velocity.Up*up.State.Velocity.Up)
        if speed &gt; 0 </span><span class="cov0" title="0">{
                dragCoeff := 0.1
                up.State.Physics.Forces.Drag -= dragCoeff * speed * speed // Apply drag force
        }</span>
}

func (up *UniversalPlatform) applyThrustForces() <span class="cov8" title="1">{
        // Convert speed and heading to thrust forces
        if up.State.Speed &gt; 0 </span><span class="cov0" title="0">{
                headingRad := up.State.Heading * math.Pi / 180.0
                thrustMagnitude := up.State.Speed * 0.1 // Simple thrust model
                up.State.Physics.Forces.Thrust += thrustMagnitude * math.Sin(headingRad)
                up.State.Physics.Forces.Normal += thrustMagnitude * math.Cos(headingRad)
        }</span>
}

func (up *UniversalPlatform) applyGravity() <span class="cov8" title="1">{
        up.State.Physics.Forces.Weight = 9.81 * up.State.Physics.Mass // Standard gravity
}</span>

func (up *UniversalPlatform) applyHydrodynamicForces() <span class="cov0" title="0">{
        // Similar to aerodynamic but for water
        up.applyAerodynamicForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyPropulsionForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyBuoyancyAndGravity() <span class="cov0" title="0">{
        up.applyGravity()
        // Add buoyancy force to counteract gravity for surface vessels
        up.State.Physics.Forces.Lift += 9.81 * up.State.Physics.Mass // Simplified buoyancy
}</span>

func (up *UniversalPlatform) applyGroundForces() <span class="cov0" title="0">{
        // Ground friction and resistance
        up.applyAerodynamicForces() // Simplified friction model
}</span>

func (up *UniversalPlatform) applyEngineForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyOrbitalForces() <span class="cov0" title="0">{
        // Basic orbital mechanics - simplified
        up.applyGravity()
}</span>

func (up *UniversalPlatform) applyThrusterForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyBasicForces() <span class="cov0" title="0">{
        up.applyThrustForces()
        up.applyGravity()
}</span>

// Force and velocity integration methods
func (up *UniversalPlatform) integrateForces(deltaTime float64) <span class="cov8" title="1">{
        if up.State.Physics.Mass &gt; 0 </span><span class="cov8" title="1">{
                // F = ma, so a = F/m
                up.State.Physics.Acceleration.North = up.State.Physics.Forces.Thrust / up.State.Physics.Mass
                up.State.Physics.Acceleration.East = up.State.Physics.Forces.Normal / up.State.Physics.Mass
                up.State.Physics.Acceleration.Up = up.State.Physics.Forces.Lift / up.State.Physics.Mass

                // Integrate acceleration to velocity
                up.State.Physics.Velocity.North += up.State.Physics.Acceleration.North * deltaTime
                up.State.Physics.Velocity.East += up.State.Physics.Acceleration.East * deltaTime
                up.State.Physics.Velocity.Up += up.State.Physics.Acceleration.Up * deltaTime

                // Reset forces for next iteration
                up.State.Physics.Forces.Thrust = 0
                up.State.Physics.Forces.Normal = 0
                up.State.Physics.Forces.Lift = 0
        }</span>
}

func (up *UniversalPlatform) integrateVelocity(deltaTime float64) <span class="cov8" title="1">{
        // Convert velocity to lat/lon/alt changes
        earthRadius := 6371000.0 // Earth radius in meters

        // Convert North/East velocity to lat/lon changes
        deltaLat := up.State.Velocity.North * deltaTime / earthRadius * 180.0 / math.Pi
        deltaLon := up.State.Velocity.East * deltaTime / (earthRadius * math.Cos(up.State.Position.Latitude*math.Pi/180.0)) * 180.0 / math.Pi
        deltaAlt := up.State.Velocity.Up * deltaTime

        // Update position
        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon
        up.State.Position.Altitude += deltaAlt

        // Update speed from velocity magnitude
        up.State.Speed = math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East + up.State.Velocity.Up*up.State.Velocity.Up)

        // Update heading from velocity direction
        if up.State.Velocity.East != 0 || up.State.Velocity.North != 0 </span><span class="cov0" title="0">{
                up.State.Heading = math.Atan2(up.State.Velocity.East, up.State.Velocity.North) * 180.0 / math.Pi
                if up.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                        up.State.Heading += 360
                }</span>
        }
}

func (up *UniversalPlatform) updateAttitudeFromForces(deltaTime float64) <span class="cov8" title="1">{
        // Apply angular velocity to attitude changes
        up.State.Physics.Attitude.Roll += up.State.Physics.AngularVelocity.RollRate * deltaTime
        up.State.Physics.Attitude.Pitch += up.State.Physics.AngularVelocity.PitchRate * deltaTime
        up.State.Physics.Attitude.Yaw += up.State.Physics.AngularVelocity.YawRate * deltaTime

        // Update legacy roll field for compatibility
        up.State.Roll = up.State.Physics.Attitude.Roll

        // Basic attitude control from angular forces
        if up.AngularForces.X != 0 || up.AngularForces.Y != 0 || up.AngularForces.Z != 0 </span><span class="cov0" title="0">{
                // Integrate angular forces to angular velocity
                if up.State.Physics.Mass &gt; 0 </span><span class="cov0" title="0">{
                        up.State.Physics.AngularVelocity.RollRate += up.AngularForces.X * deltaTime / up.State.Physics.Mass
                        up.State.Physics.AngularVelocity.PitchRate += up.AngularForces.Y * deltaTime / up.State.Physics.Mass
                        up.State.Physics.AngularVelocity.YawRate += up.AngularForces.Z * deltaTime / up.State.Physics.Mass
                }</span>

                // Reset angular forces
                <span class="cov0" title="0">up.AngularForces.X = 0
                up.AngularForces.Y = 0
                up.AngularForces.Z = 0</span>
        }
}

// GetPhysicsState returns the current physics state
func (up *UniversalPlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return up.State.Physics
}</span>

// SetPhysicsState sets the physics state
func (up *UniversalPlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        up.State.Physics = physics
        // Sync legacy state
        up.State.Position = physics.Position
        up.State.Velocity = physics.Velocity
        up.State.Heading = physics.Attitude.Yaw
        up.State.Speed = math.Sqrt(physics.Velocity.North*physics.Velocity.North + physics.Velocity.East*physics.Velocity.East)
}</span>

// CalculateDistanceTo calculates distance to another position
func (up *UniversalPlatform) CalculateDistanceTo(target Position) float64 <span class="cov8" title="1">{
        return up.calculateGreatCircleDistance(target)
}</span>

// GetStatus returns a status summary of the platform
func (up *UniversalPlatform) GetStatus() PlatformStatus <span class="cov8" title="1">{
        return PlatformStatus{
                ID:           up.ID,
                PlatformType: up.PlatformType,
                Position:     up.State.Position,
                Velocity:     up.State.Velocity,
                Heading:      up.State.Heading,
                Speed:        up.State.Speed,
                LastUpdated:  up.State.LastUpdated,
        }
}</span>

// ApplyForce applies a 3D force to the platform
func (up *UniversalPlatform) ApplyForce(force Force) <span class="cov8" title="1">{
        // Add the applied force to existing forces
        up.State.Physics.Forces.Thrust += force.X
        up.State.Physics.Forces.Normal += force.Y
        up.State.Physics.Forces.Lift += force.Z
}</span>

// calculateTurningRate calculates the turning rate for the platform in radians per second
func (p *UniversalPlatform) calculateTurningRate(_ time.Duration) float64 <span class="cov0" title="0">{
        // Get turning radius from performance characteristics
        turningRadius := p.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius = 500.0 // Default turning radius in meters
        }</span>

        // Calculate turning rate based on current speed and turning radius
        // Angular velocity = linear velocity / radius
        <span class="cov0" title="0">if p.State.Speed &gt; 0 &amp;&amp; turningRadius &gt; 0 </span><span class="cov0" title="0">{
                return p.State.Speed / turningRadius // radians per second
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// PlatformStatus represents a summary of platform state
type PlatformStatus struct {
        ID           string       `json:"id"`
        PlatformType PlatformType `json:"platform_type"`
        Position     Position     `json:"position"`
        Velocity     Velocity     `json:"velocity"`
        Heading      float64      `json:"heading"`
        Speed        float64      `json:"speed"`
        LastUpdated  time.Time    `json:"last_updated"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// SpacePlatform represents satellites and spacecraft
type SpacePlatform struct {
        // Embed UniversalPlatform for base functionality
        UniversalPlatform

        // Space-specific characteristics
        OrbitalPeriod float64 // seconds (time for one orbit)
        Apogee        float64 // meters (highest point)
        Perigee       float64 // meters (lowest point)
        Inclination   float64 // degrees (orbital plane angle)
        Eccentricity  float64 // orbital eccentricity (0 = circular)

        // Mission characteristics
        MissionType     string // communication, navigation, observation, etc.
        LaunchDate      time.Time
        MissionDuration time.Duration // expected mission lifetime

        // Space environment
        SolarPanelArea  float64 // square meters
        PowerGeneration float64 // watts
        FuelRemaining   float64 // kg
        RadiationShield bool
}

// Core Platform interface implementation - delegate to embedded UniversalPlatform
func (s *SpacePlatform) GetID() string           <span class="cov0" title="0">{ return s.UniversalPlatform.GetID() }</span>
func (s *SpacePlatform) GetType() PlatformType   <span class="cov0" title="0">{ return s.UniversalPlatform.GetType() }</span>
func (s *SpacePlatform) GetClass() string        <span class="cov0" title="0">{ return s.UniversalPlatform.GetClass() }</span>
func (s *SpacePlatform) GetName() string         <span class="cov0" title="0">{ return s.UniversalPlatform.GetName() }</span>
func (s *SpacePlatform) GetCallSign() string     <span class="cov0" title="0">{ return s.UniversalPlatform.GetCallSign() }</span>
func (s *SpacePlatform) GetState() PlatformState <span class="cov0" title="0">{ return s.UniversalPlatform.GetState() }</span>
func (s *SpacePlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return s.UniversalPlatform.GetMaxSpeed() }</span>
func (s *SpacePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return s.Apogee }</span>
func (s *SpacePlatform) GetLength() float64      <span class="cov0" title="0">{ return s.UniversalPlatform.GetLength() }</span>
func (s *SpacePlatform) GetWidth() float64       <span class="cov0" title="0">{ return s.UniversalPlatform.GetWidth() }</span>
func (s *SpacePlatform) GetHeight() float64      <span class="cov0" title="0">{ return s.UniversalPlatform.GetHeight() }</span>
func (s *SpacePlatform) GetMass() float64        <span class="cov0" title="0">{ return s.UniversalPlatform.GetMass() }</span>

func (s *SpacePlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        s.UniversalPlatform.UpdateState(state)
}</span>

func (s *SpacePlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        return s.UniversalPlatform.SetDestination(pos)
}</span>

// Enhanced 3D physics methods
func (s *SpacePlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        s.UniversalPlatform.Initialize3DPhysics()
}</span>

func (s *SpacePlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov0" title="0">{
        return s.UniversalPlatform.Update3DPhysics(deltaTime)
}</span>

func (s *SpacePlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return s.UniversalPlatform.GetPhysicsState()
}</span>

func (s *SpacePlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        s.UniversalPlatform.SetPhysicsState(physics)
}</span>

// Update implements simplified orbital mechanics
func (s *SpacePlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        // Use enhanced orbital mechanics from UniversalPlatform base
        // but can override for specialized space platform behavior

        // Simplified orbital mechanics - circular orbit approximation
        dt := deltaTime.Seconds()

        // Calculate orbital velocity based on altitude
        earthRadius := 6371000.0 // meters
        altitude := s.UniversalPlatform.State.Position.Altitude
        orbitalRadius := earthRadius + altitude

        // Simplified orbital velocity: v = sqrt(GM/r)
        // Using approximation for Earth: GM ‚âà 3.986e14 m¬≥/s¬≤
        GM := 3.986e14
        orbitalVelocity := math.Sqrt(GM / orbitalRadius)

        // Angular velocity (radians per second)
        angularVelocity := orbitalVelocity / orbitalRadius

        // Update position in simplified circular orbit
        // Convert lat/lon to radians for calculation
        lonRad := s.UniversalPlatform.State.Position.Longitude * math.Pi / 180

        // Simple eastward progression (simplified)
        lonRad += angularVelocity * dt

        // Wrap longitude
        for lonRad &gt; math.Pi </span><span class="cov0" title="0">{
                lonRad -= 2 * math.Pi
        }</span>
        <span class="cov0" title="0">for lonRad &lt; -math.Pi </span><span class="cov0" title="0">{
                lonRad += 2 * math.Pi
        }</span>

        // Convert back to degrees
        <span class="cov0" title="0">s.UniversalPlatform.State.Position.Longitude = lonRad * 180 / math.Pi

        // Update speed and heading
        s.UniversalPlatform.State.Speed = orbitalVelocity
        s.UniversalPlatform.State.Heading = 90 // Eastward movement
        s.UniversalPlatform.State.LastUpdated = time.Now()

        return nil</span>
}

// Space platform factory functions using UniversalPlatform base

// NewISSModule creates an International Space Station module
func NewISSModule(id, moduleName string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // ISS orbits at approximately 408 km altitude
        startPos.Altitude = 408000

        typeDef := &amp;PlatformTypeDefinition{
                Class: "ISS Module",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      7660, // m/s (ISS orbital velocity)
                        CruiseSpeed:   7660, // m/s
                        Acceleration:  0,    // orbital mechanics
                        TurningRadius: 0,    // not applicable
                        Range:         0,    // unlimited in orbit
                },
                Physical: PhysicalCharacteristics{
                        Length: 73,     // meters (full ISS)
                        Width:  109,    // meters (solar array span)
                        Height: 20,     // meters
                        Mass:   420000, // kg
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("ISS %s", moduleName),
                Type: "ISS Module",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("ISS%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,   // Eastward
                        Speed:       7660, // m/s
                        LastUpdated: time.Now(),
                },
        }

        return &amp;SpacePlatform{
                UniversalPlatform: universalPlatform,
                OrbitalPeriod:     5520,   // seconds (92 minutes)
                Apogee:            420000, // meters
                Perigee:           408000, // meters
                Inclination:       51.6,   // degrees
                Eccentricity:      0.0001, // nearly circular
                MissionType:       "space station",
                LaunchDate:        time.Date(1998, 11, 20, 0, 0, 0, 0, time.UTC),
                MissionDuration:   time.Hour * 24 * 365 * 30, // 30 years planned
                SolarPanelArea:    2500,                      // square meters
                PowerGeneration:   84000,                     // watts
                FuelRemaining:     1000,                      // kg (for reboost)
                RadiationShield:   true,
        }
}</span>

// NewStarlinkSatellite creates a Starlink communication satellite
func NewStarlinkSatellite(id, satelliteNumber string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Starlink operates at ~550 km altitude
        startPos.Altitude = 550000

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Starlink Satellite",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:     7590, // m/s
                        CruiseSpeed:  7590,
                        Acceleration: 0,
                        Range:        0,
                },
                Physical: PhysicalCharacteristics{
                        Length: 2.8,  // meters
                        Width:  1.9,  // meters
                        Height: 0.32, // meters
                        Mass:   260,  // kg
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("Starlink-%s", satelliteNumber),
                Type: "Starlink Satellite",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("STARLINK%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7590,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;SpacePlatform{
                UniversalPlatform: universalPlatform,
                OrbitalPeriod:     5760,   // seconds (96 minutes)
                Apogee:            550000, // meters
                Perigee:           550000, // meters
                Inclination:       53.0,   // degrees
                Eccentricity:      0.0,    // circular orbit
                MissionType:       "communication",
                LaunchDate:        time.Now(),
                MissionDuration:   time.Hour * 24 * 365 * 5, // 5 years
                SolarPanelArea:    8.0,                      // square meters
                PowerGeneration:   4000,                     // watts
                FuelRemaining:     50,                       // kg
                RadiationShield:   false,
        }
}</span>

// NewGPSSatellite creates a GPS navigation satellite
func NewGPSSatellite(id, satelliteNumber string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // GPS operates at ~20,200 km altitude
        startPos.Altitude = 20200000

        typeDef := &amp;PlatformTypeDefinition{
                Class: "GPS Block III",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:     3870, // m/s
                        CruiseSpeed:  3870,
                        Acceleration: 0,
                        Range:        0,
                },
                Physical: PhysicalCharacteristics{
                        Length: 3.0,  // meters
                        Width:  2.0,  // meters
                        Height: 1.7,  // meters
                        Mass:   2000, // kg
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("GPS III-%s", satelliteNumber),
                Type: "GPS Block III",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("GPS%s", satelliteNumber),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       3870,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;SpacePlatform{
                UniversalPlatform: universalPlatform,
                OrbitalPeriod:     43200,    // seconds (12 hours)
                Apogee:            20200000, // meters
                Perigee:           20200000, // meters
                Inclination:       55.0,     // degrees
                Eccentricity:      0.0,      // circular orbit
                MissionType:       "navigation",
                LaunchDate:        time.Date(2010, 1, 1, 0, 0, 0, 0, time.UTC),
                MissionDuration:   time.Hour * 24 * 365 * 15, // 15 years
                SolarPanelArea:    22.0,                      // square meters
                PowerGeneration:   2900,                      // watts
                FuelRemaining:     200,                       // kg
                RadiationShield:   true,
        }
}</span>

// NewHubbleTelescope creates the Hubble Space Telescope
func NewHubbleTelescope(id string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Hubble orbits at ~547 km altitude
        startPos.Altitude = 547000

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Space Telescope",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:     7590, // m/s
                        CruiseSpeed:  7590,
                        Acceleration: 0,
                        Range:        0,
                },
                Physical: PhysicalCharacteristics{
                        Length: 13.3,  // meters
                        Width:  4.3,   // meters (diameter)
                        Height: 4.3,   // meters
                        Mass:   11110, // kg
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: "Hubble Space Telescope",
                Type: "Space Telescope",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     "HUBBLE",
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7590,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;SpacePlatform{
                UniversalPlatform: universalPlatform,
                OrbitalPeriod:     5730,   // seconds (95.5 minutes)
                Apogee:            547000, // meters
                Perigee:           547000, // meters
                Inclination:       28.5,   // degrees
                Eccentricity:      0.0003, // nearly circular
                MissionType:       "observation",
                LaunchDate:        time.Date(1990, 4, 24, 0, 0, 0, 0, time.UTC),
                MissionDuration:   time.Hour * 24 * 365 * 35, // extended mission
                SolarPanelArea:    50.0,                      // square meters
                PowerGeneration:   2800,                      // watts
                FuelRemaining:     0,                         // no fuel, uses reaction wheels
                RadiationShield:   true,
        }
}</span>

// NewDragonCapsule creates a SpaceX Dragon spacecraft
func NewDragonCapsule(id, missionName string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Dragon typically operates at ISS altitude
        startPos.Altitude = 408000

        typeDef := &amp;PlatformTypeDefinition{
                Class: "Dragon 2 Capsule",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:     7660, // m/s
                        CruiseSpeed:  7660,
                        Acceleration: 0,
                        Range:        0,
                },
                Physical: PhysicalCharacteristics{
                        Length: 8.1,   // meters (with trunk)
                        Width:  3.7,   // meters (diameter)
                        Height: 3.7,   // meters
                        Mass:   12055, // kg (fully loaded)
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: fmt.Sprintf("Dragon %s", missionName),
                Type: "Dragon 2 Capsule",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     fmt.Sprintf("DRAGON%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7660,
                        LastUpdated: time.Now(),
                },
        }

        return &amp;SpacePlatform{
                UniversalPlatform: universalPlatform,
                OrbitalPeriod:     5520,   // seconds
                Apogee:            420000, // meters
                Perigee:           408000, // meters
                Inclination:       51.6,   // degrees
                Eccentricity:      0.001,  // nearly circular
                MissionType:       "crew transport",
                LaunchDate:        time.Now(),
                MissionDuration:   time.Hour * 24 * 180, // 6 months typical
                SolarPanelArea:    15.0,                 // square meters
                PowerGeneration:   3000,                 // watts
                FuelRemaining:     400,                  // kg
                RadiationShield:   true,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package output

import (
        "encoding/xml"
        "fmt"
        "math"
        "time"
)

// Dimension constants for CoT message generation
const (
        DimensionAir    = "air"
        DimensionGround = "ground"
        DimensionSea    = "sea"
        DimensionSpace  = "space"
)

// CoTEvent represents a Cursor on Target event message
type CoTEvent struct {
        XMLName xml.Name  `xml:"event"`
        Version string    `xml:"version,attr"`
        UID     string    `xml:"uid,attr"`
        Type    string    `xml:"type,attr"`
        How     string    `xml:"how,attr"`
        Time    string    `xml:"time,attr"`
        Start   string    `xml:"start,attr"`
        Stale   string    `xml:"stale,attr"`
        Point   CoTPoint  `xml:"point"`
        Detail  CoTDetail `xml:"detail"`
}

// CoTPoint represents the geographical point in a CoT message
type CoTPoint struct {
        Lat float64 `xml:"lat,attr"`
        Lon float64 `xml:"lon,attr"`
        Hae float64 `xml:"hae,attr"`
        CE  float64 `xml:"ce,attr"` // Circular Error (meters)
        LE  float64 `xml:"le,attr"` // Linear Error (meters)
}

// CoTDetail contains platform-specific details
type CoTDetail struct {
        Contact CoTContact `xml:"contact"`
        Track   CoTTrack   `xml:"track"`
        Precis  CoTPrecis  `xml:"precisionlocation"`
}

// CoTContact contains contact information
type CoTContact struct {
        Callsign string `xml:"callsign,attr"`
        Endpoint string `xml:"endpoint,attr,omitempty"`
}

// CoTTrack contains movement information
type CoTTrack struct {
        Speed  float64 `xml:"speed,attr"`  // m/s
        Course float64 `xml:"course,attr"` // degrees true
}

// CoTPrecis contains precision location data
type CoTPrecis struct {
        Geopointsrc string `xml:"geopointsrc,attr"`
        Altsrc      string `xml:"altsrc,attr"`
}

// PlatformState represents the current state of a platform
type PlatformState struct {
        ID          string
        Callsign    string
        Latitude    float64
        Longitude   float64
        Altitude    float64
        Speed       float64
        Course      float64
        CoTType     string
        Affiliation string
}

// CoTGenerator generates Cursor on Target messages
type CoTGenerator struct {
        staleTime time.Duration
}

// NewCoTGenerator creates a new CoT message generator
func NewCoTGenerator() *CoTGenerator <span class="cov8" title="1">{
        return &amp;CoTGenerator{
                staleTime: 15 * time.Minute, // Default stale time
        }
}</span>

// GenerateCoTMessage creates a CoT XML message from platform state
func (g *CoTGenerator) GenerateCoTMessage(state PlatformState) ([]byte, error) <span class="cov8" title="1">{
        now := time.Now().UTC()
        staleTime := now.Add(g.staleTime)

        event := CoTEvent{
                Version: "2.0",
                UID:     fmt.Sprintf("TRAFFICSIM-%s", state.ID),
                Type:    state.CoTType,
                How:     "m-g", // machine-generated
                Time:    now.Format("2006-01-02T15:04:05.000Z"),
                Start:   now.Format("2006-01-02T15:04:05.000Z"),
                Stale:   staleTime.Format("2006-01-02T15:04:05.000Z"),
                Point: CoTPoint{
                        Lat: state.Latitude,
                        Lon: state.Longitude,
                        Hae: state.Altitude,
                        CE:  10.0, // 10 meter circular error
                        LE:  10.0, // 10 meter linear error
                },
                Detail: CoTDetail{
                        Contact: CoTContact{
                                Callsign: state.Callsign,
                                Endpoint: fmt.Sprintf("trafficsim:%s", state.ID),
                        },
                        Track: CoTTrack{
                                Speed:  state.Speed,
                                Course: state.Course,
                        },
                        Precis: CoTPrecis{
                                Geopointsrc: "GPS",
                                Altsrc:      "GPS",
                        },
                },
        }

        xmlData, err := xml.MarshalIndent(event, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add XML declaration
        <span class="cov8" title="1">xmlDeclaration := []byte(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;` + "\n")
        return append(xmlDeclaration, xmlData...), nil</span>
}

// GenerateMILSTD2525Type generates MIL-STD-2525D type codes based on platform category
func GenerateMILSTD2525Type(category, affiliation, dimension string) string <span class="cov8" title="1">{
        var affiliationCode string
        switch affiliation </span>{
        case "friend":<span class="cov8" title="1">
                affiliationCode = "f"</span>
        case "hostile":<span class="cov8" title="1">
                affiliationCode = "h"</span>
        case "neutral":<span class="cov8" title="1">
                affiliationCode = "n"</span>
        case "unknown":<span class="cov8" title="1">
                affiliationCode = "u"</span>
        default:<span class="cov0" title="0">
                affiliationCode = "u"</span>
        }

        <span class="cov8" title="1">var dimensionCode string
        switch dimension </span>{
        case DimensionAir:<span class="cov8" title="1">
                dimensionCode = "A"</span>
        case DimensionGround:<span class="cov8" title="1">
                dimensionCode = "G"</span>
        case DimensionSea:<span class="cov8" title="1">
                dimensionCode = "S"</span>
        case DimensionSpace:<span class="cov8" title="1">
                dimensionCode = "P"</span>
        default:<span class="cov0" title="0">
                dimensionCode = "G"</span>
        }

        // Generate type based on category and dimension
        <span class="cov8" title="1">switch </span>{
        case dimension == DimensionAir &amp;&amp; category == "fighter_aircraft":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-M-F", affiliationCode, dimensionCode)</span>
        case dimension == DimensionAir &amp;&amp; category == "unmanned_aircraft":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-M-U", affiliationCode, dimensionCode)</span>
        case dimension == DimensionAir &amp;&amp; category == "commercial_aircraft":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-C-F", affiliationCode, dimensionCode)</span>
        case dimension == DimensionGround &amp;&amp; category == "main_battle_tank":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-C-I", affiliationCode, dimensionCode)</span>
        case dimension == DimensionGround &amp;&amp; category == "tactical_vehicle":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-C-V", affiliationCode, dimensionCode)</span>
        case dimension == DimensionGround &amp;&amp; category == "commercial_vehicle":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-C-V", affiliationCode, dimensionCode)</span>
        case dimension == DimensionSea &amp;&amp; category == "destroyer":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-W-D", affiliationCode, dimensionCode)</span>
        case dimension == DimensionSea &amp;&amp; category == "cargo_vessel":<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-C-V", affiliationCode, dimensionCode)</span>
        case dimension == DimensionSpace:<span class="cov8" title="1">
                return fmt.Sprintf("a-%s-%s-U-S", affiliationCode, dimensionCode)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("a-%s-%s-U", affiliationCode, dimensionCode)</span>
        }
}

// CalculateCourse calculates course between two points
func CalculateCourse(lat1, lon1, lat2, lon2 float64) float64 <span class="cov8" title="1">{
        // Convert to radians
        lat1Rad := lat1 * math.Pi / 180
        lat2Rad := lat2 * math.Pi / 180
        deltaLon := (lon2 - lon1) * math.Pi / 180

        y := math.Sin(deltaLon) * math.Cos(lat2Rad)
        x := math.Cos(lat1Rad)*math.Sin(lat2Rad) - math.Sin(lat1Rad)*math.Cos(lat2Rad)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180 / math.Pi

        // Normalize to 0-360 degrees
        if bearing &lt; 0 </span><span class="cov8" title="1">{
                bearing += 360
        }</span>

        <span class="cov8" title="1">return bearing</span>
}

// SetStaleTime sets the stale time for generated CoT messages
func (g *CoTGenerator) SetStaleTime(duration time.Duration) <span class="cov8" title="1">{
        g.staleTime = duration
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package output

import (
        "fmt"
        "log"
        "net"
        "time"
)

// MulticastPublisher handles publishing CoT messages to multicast groups
type MulticastPublisher struct {
        conn          *net.UDPConn
        multicastAddr *net.UDPAddr
        generator     *CoTGenerator
        interval      time.Duration
}

// NewMulticastPublisher creates a new multicast publisher for CoT messages
func NewMulticastPublisher(multicastIP string, port int) (*MulticastPublisher, error) <span class="cov8" title="1">{
        addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%d", multicastIP, port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve multicast address: %w", err)
        }</span>

        <span class="cov8" title="1">conn, err := net.DialUDP("udp", nil, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create UDP connection: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;MulticastPublisher{
                conn:          conn,
                multicastAddr: addr,
                generator:     NewCoTGenerator(),
                interval:      5 * time.Second, // Default 5 second interval
        }, nil</span>
}

// SetPublishInterval sets the interval for publishing CoT messages
func (p *MulticastPublisher) SetPublishInterval(interval time.Duration) <span class="cov8" title="1">{
        p.interval = interval
}</span>

// PublishPlatformState publishes a single platform state as CoT message
func (p *MulticastPublisher) PublishPlatformState(state PlatformState) error <span class="cov8" title="1">{
        cotMessage, err := p.generator.GenerateCoTMessage(state)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate CoT message: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = p.conn.Write(cotMessage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send CoT message: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StartPublishing starts a goroutine that continuously publishes platform states
func (p *MulticastPublisher) StartPublishing(platformStates chan PlatformState, stopChan chan bool) <span class="cov8" title="1">{
        ticker := time.NewTicker(p.interval)
        defer ticker.Stop()

        var latestStates = make(map[string]PlatformState)

        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case state := &lt;-platformStates:<span class="cov8" title="1">
                                latestStates[state.ID] = state</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Publish all latest platform states
                                for _, state := range latestStates </span><span class="cov0" title="0">{
                                        if err := p.PublishPlatformState(state); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error publishing CoT message for platform %s: %v", state.ID, err)
                                        }</span>
                                }
                        case &lt;-stopChan:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

// Close closes the multicast connection
func (p *MulticastPublisher) Close() error <span class="cov8" title="1">{
        if p.conn != nil </span><span class="cov8" title="1">{
                return p.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetMulticastAddress returns the configured multicast address
func (p *MulticastPublisher) GetMulticastAddress() string <span class="cov0" title="0">{
        return p.multicastAddr.String()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package output

import (
        "strings"

        "github.com/rhino11/trafficsim/internal/models"
)

// PlatformToCoTState converts a platform interface to a CoT PlatformState
// This function maps platform data to the structure needed for CoT generation
func PlatformToCoTState(platform models.Platform) PlatformState <span class="cov0" title="0">{
        state := platform.GetState()

        // Extract CoT type and affiliation from platform category and type
        cotType, affiliation := determinePlatformCoTInfo(platform)

        return PlatformState{
                ID:          platform.GetID(),
                Callsign:    platform.GetCallSign(),
                Latitude:    state.Position.Latitude,
                Longitude:   state.Position.Longitude,
                Altitude:    state.Position.Altitude,
                Speed:       state.Speed,
                Course:      state.Heading,
                CoTType:     cotType,
                Affiliation: affiliation,
        }
}</span>

// determinePlatformCoTInfo extracts CoT type and affiliation from platform data
func determinePlatformCoTInfo(platform models.Platform) (cotType, affiliation string) <span class="cov0" title="0">{
        platformType := strings.ToLower(string(platform.GetType()))
        class := strings.ToLower(platform.GetClass())

        // Try to get category from the platform if it's a UniversalPlatform
        category := "unknown"
        if up, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                category = strings.ToLower(up.TypeDef.Category)
        }</span>

        // Determine affiliation based on category and class
        <span class="cov0" title="0">affiliation = "neutral" // Default
        if strings.Contains(category, "military") || strings.Contains(class, "military") ||
                strings.Contains(class, "f-16") || strings.Contains(class, "f-22") ||
                strings.Contains(class, "abrams") || strings.Contains(class, "arleigh burke") ||
                strings.Contains(class, "destroyer") || strings.Contains(class, "hmmwv") </span><span class="cov0" title="0">{
                affiliation = "friend"
        }</span> else<span class="cov0" title="0"> if strings.Contains(category, "commercial") || strings.Contains(category, "civilian") ||
                strings.Contains(class, "boeing") || strings.Contains(class, "airbus") ||
                strings.Contains(class, "container") || strings.Contains(class, "tesla") </span><span class="cov0" title="0">{
                affiliation = "neutral"
        }</span>

        // Determine dimension
        <span class="cov0" title="0">var dimension string
        switch platformType </span>{
        case "airborne":<span class="cov0" title="0">
                dimension = DimensionAir</span>
        case "land":<span class="cov0" title="0">
                dimension = DimensionGround</span>
        case "maritime":<span class="cov0" title="0">
                dimension = DimensionSea</span>
        case "space":<span class="cov0" title="0">
                dimension = DimensionSpace</span>
        default:<span class="cov0" title="0">
                dimension = DimensionGround</span>
        }

        // Map specific platform categories to more specific CoT categories for better type generation
        <span class="cov0" title="0">mappedCategory := mapCategoryForCoT(category, class)

        // Generate CoT type using the existing function
        cotType = GenerateMILSTD2525Type(mappedCategory, affiliation, dimension)

        return cotType, affiliation</span>
}

// mapCategoryForCoT maps platform categories/classes to CoT-specific categories
func mapCategoryForCoT(category, class string) string <span class="cov0" title="0">{
        classLower := strings.ToLower(class)
        categoryLower := strings.ToLower(category)

        // Aircraft types
        if strings.Contains(classLower, "f-16") || strings.Contains(classLower, "f-22") ||
                strings.Contains(classLower, "fighter") </span><span class="cov0" title="0">{
                return "fighter_aircraft"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "boeing") || strings.Contains(classLower, "airbus") ||
                strings.Contains(categoryLower, "commercial") </span><span class="cov0" title="0">{
                return "commercial_aircraft"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "c-130") || strings.Contains(classLower, "hercules") </span><span class="cov0" title="0">{
                return "transport_aircraft"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "mq-9") || strings.Contains(classLower, "reaper") ||
                strings.Contains(categoryLower, "drone") </span><span class="cov0" title="0">{
                return "unmanned_aircraft"
        }</span>

        // Ground vehicle types
        <span class="cov0" title="0">if strings.Contains(classLower, "abrams") || strings.Contains(categoryLower, "tank") </span><span class="cov0" title="0">{
                return "main_battle_tank"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "hmmwv") || strings.Contains(categoryLower, "tactical") </span><span class="cov0" title="0">{
                return "tactical_vehicle"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "tesla") || strings.Contains(classLower, "truck") ||
                strings.Contains(categoryLower, "commercial") || strings.Contains(categoryLower, "civilian") </span><span class="cov0" title="0">{
                return "commercial_vehicle"
        }</span>

        // Maritime types
        <span class="cov0" title="0">if strings.Contains(classLower, "destroyer") || strings.Contains(classLower, "arleigh burke") </span><span class="cov0" title="0">{
                return "destroyer"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "container") || strings.Contains(classLower, "cargo") </span><span class="cov0" title="0">{
                return "cargo_vessel"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "submarine") </span><span class="cov0" title="0">{
                return "submarine"
        }</span>

        // Space types
        <span class="cov0" title="0">if strings.Contains(classLower, "satellite") || strings.Contains(classLower, "starlink") </span><span class="cov0" title="0">{
                return "satellite"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "station") || strings.Contains(classLower, "iss") </span><span class="cov0" title="0">{
                return "space_station"
        }</span>
        <span class="cov0" title="0">if strings.Contains(classLower, "gps") </span><span class="cov0" title="0">{
                return "navigation_satellite"
        }</span>

        // Fall back to the original category
        <span class="cov0" title="0">return categoryLower</span>
}

// ConvertPlatformListToCoTStates converts a list of platforms to CoT states
func ConvertPlatformListToCoTStates(platforms []models.Platform) []PlatformState <span class="cov0" title="0">{
        states := make([]PlatformState, len(platforms))
        for i, platform := range platforms </span><span class="cov0" title="0">{
                states[i] = PlatformToCoTState(platform)
        }</span>
        <span class="cov0" title="0">return states</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
        "gopkg.in/yaml.v3"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
        "github.com/rhino11/trafficsim/internal/sim"
)

// isTestMode checks if we're running in test mode
func isTestMode() bool <span class="cov8" title="1">{
        return strings.Contains(os.Args[0], ".test") ||
                strings.HasSuffix(os.Args[0], "/test") ||
                os.Getenv("GO_TESTING") == "1"
}</span>

// logf is a conditional logger that respects test verbosity
func logf(format string, args ...interface{}) <span class="cov8" title="1">{
        if isTestMode() </span><span class="cov8" title="1">{
                // In test mode, suppress output unless explicitly enabled
                if os.Getenv("VERBOSE_TESTS") == "1" </span><span class="cov0" title="0">{
                        log.Printf(format, args...)
                }</span>
                // Otherwise suppress output in test mode
        } else<span class="cov0" title="0"> {
                // In production mode, always log
                log.Printf(format, args...)
        }</span>
}

// Enhanced logging for web interface debugging
func logWebRequest(r *http.Request, status string) <span class="cov8" title="1">{
        logf("[WEB] %s %s - %s - User-Agent: %s - RemoteAddr: %s",
                r.Method, r.URL.Path, status, r.UserAgent(), r.RemoteAddr)
}</span>

func logWebError(context string, err error) <span class="cov8" title="1">{
        logf("[WEB-ERROR] %s: %v", context, err)
}</span>

func logWebSocket(action string, clientCount int) <span class="cov0" title="0">{
        logf("[WEBSOCKET] %s - Active clients: %d", action, clientCount)
}</span>

func logJSLoad(filename string, status string) <span class="cov0" title="0">{
        logf("[JS-LOAD] %s - %s", filename, status)
}</span>

func logInitialization(component string, status string, duration time.Duration) <span class="cov8" title="1">{
        logf("[INIT] %s - %s (took %v)", component, status, duration)
}</span>

func logSimulationEvent(event string, details interface{}) <span class="cov0" title="0">{
        logf("[SIM] %s - %+v", event, details)
}</span>

func logPerformance(metric string, value interface{}) <span class="cov8" title="1">{
        logf("[PERF] %s: %v", metric, value)
}</span>

func logDebug(component string, message string, data interface{}) <span class="cov0" title="0">{
        logf("[DEBUG] [%s] %s - %+v", component, message, data)
}</span>

func logClientMessage(msgType string, clientAddr string, data interface{}) <span class="cov0" title="0">{
        logf("[CLIENT-MSG] Type: %s, From: %s, Data: %+v", msgType, clientAddr, data)
}</span>

func logDataStream(component string, action string, details interface{}) <span class="cov0" title="0">{
        logf("[STREAM] [%s] %s - %+v", component, action, details)
}</span>

func logPlatformUpdate(platformCount int, action string) <span class="cov0" title="0">{
        logf("[PLATFORM] %s - Count: %d", action, platformCount)
}</span>

// Server represents the web server for the traffic simulation
type Server struct {
        config     *config.Config
        simulation *sim.Engine
        router     *mux.Router
        upgrader   websocket.Upgrader
        clients    map[*websocket.Conn]bool
        clientsMux sync.RWMutex
        broadcast  chan []byte
        ctx        context.Context
        cancel     context.CancelFunc
}

// Client represents a connected WebSocket client
type Client struct {
        conn   *websocket.Conn
        send   chan []byte
        server *Server
}

// Message represents a WebSocket message
type Message struct {
        Type      string      `json:"type"`
        Data      interface{} `json:"data,omitempty"`
        Timestamp int64       `json:"timestamp"`
}

// PlatformUpdate represents a platform update message
type PlatformUpdate struct {
        Type      string            `json:"type"`
        Platforms []models.Platform `json:"platforms"`
        Timestamp int64             `json:"timestamp"`
}

// SimulationStatus represents simulation status
type SimulationStatus struct {
        Running       bool    `json:"running"`
        Time          float64 `json:"time"`
        PlatformCount int     `json:"platform_count"`
        Speed         float64 `json:"speed"`
}

// NewServer creates a new web server instance
func NewServer(cfg *config.Config, simulation *sim.Engine) *Server <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        server := &amp;Server{
                config:     cfg,
                simulation: simulation,
                router:     mux.NewRouter(),
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true // Allow all origins for development
                        }</span>,
                },
                clients:   make(map[*websocket.Conn]bool),
                broadcast: make(chan []byte, 256),
                ctx:       ctx,
                cancel:    cancel,
        }

        <span class="cov8" title="1">server.setupRoutes()
        return server</span>
}

// setupRoutes configures all HTTP routes
func (s *Server) setupRoutes() <span class="cov8" title="1">{
        // Static files with logging
        staticHandler := http.StripPrefix("/static/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                logWebRequest(r, "SERVING_STATIC")

                // Serve the file
                fileServer := http.FileServer(http.Dir("web/static/"))
                fileServer.ServeHTTP(w, r)

                duration := time.Since(start)
                logPerformance("static_file_serve", map[string]interface{}{
                        "file":     r.URL.Path,
                        "duration": duration,
                })

                // Log JavaScript file loads specifically
                if strings.HasSuffix(r.URL.Path, ".js") </span><span class="cov0" title="0">{
                        logJSLoad(r.URL.Path, "LOADED")
                }</span>
        }))
        <span class="cov8" title="1">s.router.PathPrefix("/static/").Handler(staticHandler)

        // WebSocket endpoint
        s.router.HandleFunc("/ws", s.handleWebSocket)

        // API endpoints with logging middleware
        api := s.router.PathPrefix("/api").Subrouter()
        api.Use(s.loggingMiddleware)
        api.HandleFunc("/platforms", s.handleGetPlatforms).Methods("GET")
        api.HandleFunc("/platform-types", s.handleGetPlatformTypes).Methods("GET")
        api.HandleFunc("/simulation/start", s.handleStartSimulation).Methods("POST")
        api.HandleFunc("/simulation/stop", s.handleStopSimulation).Methods("POST")
        api.HandleFunc("/simulation/reset", s.handleResetSimulation).Methods("POST")
        api.HandleFunc("/simulation/status", s.handleSimulationStatus).Methods("GET")
        api.HandleFunc("/stream/platforms", s.handleSSEPlatforms).Methods("GET")
        // Performance monitoring endpoint
        api.HandleFunc("/metrics", s.handleMetrics).Methods("GET")
        // Client logging endpoint for debugging
        api.HandleFunc("/log", s.handleClientLog).Methods("POST")
        // Scenario creation endpoint
        api.HandleFunc("/scenarios", s.handleCreateScenario).Methods("POST")

        // Main page
        s.router.HandleFunc("/", s.handleIndex).Methods("GET")
        // Scenario Builder page
        s.router.HandleFunc("/scenario-builder", s.handleScenarioBuilder).Methods("GET")

        logInitialization("Router", "CONFIGURED", 0)</span>
}

// Start starts the web server
func (s *Server) Start(port string) error <span class="cov0" title="0">{
        log.Printf("Starting web server on port %s", port)

        // Start the broadcast goroutine
        go s.handleBroadcast()

        // Start simulation updates if simulation is running
        go s.streamSimulationUpdates()

        // Create HTTP server with proper timeouts for security
        server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      s.router,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        return server.ListenAndServe()
}</span>

// Stop stops the web server
func (s *Server) Stop() <span class="cov8" title="1">{
        s.cancel()

        // Close all WebSocket connections with proper error handling
        s.clientsMux.Lock()
        for client := range s.clients </span><span class="cov0" title="0">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection: %v", err)
                }</span>
        }
        <span class="cov8" title="1">s.clientsMux.Unlock()</span>
}

// handleIndex serves the main HTML page
func (s *Server) handleIndex(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tmpl, err := template.ParseFiles("web/templates/index.html")
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Error loading template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Traffic Simulation",
        }

        if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error executing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// handleScenarioBuilder serves the scenario builder HTML page
func (s *Server) handleScenarioBuilder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tmpl, err := template.ParseFiles("web/templates/scenario-builder.html")
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Error loading scenario builder template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Scenario Builder - Traffic Simulation",
        }

        if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error executing scenario builder template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// handleWebSocket handles WebSocket connections
func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;Client{
                conn:   conn,
                send:   make(chan []byte, 256),
                server: s,
        }

        s.clientsMux.Lock()
        s.clients[conn] = true
        s.clientsMux.Unlock()

        logWebSocket("New connection", len(s.clients))

        // Send initial data
        go s.sendInitialData(client)

        // Start goroutines for this client
        go client.writePump()
        go client.readPump()</span>
}

// sendInitialData sends initial platform data to a new client
func (s *Server) sendInitialData(client *Client) <span class="cov0" title="0">{
        platforms := s.simulation.GetAllPlatforms()

        message := PlatformUpdate{
                Type:      "platform_update",
                Platforms: platforms,
                Timestamp: time.Now().UnixMilli(),
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling initial data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">select </span>{
        case client.send &lt;- data:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                log.Printf("Timeout sending initial data to client")</span>
        }
}

// handleGetPlatforms returns all current platforms
func (s *Server) handleGetPlatforms(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        platforms := s.simulation.GetAllPlatforms()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(platforms); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error encoding platforms: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// handleGetPlatformTypes returns all available platform types from distributed files or configuration
func (s *Server) handleGetPlatformTypes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // First try to load platform types from distributed files
        platformTypes, err := s.loadPlatformTypesFromFiles()
        if err != nil || len(platformTypes) == 0 </span><span class="cov0" title="0">{
                logf("Failed to load platform types from files, trying config: %v", err)
                // Fallback to configuration file loading
                platformTypes, err = s.loadPlatformTypesFromConfig()
                if err != nil || len(platformTypes) == 0 </span><span class="cov0" title="0">{
                        logf("Failed to load platform types from config, using fallback: %v", err)
                        // Final fallback to hardcoded data
                        platformTypes = s.getFallbackPlatformTypes()
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(platformTypes); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error encoding platform types: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// PlatformTypeInfo represents a platform type for the scenario builder
type PlatformTypeInfo struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Class       string                 `json:"class"`
        Category    string                 `json:"category"`
        Domain      string                 `json:"domain"`
        Description string                 `json:"description"`
        Performance map[string]interface{} `json:"performance"`
}

// loadPlatformTypesFromConfig loads platform types from YAML configuration files
func (s *Server) loadPlatformTypesFromConfig() ([]PlatformTypeInfo, error) <span class="cov0" title="0">{
        // Load configuration from file
        cfg, err := config.LoadConfig("data/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not load configuration: %v", err)
                return s.getDefaultPlatformTypes(), nil
        }</span>

        <span class="cov0" title="0">var platformTypes []PlatformTypeInfo

        // Convert airborne types
        for typeID, typeDef := range cfg.Platforms.AirborneTypes </span><span class="cov0" title="0">{
                typeInfo := PlatformTypeInfo{
                        ID:          typeID,
                        Name:        typeDef.Name,
                        Class:       typeDef.Class,
                        Category:    typeDef.Category,
                        Domain:      "airborne",
                        Description: s.generateDescription(typeID),
                        Performance: map[string]interface{}{
                                "max_speed":    typeDef.MaxSpeed,
                                "cruise_speed": typeDef.CruiseSpeed,
                                "max_altitude": typeDef.MaxAltitude,
                        },
                }
                platformTypes = append(platformTypes, typeInfo)
        }</span>

        // Convert maritime types
        <span class="cov0" title="0">for typeID, typeDef := range cfg.Platforms.MaritimeTypes </span><span class="cov0" title="0">{
                typeInfo := PlatformTypeInfo{
                        ID:          typeID,
                        Name:        typeDef.Name,
                        Class:       typeDef.Class,
                        Category:    typeDef.Category,
                        Domain:      "maritime",
                        Description: s.generateDescription(typeID),
                        Performance: map[string]interface{}{
                                "max_speed":    typeDef.MaxSpeed,
                                "cruise_speed": typeDef.CruiseSpeed,
                        },
                }
                platformTypes = append(platformTypes, typeInfo)
        }</span>

        // Convert land types
        <span class="cov0" title="0">for typeID, typeDef := range cfg.Platforms.LandTypes </span><span class="cov0" title="0">{
                typeInfo := PlatformTypeInfo{
                        ID:          typeID,
                        Name:        typeDef.Name,
                        Class:       typeDef.Class,
                        Category:    typeDef.Category,
                        Domain:      "land",
                        Description: s.generateDescription(typeID),
                        Performance: map[string]interface{}{
                                "max_speed":    typeDef.MaxSpeed,
                                "cruise_speed": typeDef.CruiseSpeed,
                        },
                }
                platformTypes = append(platformTypes, typeInfo)
        }</span>

        // Convert space types
        <span class="cov0" title="0">for typeID, typeDef := range cfg.Platforms.SpaceTypes </span><span class="cov0" title="0">{
                typeInfo := PlatformTypeInfo{
                        ID:          typeID,
                        Name:        typeDef.Name,
                        Class:       typeDef.Class,
                        Category:    typeDef.Category,
                        Domain:      "space",
                        Description: s.generateDescription(typeID),
                        Performance: map[string]interface{}{
                                "orbital_velocity": typeDef.MaxSpeed,
                                "orbital_altitude": typeDef.MaxAltitude,
                        },
                }
                platformTypes = append(platformTypes, typeInfo)
        }</span>

        <span class="cov0" title="0">if len(platformTypes) == 0 </span><span class="cov0" title="0">{
                return s.getDefaultPlatformTypes(), nil
        }</span>

        <span class="cov0" title="0">return platformTypes, nil</span>
}

// loadPlatformTypesFromFiles loads platform types from distributed YAML files in data/platforms/
func (s *Server) loadPlatformTypesFromFiles() ([]PlatformTypeInfo, error) <span class="cov8" title="1">{
        var platformTypes []PlatformTypeInfo

        // Define the domains and their subdirectories
        domains := map[string][]string{
                "airborne": {"commercial", "military"},
                "land":     {"commercial", "military"},
                "maritime": {"commercial", "military"},
                "space":    {"commercial", "military"},
        }

        // Walk through each domain directory
        for domain, categories := range domains </span><span class="cov8" title="1">{
                for _, category := range categories </span><span class="cov8" title="1">{
                        platformDir := fmt.Sprintf("data/platforms/%s/%s", domain, category)

                        // Check if directory exists
                        if _, err := os.Stat(platformDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                logf("Platform directory does not exist: %s", platformDir)
                                continue</span>
                        }

                        // Read all YAML files in the directory
                        <span class="cov8" title="1">files, err := os.ReadDir(platformDir)
                        if err != nil </span><span class="cov0" title="0">{
                                logf("Error reading platform directory %s: %v", platformDir, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                                if !strings.HasSuffix(file.Name(), ".yaml") &amp;&amp; !strings.HasSuffix(file.Name(), ".yml") </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">filePath := fmt.Sprintf("%s/%s", platformDir, file.Name())
                                platformInfo, err := s.loadPlatformFromFile(filePath, domain, category)
                                if err != nil </span><span class="cov0" title="0">{
                                        logf("Error loading platform from %s: %v", filePath, err)
                                        continue</span>
                                }

                                <span class="cov8" title="1">if platformInfo != nil </span><span class="cov8" title="1">{
                                        platformTypes = append(platformTypes, *platformInfo)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(platformTypes) == 0 </span><span class="cov8" title="1">{
                logf("No platform types loaded from files, using fallback")
                return s.getFallbackPlatformTypes(), nil
        }</span>

        <span class="cov8" title="1">logf("Loaded %d platform types from distributed files", len(platformTypes))
        return platformTypes, nil</span>
}

// loadPlatformFromFile loads a single platform type from a YAML file
func (s *Server) loadPlatformFromFile(filePath, domain, category string) (*PlatformTypeInfo, error) <span class="cov8" title="1">{
        // Validate and clean the file path to prevent directory traversal attacks
        cleanPath := filepath.Clean(filePath)

        // Ensure the path is within the expected data/platforms directory
        expectedPrefix := filepath.Clean("data/platforms/")
        if !strings.HasPrefix(cleanPath, expectedPrefix) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file path: %s is outside allowed directory", filePath)
        }</span>

        // Additional validation: ensure no directory traversal sequences
        <span class="cov8" title="1">if strings.Contains(filePath, "..") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file path: directory traversal detected in %s", filePath)
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read file %s: %w", cleanPath, err)
        }</span>

        // Parse the YAML structure
        <span class="cov8" title="1">var platformFile struct {
                PlatformTypes map[string]struct {
                        Class       string `yaml:"class"`
                        Category    string `yaml:"category"`
                        Performance struct {
                                MaxSpeed    float64 `yaml:"max_speed"`
                                CruiseSpeed float64 `yaml:"cruise_speed"`
                                MaxAltitude float64 `yaml:"max_altitude"`
                        } `yaml:"performance"`
                } `yaml:"platform_types"`
        }

        if err := yaml.Unmarshal(data, &amp;platformFile); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML file %s: %w", filePath, err)
        }</span>

        // Extract the first (and typically only) platform type from the file
        <span class="cov8" title="1">for typeID, typeDef := range platformFile.PlatformTypes </span><span class="cov8" title="1">{
                platformInfo := &amp;PlatformTypeInfo{
                        ID:          typeID,
                        Name:        typeDef.Class,
                        Class:       typeDef.Class,
                        Category:    typeDef.Category,
                        Domain:      domain,
                        Description: s.generateDescription(typeID),
                        Performance: map[string]interface{}{
                                "max_speed":    typeDef.Performance.MaxSpeed,
                                "cruise_speed": typeDef.Performance.CruiseSpeed,
                        },
                }

                // Add altitude for airborne and space platforms
                if domain == "airborne" || domain == "space" </span><span class="cov8" title="1">{
                        platformInfo.Performance["max_altitude"] = typeDef.Performance.MaxAltitude
                }</span>

                <span class="cov8" title="1">return platformInfo, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no platform types found in file %s", filePath)</span>
}

// determineDomain determines the domain based on platform type
func (s *Server) determineDomain(platformType string) string <span class="cov8" title="1">{
        airborneTypes := []string{"airbus_a320", "boeing_777_300er", "f16_fighting_falcon", "commercial_aircraft", "fighter_aircraft"}
        maritimeTypes := []string{"container_ship", "arleigh_burke_destroyer", "cargo_vessel", "guided_missile_destroyer"}
        landTypes := []string{"truck", "tank", "convoy"}
        spaceTypes := []string{"satellite", "space_station"}

        for _, t := range airborneTypes </span><span class="cov8" title="1">{
                if strings.Contains(platformType, t) </span><span class="cov8" title="1">{
                        return "airborne"
                }</span>
        }
        <span class="cov8" title="1">for _, t := range maritimeTypes </span><span class="cov8" title="1">{
                if strings.Contains(platformType, t) </span><span class="cov8" title="1">{
                        return "maritime"
                }</span>
        }
        <span class="cov8" title="1">for _, t := range landTypes </span><span class="cov8" title="1">{
                if strings.Contains(platformType, t) </span><span class="cov8" title="1">{
                        return "land"
                }</span>
        }
        <span class="cov8" title="1">for _, t := range spaceTypes </span><span class="cov8" title="1">{
                if strings.Contains(platformType, t) </span><span class="cov8" title="1">{
                        return "space"
                }</span>
        }

        <span class="cov8" title="1">return "unknown"</span>
}

// generateDescription generates a description for a platform type
func (s *Server) generateDescription(platformType string) string <span class="cov8" title="1">{
        descriptions := map[string]string{
                "airbus_a320":             "Short to medium-range commercial airliner",
                "boeing_777_300er":        "Long-range wide-body commercial airliner",
                "f16_fighting_falcon":     "Multi-role fighter aircraft",
                "container_ship":          "Large cargo container vessel",
                "arleigh_burke_destroyer": "US Navy guided missile destroyer",
        }

        if desc, exists := descriptions[platformType]; exists </span><span class="cov8" title="1">{
                return desc
        }</span>

        // Use proper text casing instead of deprecated strings.Title
        <span class="cov8" title="1">caser := cases.Title(language.English)
        return fmt.Sprintf("%s platform", caser.String(strings.ReplaceAll(platformType, "_", " ")))</span>
}

// getFallbackPlatformTypes returns hardcoded platform types as fallback
func (s *Server) getFallbackPlatformTypes() []PlatformTypeInfo <span class="cov8" title="1">{
        return []PlatformTypeInfo{
                {
                        ID:          "airbus_a320",
                        Name:        "Airbus A320",
                        Class:       "Airbus A320",
                        Category:    "commercial_aircraft",
                        Domain:      "airborne",
                        Description: "Short to medium-range commercial airliner",
                        Performance: map[string]interface{}{
                                "max_speed":    257.0,
                                "cruise_speed": 230.0,
                                "max_altitude": 12000.0,
                        },
                },
                {
                        ID:          "boeing_777_300er",
                        Name:        "Boeing 777-300ER",
                        Class:       "Boeing 777-300ER",
                        Category:    "wide_body_airliner",
                        Domain:      "airborne",
                        Description: "Long-range wide-body commercial airliner",
                        Performance: map[string]interface{}{
                                "max_speed":    290.0,
                                "cruise_speed": 257.0,
                                "max_altitude": 13100.0,
                        },
                },
                {
                        ID:          "f16_fighting_falcon",
                        Name:        "F-16 Fighting Falcon",
                        Class:       "F-16 Fighting Falcon",
                        Category:    "fighter_aircraft",
                        Domain:      "airborne",
                        Description: "Multi-role fighter aircraft",
                        Performance: map[string]interface{}{
                                "max_speed":    588.89,
                                "cruise_speed": 261.11,
                                "max_altitude": 15240.0,
                        },
                },
                {
                        ID:          "container_ship",
                        Name:        "Container Ship",
                        Class:       "Container Ship",
                        Category:    "cargo_vessel",
                        Domain:      "maritime",
                        Description: "Large cargo container vessel",
                        Performance: map[string]interface{}{
                                "max_speed":    12.9,
                                "cruise_speed": 10.8,
                        },
                },
                {
                        ID:          "arleigh_burke_destroyer",
                        Name:        "Arleigh Burke Destroyer",
                        Class:       "Arleigh Burke-class Destroyer",
                        Category:    "guided_missile_destroyer",
                        Domain:      "maritime",
                        Description: "US Navy guided missile destroyer",
                        Performance: map[string]interface{}{
                                "max_speed":    15.4,
                                "cruise_speed": 10.3,
                        },
                },
        }
}</span>

// getDefaultPlatformTypes returns default platform types when config loading fails
func (s *Server) getDefaultPlatformTypes() []PlatformTypeInfo <span class="cov0" title="0">{
        return []PlatformTypeInfo{
                {
                        ID:          "boeing_737_800",
                        Name:        "Boeing 737-800",
                        Class:       "Boeing 737-800",
                        Category:    "commercial_aircraft",
                        Domain:      "airborne",
                        Description: "Short to medium-range commercial airliner",
                        Performance: map[string]interface{}{
                                "max_speed":    257.0,
                                "cruise_speed": 230.0,
                                "max_altitude": 12000.0,
                        },
                },
                {
                        ID:          "f16_fighting_falcon",
                        Name:        "F-16 Fighting Falcon",
                        Class:       "F-16 Fighting Falcon",
                        Category:    "fighter_aircraft",
                        Domain:      "airborne",
                        Description: "Multi-role fighter aircraft",
                        Performance: map[string]interface{}{
                                "max_speed":    588.89,
                                "cruise_speed": 261.11,
                                "max_altitude": 15240.0,
                        },
                },
                {
                        ID:          "m1a2_abrams",
                        Name:        "M1A2 Abrams",
                        Class:       "M1A2 Abrams",
                        Category:    "main_battle_tank",
                        Domain:      "land",
                        Description: "Main battle tank",
                        Performance: map[string]interface{}{
                                "max_speed":    18.0,
                                "cruise_speed": 12.0,
                        },
                },
                {
                        ID:          "civilian_car",
                        Name:        "Civilian Car",
                        Class:       "Civilian Car",
                        Category:    "civilian_vehicle",
                        Domain:      "land",
                        Description: "Standard civilian automobile",
                        Performance: map[string]interface{}{
                                "max_speed":    36.1,
                                "cruise_speed": 25.0,
                        },
                },
                {
                        ID:          "arleigh_burke_destroyer",
                        Name:        "Arleigh Burke Destroyer",
                        Class:       "Arleigh Burke-class Destroyer",
                        Category:    "guided_missile_destroyer",
                        Domain:      "maritime",
                        Description: "US Navy guided missile destroyer",
                        Performance: map[string]interface{}{
                                "max_speed":    15.4,
                                "cruise_speed": 10.3,
                        },
                },
                {
                        ID:          "container_ship",
                        Name:        "Container Ship",
                        Class:       "Container Ship",
                        Category:    "cargo_vessel",
                        Domain:      "maritime",
                        Description: "Large cargo container vessel",
                        Performance: map[string]interface{}{
                                "max_speed":    12.9,
                                "cruise_speed": 10.8,
                        },
                },
                {
                        ID:          "starlink_satellite",
                        Name:        "Starlink Satellite",
                        Class:       "Starlink Satellite",
                        Category:    "communication_satellite",
                        Domain:      "space",
                        Description: "Low Earth orbit communication satellite",
                        Performance: map[string]interface{}{
                                "orbital_velocity": 7.66,
                                "orbital_altitude": 550000.0,
                        },
                },
        }
}</span>

// handleStartSimulation starts the simulation
func (s *Server) handleStartSimulation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err := s.simulation.Start(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error starting simulation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "started"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Start simulation response encoding", err)
        }</span>
}

// handleStopSimulation stops the simulation
func (s *Server) handleStopSimulation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        s.simulation.Stop()
        s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "stopped"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Stop simulation response encoding", err)
        }</span>
}

// handleResetSimulation resets the simulation
func (s *Server) handleResetSimulation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err := s.simulation.Reset(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error resetting simulation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "reset"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Reset simulation response encoding", err)
        }</span>
}

// handleSimulationStatus returns simulation status
func (s *Server) handleSimulationStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := SimulationStatus{
                Running:       s.simulation.IsRunning(),
                Time:          s.simulation.GetSimulationTime(),
                PlatformCount: len(s.simulation.GetAllPlatforms()),
                Speed:         1.0, // Default speed
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(status); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding status response: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// handleSSEPlatforms handles Server-Sent Events for platform updates
func (s *Server) handleSSEPlatforms(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
                return
        }</span>

        // Send initial data
        <span class="cov0" title="0">platforms := s.simulation.GetAllPlatforms()
        if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                data, _ := json.Marshal(platforms)
                fmt.Fprintf(w, "data: %s\n\n", data)
                flusher.Flush()
                log.Printf("SSE: Sent initial data with %d platforms", len(platforms))
        }</span>

        // Create a ticker to send regular updates
        <span class="cov0" title="0">ticker := time.NewTicker(100 * time.Millisecond) // 10 FPS
        defer ticker.Stop()

        // Keep connection alive ticker
        heartbeatTicker := time.NewTicker(30 * time.Second)
        defer heartbeatTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-r.Context().Done():<span class="cov0" title="0">
                        log.Printf("SSE: Client disconnected")
                        return</span>
                case &lt;-heartbeatTicker.C:<span class="cov0" title="0">
                        fmt.Fprintf(w, ": heartbeat\n\n")
                        flusher.Flush()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if s.simulation.IsRunning() </span><span class="cov0" title="0">{
                                platforms := s.simulation.GetAllPlatforms()
                                if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                                        message := PlatformUpdate{
                                                Type:      "platform_update",
                                                Platforms: platforms,
                                                Timestamp: time.Now().UnixMilli(),
                                        }

                                        data, err := json.Marshal(message)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error marshaling SSE platform update: %v", err)
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">fmt.Fprintf(w, "data: %s\n\n", data)
                                        flusher.Flush()</span>
                                }
                        }
                }
        }
}

// streamSimulationUpdates continuously streams simulation updates to WebSocket clients
func (s *Server) streamSimulationUpdates() <span class="cov0" title="0">{
        ticker := time.NewTicker(100 * time.Millisecond) // 10 FPS
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if s.simulation.IsRunning() </span><span class="cov0" title="0">{
                                platforms := s.simulation.GetAllPlatforms()

                                message := PlatformUpdate{
                                        Type:      "platform_update",
                                        Platforms: platforms,
                                        Timestamp: time.Now().UnixMilli(),
                                }

                                data, err := json.Marshal(message)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error marshaling platform update: %v", err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">select </span>{
                                case s.broadcast &lt;- data:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Channel is full, skip this update
                                }
                        }
                }
        }
}

// broadcastSimulationStatus broadcasts simulation status to all clients
func (s *Server) broadcastSimulationStatus() <span class="cov8" title="1">{
        status := SimulationStatus{
                Running:       s.simulation.IsRunning(),
                Time:          s.simulation.GetSimulationTime(),
                PlatformCount: len(s.simulation.GetAllPlatforms()),
                Speed:         1.0,
        }

        message := Message{
                Type:      "simulation_status",
                Data:      status,
                Timestamp: time.Now().UnixMilli(),
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling simulation status: %v", err)
                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case s.broadcast &lt;- data:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip this update
        }
}

// handleBroadcast handles broadcasting messages to all connected clients
func (s *Server) handleBroadcast() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case message := &lt;-s.broadcast:<span class="cov0" title="0">
                        s.clientsMux.RLock()
                        clientsToRemove := make([]*websocket.Conn, 0)

                        for client := range s.clients </span><span class="cov0" title="0">{
                                err := client.WriteMessage(websocket.TextMessage, message)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error writing to WebSocket client: %v", err)
                                        clientsToRemove = append(clientsToRemove, client)
                                }</span>
                        }
                        <span class="cov0" title="0">s.clientsMux.RUnlock()

                        // Remove failed clients
                        if len(clientsToRemove) &gt; 0 </span><span class="cov0" title="0">{
                                s.clientsMux.Lock()
                                for _, client := range clientsToRemove </span><span class="cov0" title="0">{
                                        delete(s.clients, client)
                                        if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error closing failed WebSocket client: %v", err)
                                        }</span>
                                }
                                <span class="cov0" title="0">s.clientsMux.Unlock()
                                logWebSocket("Removed failed clients", len(s.clients))</span>
                        }
                }
        }
}

// Client methods for WebSocket handling

// readPump handles reading messages from the WebSocket connection
func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.server.clientsMux.Lock()
                delete(c.server.clients, c.conn)
                c.server.clientsMux.Unlock()
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection in readPump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">c.conn.SetReadLimit(512)
        if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting read deadline: %v", err)
        }</span>
        <span class="cov0" title="0">c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error setting pong read deadline: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Handle incoming messages (ping, control messages, etc.)
                <span class="cov0" title="0">c.handleMessage(message)</span>
        }
}

// writePump handles writing messages to the WebSocket connection
func (c *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection in writePump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        if err := c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error setting write deadline: %v", err)
                        }</span>
                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                if err := c.conn.WriteMessage(websocket.CloseMessage, []byte{}); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error sending close message: %v", err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error setting ping write deadline: %v", err)
                        }</span>
                        <span class="cov0" title="0">if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleMessage handles incoming WebSocket messages
func (c *Client) handleMessage(data []byte) <span class="cov0" title="0">{
        clientAddr := c.conn.RemoteAddr().String()

        var msg Message
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                logWebError("Message unmarshaling", err)
                return
        }</span>

        <span class="cov0" title="0">logClientMessage(msg.Type, clientAddr, msg.Data)

        switch msg.Type </span>{
        case "ping":<span class="cov0" title="0">
                // Respond with pong
                response := Message{
                        Type:      "pong",
                        Timestamp: time.Now().UnixMilli(),
                }
                responseData, _ := json.Marshal(response)
                select </span>{
                case c.send &lt;- responseData:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">logDebug("WEBSOCKET", "Pong sent", map[string]interface{}{
                        "client":  clientAddr,
                        "latency": time.Now().UnixMilli() - msg.Timestamp,
                })</span>

        case "viewport_update":<span class="cov0" title="0">
                // Handle viewport changes for server-side filtering
                logDataStream("VIEWPORT", "Update received", msg.Data)</span>
                // Future: Implement viewport-based platform filtering

        case "filter_update":<span class="cov0" title="0">
                // Handle platform filter changes
                logDataStream("FILTER", "Update received", msg.Data)</span>
                // Future: Implement server-side platform filtering

        case "request_initial_data":<span class="cov0" title="0">
                // Send current platform data
                logDataStream("CLIENT", "Initial data requested", clientAddr)
                go c.server.sendInitialData(c)</span>

        case "start_simulation":<span class="cov0" title="0">
                // Handle simulation start command
                logSimulationEvent("START_REQUESTED", map[string]interface{}{
                        "client":    clientAddr,
                        "timestamp": msg.Timestamp,
                })
                if err := c.server.simulation.Start(); err != nil </span><span class="cov0" title="0">{
                        logWebError("Simulation start", err)
                }</span> else<span class="cov0" title="0"> {
                        c.server.broadcastSimulationStatus()
                }</span>

        case "stop_simulation":<span class="cov0" title="0">
                // Handle simulation stop command
                logSimulationEvent("STOP_REQUESTED", map[string]interface{}{
                        "client":    clientAddr,
                        "timestamp": msg.Timestamp,
                })
                c.server.simulation.Stop()
                c.server.broadcastSimulationStatus()</span>

        case "control":<span class="cov0" title="0">
                // Handle other simulation control messages
                logSimulationEvent("CONTROL_MESSAGE", msg.Data)</span>

        default:<span class="cov0" title="0">
                // Log unknown message types with full context for debugging
                logDebug("WEBSOCKET", "Unknown message type received", map[string]interface{}{
                        "type":      msg.Type,
                        "client":    clientAddr,
                        "data":      msg.Data,
                        "timestamp": msg.Timestamp,
                })</span>
        }
}

// handleClientLog handles client-side logging for debugging
func (s *Server) handleClientLog(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var logData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;logData); err != nil </span><span class="cov8" title="1">{
                logWebError("Client log decode", err)
                http.Error(w, "Invalid log data", http.StatusBadRequest)
                return
        }</span>

        // Log client-side events with context
        <span class="cov8" title="1">logType, _ := logData["type"].(string)
        step, _ := logData["step"].(string)
        message, _ := logData["message"].(string)
        timestamp, _ := logData["timestamp"].(string)
        userAgent, _ := logData["userAgent"].(string)

        switch logType </span>{
        case "client_log":<span class="cov8" title="1">
                log.Printf("[CLIENT-LOG] [%s] %s: %s - UA: %s", step, timestamp, message, userAgent)</span>
        case "client_error":<span class="cov0" title="0">
                errorMsg, _ := logData["error"].(string)
                context, _ := logData["context"].(string)
                stack, _ := logData["stack"].(string)
                log.Printf("[CLIENT-ERROR] [%s] %s: %s - Context: %s - Stack: %s - UA: %s",
                        step, timestamp, errorMsg, context, stack, userAgent)</span>
        default:<span class="cov0" title="0">
                log.Printf("[CLIENT-UNKNOWN] %+v", logData)</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// loggingMiddleware adds request/response logging to API endpoints
func (s *Server) loggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                logWebRequest(r, "API_REQUEST_START")

                // Create a response writer wrapper to capture status code
                wrapper := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                next.ServeHTTP(wrapper, r)

                duration := time.Since(start)
                logPerformance("api_request", map[string]interface{}{
                        "endpoint": r.URL.Path,
                        "method":   r.Method,
                        "status":   wrapper.statusCode,
                        "duration": duration,
                })
        }</span>)
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// handleMetrics returns comprehensive performance metrics
func (s *Server) handleMetrics(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        stats := s.simulation.GetStatistics()

        metrics := map[string]interface{}{
                "simulation": stats,
                "server": map[string]interface{}{
                        "active_websocket_clients": len(s.clients),
                        "uptime_seconds":           time.Since(time.Now()).Seconds(), // Will be corrected with actual start time
                },
                "platforms": map[string]interface{}{
                        "total": stats.TotalPlatforms,
                        "by_type": map[string]interface{}{
                                "airborne": stats.AirbornePlatforms,
                                "maritime": stats.MaritimePlatforms,
                                "land":     stats.LandPlatforms,
                                "space":    stats.SpacePlatforms,
                        },
                },
                "timestamp": time.Now().Unix(),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logWebError("Metrics encoding", err)
                http.Error(w, "Error encoding metrics", http.StatusInternalServerError)
                return
        }</span>
}

// handleCreateScenario handles scenario creation requests
func (s *Server) handleCreateScenario(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                Name        string                   `json:"name"`
                Description string                   `json:"description"`
                Duration    int                      `json:"duration"`
                Platforms   []map[string]interface{} `json:"platforms"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid request format", http.StatusBadRequest)
                return
        }</span>

        // Create platforms from the request
        <span class="cov8" title="1">var platforms []*models.UniversalPlatform
        for _, platformConfig := range req.Platforms </span><span class="cov0" title="0">{
                platform, err := models.CreatePlatformFromConfig(platformConfig)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Failed to create platform: %v", err), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">platforms = append(platforms, platform)</span>
        }

        // Create scenario configuration
        <span class="cov8" title="1">scenario := map[string]interface{}{
                "name":        req.Name,
                "description": req.Description,
                "duration":    req.Duration,
                "platforms":   platforms,
                "created_at":  time.Now(),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "message":  "Scenario created successfully",
                "scenario": scenario,
        }); err != nil </span><span class="cov0" title="0">{
                logWebError("Scenario creation response encoding", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package sim

import (
        "fmt"
        "log"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
)

// isTestMode checks if we're running in test mode
func isTestMode() bool <span class="cov0" title="0">{
        return strings.Contains(os.Args[0], ".test") ||
                strings.HasSuffix(os.Args[0], "/test") ||
                os.Getenv("GO_TESTING") == "1"
}</span>

// logf is a conditional logger that respects test verbosity
func logf(format string, args ...interface{}) <span class="cov0" title="0">{
        if isTestMode() </span><span class="cov0" title="0">{
                // In test mode, suppress output to reduce noise
                return
        }</span> else<span class="cov0" title="0"> {
                // In production mode, always log
                fmt.Printf(format+"\n", args...)
        }</span>
}

// Enhanced logging for simulation debugging
func logSimulationStart(platformCount int, updateInterval time.Duration) <span class="cov0" title="0">{
        logf("[SIM-START] Starting simulation with %d platforms at %v update interval", platformCount, updateInterval)
}</span>

func logSimulationStop(reason string) <span class="cov0" title="0">{
        logf("[SIM-STOP] Simulation stopped: %s", reason)
}</span>

func logPlatformOperation(operation string, platformID string, details interface{}) <span class="cov0" title="0">{
        logf("[PLATFORM-OP] %s - ID: %s - Details: %+v", operation, platformID, details)
}</span>

func logSimulationPerformance(updateCount int, avgUpdateTime time.Duration, platformCount int) <span class="cov0" title="0">{
        logf("[SIM-PERF] Updates: %d, Avg Update Time: %v, Platforms: %d", updateCount, avgUpdateTime, platformCount)
}</span>

func logSimulationError(context string, err error, platformID string) <span class="cov0" title="0">{
        logf("[SIM-ERROR] Context: %s, Platform: %s, Error: %v", context, platformID, err)
}</span>

// Engine represents the main simulation engine that orchestrates all platform movement
type Engine struct {
        config         *config.Config
        physics        *PhysicsEngine
        platforms      map[string]models.Platform
        platformsMux   sync.RWMutex
        isRunning      bool
        runningMux     sync.RWMutex
        updateTicker   *time.Ticker
        stopCh         chan struct{}
        simulationTime float64
        timeMux        sync.RWMutex
        updateInterval time.Duration

        // Performance tracking
        updateCount     int64
        totalUpdateTime time.Duration
        lastPerfLog     time.Time
}

// NewEngine creates a new simulation engine
func NewEngine(cfg *config.Config) *Engine <span class="cov0" title="0">{
        updateInterval := time.Second / 60 // 60 FPS default
        if cfg != nil &amp;&amp; cfg.Simulation.UpdateInterval != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(cfg.Simulation.UpdateInterval); err == nil </span><span class="cov0" title="0">{
                        updateInterval = parsed
                }</span>
        }

        <span class="cov0" title="0">return &amp;Engine{
                config:         cfg,
                physics:        NewPhysicsEngine(),
                platforms:      make(map[string]models.Platform),
                stopCh:         make(chan struct{}),
                updateInterval: updateInterval,
        }</span>
}

// Start begins the simulation loop
func (e *Engine) Start() error <span class="cov0" title="0">{
        e.runningMux.Lock()
        defer e.runningMux.Unlock()

        if e.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("simulation is already running")
        }</span>

        <span class="cov0" title="0">e.isRunning = true
        e.stopCh = make(chan struct{})
        e.updateTicker = time.NewTicker(e.updateInterval)

        // Start the simulation loop in a goroutine
        go e.simulationLoop()

        logSimulationStart(len(e.platforms), e.updateInterval)
        return nil</span>
}

// Stop halts the simulation
func (e *Engine) Stop() <span class="cov0" title="0">{
        e.runningMux.Lock()
        defer e.runningMux.Unlock()

        if !e.isRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">e.isRunning = false
        if e.updateTicker != nil </span><span class="cov0" title="0">{
                e.updateTicker.Stop()
        }</span>
        <span class="cov0" title="0">close(e.stopCh)

        logSimulationStop("User requested stop")</span>
}

// Reset resets the simulation to initial state
func (e *Engine) Reset() error <span class="cov0" title="0">{
        wasRunning := e.IsRunning()
        if wasRunning </span><span class="cov0" title="0">{
                e.Stop()
        }</span>

        <span class="cov0" title="0">e.timeMux.Lock()
        e.simulationTime = 0
        e.timeMux.Unlock()

        // Reset all platforms to their initial positions
        e.platformsMux.Lock()
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        universalPlatform.State.Position = universalPlatform.Config.StartPosition
                        universalPlatform.State.Speed = 0
                        universalPlatform.State.Heading = 0
                        universalPlatform.State.Velocity = models.Velocity{}
                        universalPlatform.MissionTime = 0
                        universalPlatform.State.LastUpdated = time.Now()
                }</span>
        }
        <span class="cov0" title="0">e.platformsMux.Unlock()

        if wasRunning </span><span class="cov0" title="0">{
                return e.Start()
        }</span>

        <span class="cov0" title="0">logf("Simulation reset")
        return nil</span>
}

// IsRunning returns whether the simulation is currently running
func (e *Engine) IsRunning() bool <span class="cov0" title="0">{
        e.runningMux.RLock()
        defer e.runningMux.RUnlock()
        return e.isRunning
}</span>

// GetSimulationTime returns the current simulation time in seconds
func (e *Engine) GetSimulationTime() float64 <span class="cov0" title="0">{
        e.timeMux.RLock()
        defer e.timeMux.RUnlock()
        return e.simulationTime
}</span>

// AddPlatform adds a platform to the simulation
func (e *Engine) AddPlatform(platform models.Platform) error <span class="cov0" title="0">{
        e.platformsMux.Lock()
        defer e.platformsMux.Unlock()

        id := platform.GetID()
        if _, exists := e.platforms[id]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("platform with ID %s already exists", id)
        }</span>

        <span class="cov0" title="0">e.platforms[id] = platform
        logPlatformOperation("ADD", id, platform)
        return nil</span>
}

// RemovePlatform removes a platform from the simulation
func (e *Engine) RemovePlatform(id string) error <span class="cov0" title="0">{
        e.platformsMux.Lock()
        defer e.platformsMux.Unlock()

        if _, exists := e.platforms[id]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("platform with ID %s not found", id)
        }</span>

        <span class="cov0" title="0">delete(e.platforms, id)
        logPlatformOperation("REMOVE", id, nil)
        return nil</span>
}

// GetPlatform returns a platform by ID
func (e *Engine) GetPlatform(id string) (models.Platform, error) <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        platform, exists := e.platforms[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("platform with ID %s not found", id)
        }</span>

        <span class="cov0" title="0">return platform, nil</span>
}

// GetAllPlatforms returns all platforms in the simulation
func (e *Engine) GetAllPlatforms() []models.Platform <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        platforms := make([]models.Platform, 0, len(e.platforms))
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>

        <span class="cov0" title="0">return platforms</span>
}

// LoadPlatformsFromConfig loads platforms from configuration
func (e *Engine) LoadPlatformsFromConfig() error <span class="cov0" title="0">{
        if e.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration provided")
        }</span>

        // This would load platforms from the configuration
        // For now, we'll create some example platforms
        <span class="cov0" title="0">if err := e.createExamplePlatforms(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example platforms: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createExamplePlatforms creates some example platforms for testing
func (e *Engine) createExamplePlatforms() error <span class="cov0" title="0">{
        // Create example aircraft
        boeing737 := models.NewBoeing737_800Universal(
                "UA123",
                "United 123",
                models.Position{Latitude: 40.7128, Longitude: -74.0060, Altitude: 10000}, // NYC
        )
        if err := boeing737.SetDestination(models.Position{Latitude: 34.0522, Longitude: -118.2437, Altitude: 10000}); err != nil </span><span class="cov0" title="0">{
                logf("Error setting Boeing 737 destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(boeing737); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example ship
        <span class="cov0" title="0">destroyer := models.NewArleighBurkeDestroyerUniversal(
                "DDG-89",
                "Mustin",
                models.Position{Latitude: 36.8485, Longitude: -76.2951, Altitude: 0}, // Norfolk, VA
        )
        if err := destroyer.SetDestination(models.Position{Latitude: 25.7617, Longitude: -80.1918, Altitude: 0}); err != nil </span><span class="cov0" title="0">{
                logf("Error setting destroyer destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(destroyer); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example tank
        <span class="cov0" title="0">tank := models.NewM1A2AbramsUniversal(
                "ARMOR-01",
                "Alpha Company",
                models.Position{Latitude: 31.8720, Longitude: -106.3744, Altitude: 1200}, // El Paso, TX
        )
        if err := tank.SetDestination(models.Position{Latitude: 31.8800, Longitude: -106.3600, Altitude: 1250}); err != nil </span><span class="cov0" title="0">{
                logf("Error setting tank destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(tank); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example satellite
        <span class="cov0" title="0">satellite := models.NewStarlinkSatelliteUniversal(
                "STARLINK-1234",
                "1234",
                models.Position{Latitude: 0, Longitude: 0, Altitude: 550000},
        )

        if err := e.AddPlatform(satellite); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logf("Created %d example platforms", len(e.platforms))
        return nil</span>
}

// Update performs a single simulation step
func (e *Engine) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        if !e.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("simulation is not running")
        }</span>

        <span class="cov0" title="0">e.platformsMux.RLock()
        platforms := make([]models.Platform, 0, len(e.platforms))
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>
        <span class="cov0" title="0">e.platformsMux.RUnlock()

        // Update all platforms using physics engine
        for _, platform := range platforms </span><span class="cov0" title="0">{
                if err := e.physics.CalculateMovement(platform, deltaTime); err != nil </span><span class="cov0" title="0">{
                        logf("Error updating platform %s: %v", platform.GetID(), err)
                }</span>
        }

        // Update simulation time
        <span class="cov0" title="0">e.timeMux.Lock()
        e.simulationTime += deltaTime.Seconds()
        e.timeMux.Unlock()

        // Performance tracking
        e.updateCount++
        e.totalUpdateTime += deltaTime
        if time.Since(e.lastPerfLog) &gt; time.Second </span><span class="cov0" title="0">{
                avgUpdateTime := e.totalUpdateTime / time.Duration(e.updateCount)
                logSimulationPerformance(int(e.updateCount), avgUpdateTime, len(e.platforms))
                e.lastPerfLog = time.Now()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// simulationLoop runs the main simulation update loop
func (e *Engine) simulationLoop() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Simulation loop panic: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">lastUpdate := time.Now()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.stopCh:<span class="cov0" title="0">
                        return</span>
                case currentTime := &lt;-e.updateTicker.C:<span class="cov0" title="0">
                        deltaTime := currentTime.Sub(lastUpdate)
                        lastUpdate = currentTime

                        if err := e.Update(deltaTime); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Simulation update error: %v", err)
                        }</span>
                }
        }
}

// SetUpdateInterval changes the simulation update frequency
func (e *Engine) SetUpdateInterval(interval time.Duration) <span class="cov0" title="0">{
        e.updateInterval = interval

        // If running, restart with new interval
        if e.IsRunning() </span><span class="cov0" title="0">{
                e.Stop()
                time.Sleep(100 * time.Millisecond) // Brief pause
                if err := e.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error restarting simulation with new interval: %v", err)
                }</span>
        }
}

// GetPlatformCount returns the number of platforms in the simulation
func (e *Engine) GetPlatformCount() int <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()
        return len(e.platforms)
}</span>

// GetPlatformsByType returns platforms filtered by type
func (e *Engine) GetPlatformsByType(platformType models.PlatformType) []models.Platform <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        var filtered []models.Platform
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        if universalPlatform.PlatformType == platformType </span><span class="cov0" title="0">{
                                filtered = append(filtered, platform)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// GetStatistics returns simulation statistics
func (e *Engine) GetStatistics() SimulationStatistics <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        stats := SimulationStatistics{
                TotalPlatforms: len(e.platforms),
                SimulationTime: e.GetSimulationTime(),
                IsRunning:      e.IsRunning(),
                UpdateInterval: e.updateInterval,
        }

        // Count by type
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        switch universalPlatform.PlatformType </span>{
                        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                                stats.AirbornePlatforms++</span>
                        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                                stats.MaritimePlatforms++</span>
                        case models.PlatformTypeLand:<span class="cov0" title="0">
                                stats.LandPlatforms++</span>
                        case models.PlatformTypeSpace:<span class="cov0" title="0">
                                stats.SpacePlatforms++</span>
                        }
                }
        }

        <span class="cov0" title="0">return stats</span>
}

// SimulationStatistics contains simulation metrics
type SimulationStatistics struct {
        TotalPlatforms    int           `json:"total_platforms"`
        AirbornePlatforms int           `json:"airborne_platforms"`
        MaritimePlatforms int           `json:"maritime_platforms"`
        LandPlatforms     int           `json:"land_platforms"`
        SpacePlatforms    int           `json:"space_platforms"`
        SimulationTime    float64       `json:"simulation_time"`
        IsRunning         bool          `json:"is_running"`
        UpdateInterval    time.Duration `json:"update_interval"`
}

// SetDestinationForPlatform sets a destination for a specific platform
func (e *Engine) SetDestinationForPlatform(id string, destination models.Position) error <span class="cov0" title="0">{
        platform, err := e.GetPlatform(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                if err := universalPlatform.SetDestination(destination); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set destination for platform %s: %w", id, err)
                }</span>
                <span class="cov0" title="0">logPlatformOperation("SET_DESTINATION", id, destination)
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("platform %s does not support destination setting", id)</span>
}

// GetPlatformStatus returns detailed status for a platform
func (e *Engine) GetPlatformStatus(id string) (*PlatformStatus, error) <span class="cov0" title="0">{
        platform, err := e.GetPlatform(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">universalPlatform, ok := platform.(*models.UniversalPlatform)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("platform %s is not a universal platform", id)
        }</span>

        <span class="cov0" title="0">status := &amp;PlatformStatus{
                ID:            universalPlatform.ID,
                Name:          universalPlatform.Config.Name,
                Type:          string(universalPlatform.PlatformType),
                Position:      universalPlatform.State.Position,
                Velocity:      universalPlatform.State.Velocity,
                Speed:         universalPlatform.State.Speed,
                Heading:       universalPlatform.State.Heading,
                FuelRemaining: universalPlatform.FuelRemaining,
                SystemStatus:  universalPlatform.SystemStatus,
                LastUpdated:   universalPlatform.State.LastUpdated,
        }

        if universalPlatform.Destination != nil </span><span class="cov0" title="0">{
                status.Destination = universalPlatform.Destination
                status.DistanceToDestination = e.physics.CalculateGreatCircleDistance(
                        universalPlatform.State.Position,
                        *universalPlatform.Destination,
                )
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// PlatformStatus represents detailed platform status information
type PlatformStatus struct {
        ID                    string              `json:"id"`
        Name                  string              `json:"name"`
        Type                  string              `json:"type"`
        Position              models.Position     `json:"position"`
        Destination           *models.Position    `json:"destination,omitempty"`
        DistanceToDestination float64             `json:"distance_to_destination,omitempty"`
        Velocity              models.Velocity     `json:"velocity"`
        Speed                 float64             `json:"speed"`
        Heading               float64             `json:"heading"`
        FuelRemaining         float64             `json:"fuel_remaining"`
        SystemStatus          models.SystemStatus `json:"system_status"`
        LastUpdated           time.Time           `json:"last_updated"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package sim

import (
        "math"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

// Platform type constants
const (
        PlatformTypeAircraft = "aircraft"
        PlatformTypeLand     = "land"
        PlatformTypeMaritime = "maritime"
        PlatformTypeSpace    = "space"
)

// PhysicsEngine handles realistic movement calculations for all platform types
type PhysicsEngine struct {
        // Environmental constants
        EarthRadius   float64 // meters
        GravityAccel  float64 // m/s¬≤
        AirDensity    float64 // kg/m¬≥ (sea level)
        SeaLevelPress float64 // Pa

        // Simulation parameters
        TimeStep      time.Duration
        EnableWeather bool
        EnableTerrain bool
}

// NewPhysicsEngine creates a new physics engine with realistic constants
func NewPhysicsEngine() *PhysicsEngine <span class="cov8" title="1">{
        return &amp;PhysicsEngine{
                EarthRadius:   6371000.0, // meters
                GravityAccel:  9.81,      // m/s¬≤
                AirDensity:    1.225,     // kg/m¬≥
                SeaLevelPress: 101325.0,  // Pa
                TimeStep:      time.Second,
                EnableWeather: false, // Start simple
                EnableTerrain: false, // Start simple
        }
}</span>

// CalculateMovement performs physics-based movement calculation for a platform
func (pe *PhysicsEngine) CalculateMovement(platform models.Platform, deltaTime time.Duration) error <span class="cov8" title="1">{
        // Try to cast to UniversalPlatform for enhanced physics
        if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov8" title="1">{
                return pe.updateUniversalPlatform(universalPlatform, deltaTime)
        }</span>

        // Fallback to platform's own Update method for all platforms
        <span class="cov0" title="0">return platform.Update(deltaTime)</span>
}

// updateUniversalPlatform handles movement for the new universal platform system
func (pe *PhysicsEngine) updateUniversalPlatform(platform *models.UniversalPlatform, deltaTime time.Duration) error <span class="cov8" title="1">{
        deltaSeconds := deltaTime.Seconds()

        // Skip movement if no destination
        if platform.Destination == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Calculate distance and bearing to destination
        <span class="cov8" title="1">distance := pe.CalculateGreatCircleDistance(
                platform.State.Position,
                *platform.Destination,
        )

        // Check if we've reached the destination
        arrivalThreshold := pe.getArrivalThreshold(platform.PlatformType)
        if distance &lt; arrivalThreshold </span><span class="cov0" title="0">{
                platform.State.Position = *platform.Destination
                platform.Destination = nil
                platform.State.Speed = 0
                return nil
        }</span>

        // Calculate desired movement vector
        <span class="cov8" title="1">bearing := pe.CalculateBearing(platform.State.Position, *platform.Destination)

        // Apply platform-specific physics
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov8" title="1">
                return pe.updateAircraftPhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeMaritime:<span class="cov8" title="1">
                return pe.updateMaritimePhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeLand:<span class="cov8" title="1">
                return pe.updateLandPhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                return pe.updateSpacePhysics(platform, deltaSeconds)</span>
        default:<span class="cov0" title="0">
                return pe.updateGenericPhysics(platform, bearing, distance, deltaSeconds)</span>
        }
}

// updateAircraftPhysics implements realistic aircraft movement
func (pe *PhysicsEngine) updateAircraftPhysics(platform *models.UniversalPlatform, bearing, _ /* distance */, deltaSeconds float64) error <span class="cov8" title="1">{
        // Get performance characteristics
        maxSpeed := platform.TypeDef.Performance.MaxSpeed
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed
        climbRate := platform.TypeDef.Performance.ClimbRate
        if climbRate == 0 </span><span class="cov0" title="0">{
                climbRate = 10.0 // Default climb rate
        }</span>

        // Calculate turning constraints
        <span class="cov8" title="1">turningRadius := platform.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                // Calculate based on speed and standard bank angle (30¬∞)
                bankAngle := 30.0 * math.Pi / 180.0
                turningRadius = (cruiseSpeed * cruiseSpeed) / (pe.GravityAccel * math.Tan(bankAngle))
        }</span>

        // Apply heading change with turning constraints
        <span class="cov8" title="1">newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                turningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Handle altitude changes
        altitudeDiff := platform.Destination.Altitude - platform.State.Position.Altitude
        if math.Abs(altitudeDiff) &gt; 10 </span><span class="cov8" title="1">{
                maxAltChange := climbRate * deltaSeconds
                if math.Abs(altitudeDiff) &lt;= maxAltChange </span><span class="cov0" title="0">{
                        platform.State.Position.Altitude = platform.Destination.Altitude
                }</span> else<span class="cov8" title="1"> if altitudeDiff &gt; 0 </span><span class="cov8" title="1">{
                        platform.State.Position.Altitude += maxAltChange
                }</span> else<span class="cov0" title="0"> {
                        platform.State.Position.Altitude -= maxAltChange
                }</span>
        }

        // Apply speed control with acceleration limits
        <span class="cov8" title="1">targetSpeed := math.Min(cruiseSpeed, maxSpeed)
        platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                targetSpeed,
                platform.TypeDef.Performance.Acceleration,
                deltaSeconds,
        )

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateMaritimePhysics implements realistic ship movement
func (pe *PhysicsEngine) updateMaritimePhysics(platform *models.UniversalPlatform, bearing, _ /* distance */, deltaSeconds float64) error <span class="cov8" title="1">{
        // Ships have different characteristics
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed

        // Ships have large turning radii
        turningRadius := platform.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius = platform.TypeDef.Physical.Length * 6 // 6x ship length
        }</span>

        // Apply heading change (ships turn slowly)
        <span class="cov8" title="1">newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                turningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Ships stay at sea level
        platform.State.Position.Altitude = 0

        // Apply acceleration (ships accelerate slowly)
        acceleration := platform.TypeDef.Performance.Acceleration
        if acceleration == 0 </span><span class="cov0" title="0">{
                acceleration = 0.3 // Default slow acceleration for ships
        }</span>

        <span class="cov8" title="1">platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                cruiseSpeed,
                acceleration,
                deltaSeconds,
        )

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateLandPhysics implements realistic land vehicle movement
func (pe *PhysicsEngine) updateLandPhysics(platform *models.UniversalPlatform, bearing, distance, deltaSeconds float64) error <span class="cov8" title="1">{
        // Land vehicles have terrain constraints
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed

        // Apply turning constraints
        newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                platform.TypeDef.Performance.TurningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Apply gradient constraints
        if pe.EnableTerrain </span><span class="cov0" title="0">{
                pe.applyGradientConstraints(platform, distance)
        }</span>

        // Apply acceleration
        <span class="cov8" title="1">platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                cruiseSpeed,
                platform.TypeDef.Performance.Acceleration,
                deltaSeconds,
        )

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateSpacePhysics implements orbital mechanics for satellites
func (pe *PhysicsEngine) updateSpacePhysics(platform *models.UniversalPlatform, deltaSeconds float64) error <span class="cov0" title="0">{
        // Space platforms have orbital characteristics
        orbitalVelocity := platform.TypeDef.Performance.OrbitalVelocity
        if orbitalVelocity == 0 </span><span class="cov0" title="0">{
                // Calculate orbital velocity based on altitude
                altitude := platform.State.Position.Altitude
                orbitalVelocity = math.Sqrt(pe.GravityAccel * pe.EarthRadius * pe.EarthRadius / (pe.EarthRadius + altitude))
        }</span>

        // Maintain orbital velocity
        <span class="cov0" title="0">platform.State.Speed = orbitalVelocity

        // Update position in orbit
        pe.updateOrbitalPosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateGenericPhysics provides basic movement for unknown platform types
func (pe *PhysicsEngine) updateGenericPhysics(platform *models.UniversalPlatform, bearing, _ /* distance */, deltaSeconds float64) error <span class="cov0" title="0">{
        // Basic movement
        platform.State.Heading = bearing
        platform.State.Speed = platform.TypeDef.Performance.CruiseSpeed

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil
}</span>

// Helper methods

func (pe *PhysicsEngine) getArrivalThreshold(platformType models.PlatformType) float64 <span class="cov8" title="1">{
        switch platformType </span>{
        case models.PlatformTypeAirborne:<span class="cov8" title="1">
                return 100.0</span> // 100 meters
        case models.PlatformTypeMaritime:<span class="cov8" title="1">
                return 50.0</span> // 50 meters
        case models.PlatformTypeLand:<span class="cov8" title="1">
                return 10.0</span> // 10 meters
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                return 1000.0</span> // 1 km for satellites
        default:<span class="cov0" title="0">
                return 50.0</span> // Default threshold
        }
}

func (pe *PhysicsEngine) applyTurningConstraints(currentHeading, targetHeading, speed, turningRadius, deltaTime float64) float64 <span class="cov8" title="1">{
        if turningRadius &lt;= 0 || speed &lt;= 0 </span><span class="cov0" title="0">{
                return targetHeading
        }</span>

        // Calculate heading difference
        <span class="cov8" title="1">headingDiff := targetHeading - currentHeading
        for headingDiff &gt; 180 </span><span class="cov0" title="0">{
                headingDiff -= 360
        }</span>
        <span class="cov8" title="1">for headingDiff &lt; -180 </span><span class="cov0" title="0">{
                headingDiff += 360
        }</span>

        // Calculate maximum turn rate
        <span class="cov8" title="1">maxTurnRate := speed / turningRadius * 180.0 / math.Pi // degrees per second
        maxTurnChange := maxTurnRate * deltaTime

        // Apply turn constraint
        if math.Abs(headingDiff) &lt;= maxTurnChange </span><span class="cov0" title="0">{
                return targetHeading
        }</span> else<span class="cov8" title="1"> if headingDiff &gt; 0 </span><span class="cov8" title="1">{
                return math.Mod(currentHeading+maxTurnChange, 360)
        }</span> else<span class="cov8" title="1"> {
                return math.Mod(currentHeading-maxTurnChange+360, 360)
        }</span>
}

func (pe *PhysicsEngine) applyAcceleration(currentSpeed, targetSpeed, acceleration, deltaTime float64) float64 <span class="cov8" title="1">{
        if acceleration &lt;= 0 </span><span class="cov0" title="0">{
                return targetSpeed
        }</span>

        <span class="cov8" title="1">speedDiff := targetSpeed - currentSpeed
        maxSpeedChange := acceleration * deltaTime

        if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov0" title="0">{
                return targetSpeed
        }</span> else<span class="cov8" title="1"> if speedDiff &gt; 0 </span><span class="cov8" title="1">{
                return currentSpeed + maxSpeedChange
        }</span> else<span class="cov0" title="0"> {
                return currentSpeed - maxSpeedChange
        }</span>
}

func (pe *PhysicsEngine) applyGradientConstraints(platform *models.UniversalPlatform, _ /* distance */ float64) <span class="cov0" title="0">{
        // Apply terrain gradient constraints for land vehicles
        maxGradient := platform.TypeDef.Performance.MaxGradient
        if maxGradient &gt; 0 </span>{<span class="cov0" title="0">
                // Implement gradient checking logic here
                // For now, this is a placeholder
        }</span>
}

func (pe *PhysicsEngine) updatePosition(state *models.PlatformState, deltaTime float64) <span class="cov8" title="1">{
        // Convert heading to radians
        headingRad := state.Heading * math.Pi / 180.0

        // Calculate distance moved
        distance := state.Speed * deltaTime

        // Calculate new position
        deltaLat := distance * math.Cos(headingRad) / pe.EarthRadius * 180.0 / math.Pi
        deltaLon := distance * math.Sin(headingRad) / pe.EarthRadius * 180.0 / math.Pi / math.Cos(state.Position.Latitude*math.Pi/180.0)

        state.Position.Latitude += deltaLat
        state.Position.Longitude += deltaLon

        // Update velocity components
        state.Velocity.North = state.Speed * math.Cos(headingRad)
        state.Velocity.East = state.Speed * math.Sin(headingRad)
}</span>

func (pe *PhysicsEngine) updateOrbitalPosition(state *models.PlatformState, deltaTime float64) <span class="cov0" title="0">{
        // Simplified orbital mechanics
        orbitalPeriod := 90.0 * 60.0 // 90 minutes in seconds
        angularVelocity := 2.0 * math.Pi / orbitalPeriod

        // Update orbital position
        currentAngle := angularVelocity * deltaTime

        // Move eastward along the equator (simplified)
        deltaLon := currentAngle * 180.0 / math.Pi
        state.Position.Longitude += deltaLon

        // Normalize longitude
        for state.Position.Longitude &gt; 180 </span><span class="cov0" title="0">{
                state.Position.Longitude -= 360
        }</span>
        <span class="cov0" title="0">for state.Position.Longitude &lt; -180 </span><span class="cov0" title="0">{
                state.Position.Longitude += 360
        }</span>
}

// CalculateGreatCircleDistance calculates the distance between two positions
func (pe *PhysicsEngine) CalculateGreatCircleDistance(pos1, pos2 models.Position) float64 <span class="cov8" title="1">{
        // Haversine formula
        lat1 := pos1.Latitude * math.Pi / 180.0
        lat2 := pos2.Latitude * math.Pi / 180.0
        deltaLat := (pos2.Latitude - pos1.Latitude) * math.Pi / 180.0
        deltaLon := (pos2.Longitude - pos1.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        distance := pe.EarthRadius * c

        // Add altitude difference
        altDiff := pos2.Altitude - pos1.Altitude
        return math.Sqrt(distance*distance + altDiff*altDiff)
}</span>

// CalculateBearing calculates the bearing from one position to another
func (pe *PhysicsEngine) CalculateBearing(from, to models.Position) float64 <span class="cov8" title="1">{
        lat1 := from.Latitude * math.Pi / 180.0
        lat2 := to.Latitude * math.Pi / 180.0
        deltaLon := (to.Longitude - from.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        return math.Mod(bearing+360, 360)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package testutil

import (
        "log/slog"
        "os"
        "testing"
)

// SetupTestLogging configures a silent logger for tests to reduce verbose output
func SetupTestLogging(t *testing.T) *slog.Logger <span class="cov0" title="0">{
        // Create a logger that writes to a null handler (discards all output)
        logger := slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                Level: slog.LevelError, // Only show errors during tests
        }))

        // Set as default logger
        slog.SetDefault(logger)

        return logger
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
