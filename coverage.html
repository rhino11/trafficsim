
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>simrunner: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rhino11/trafficsim/cmd/simrunner/main.go (0.0%)</option>
				
				<option value="file1">github.com/rhino11/trafficsim/debug_attitude.go (0.0%)</option>
				
				<option value="file2">github.com/rhino11/trafficsim/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/rhino11/trafficsim/internal/config/factory.go (0.0%)</option>
				
				<option value="file4">github.com/rhino11/trafficsim/internal/models/airborne.go (76.0%)</option>
				
				<option value="file5">github.com/rhino11/trafficsim/internal/models/factory.go (91.7%)</option>
				
				<option value="file6">github.com/rhino11/trafficsim/internal/models/land.go (0.0%)</option>
				
				<option value="file7">github.com/rhino11/trafficsim/internal/models/maritime.go (0.0%)</option>
				
				<option value="file8">github.com/rhino11/trafficsim/internal/models/platform.go (47.3%)</option>
				
				<option value="file9">github.com/rhino11/trafficsim/internal/models/space.go (0.0%)</option>
				
				<option value="file10">github.com/rhino11/trafficsim/internal/server/server.go (0.0%)</option>
				
				<option value="file11">github.com/rhino11/trafficsim/internal/sim/engine.go (0.0%)</option>
				
				<option value="file12">github.com/rhino11/trafficsim/internal/sim/physics.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
        "github.com/rhino11/trafficsim/internal/server"
        "github.com/rhino11/trafficsim/internal/sim"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                configPath = flag.String("config", "data/config.yaml", "Path to configuration file")
                webMode    = flag.Bool("web", false, "Run in web server mode")
                port       = flag.String("port", "8080", "Port for web server")
        )
        flag.Parse()

        fmt.Println("Global Traffic Simulator - Configuration-Driven Demo")
        fmt.Println("====================================================")

        // Load configuration
        fmt.Printf("Loading configuration from: %s\n", *configPath)
        cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Create simulation engine
        <span class="cov0" title="0">engine := sim.NewEngine(cfg)

        if *webMode </span><span class="cov0" title="0">{
                // Run web server mode
                fmt.Printf("Starting web server on port %s...\n", *port)

                // Load platforms from configuration (needed for web mode)
                fmt.Println("Loading platforms for web simulation...")
                if err := engine.LoadPlatformsFromConfig(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load platforms: %v", err)
                }</span>

                <span class="cov0" title="0">platforms := engine.GetAllPlatforms()
                fmt.Printf("Loaded %d platforms for web interface\n", len(platforms))

                // Start simulation engine for web mode
                if err := engine.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start simulation: %v", err)
                }</span>

                // Create server
                <span class="cov0" title="0">srv := server.NewServer(cfg, engine)

                // Start server
                if err := srv.Start(*port); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Run command-line mode
                runCLISimulation(engine, cfg)
        }</span>
}

func runCLISimulation(engine *sim.Engine, cfg *config.Config) <span class="cov0" title="0">{
        fmt.Println("Starting traffic simulation...")

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                fmt.Println("\nReceived interrupt signal, shutting down...")
                cancel()
        }</span>()

        // Load platforms from configuration or create examples
        <span class="cov0" title="0">if err := engine.LoadPlatformsFromConfig(); err != nil </span><span class="cov0" title="0">{
                cancel() // Cancel context before fatal exit
                log.Fatalf("Failed to load platforms: %v", err)
        }</span>

        <span class="cov0" title="0">platforms := engine.GetAllPlatforms()
        fmt.Printf("Loaded %d platforms\n", len(platforms))

        // Display platform information
        for _, platform := range platforms </span><span class="cov0" title="0">{
                displayPlatformInfo(platform)
        }</span>

        // Start simulation
        <span class="cov0" title="0">if err := engine.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start simulation: %v", err)
        }</span>

        // Run simulation monitoring loop
        <span class="cov0" title="0">ticker := time.NewTicker(1 * time.Second) // Status updates every second
        defer ticker.Stop()

        startTime := time.Now()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        fmt.Println("Simulation stopped")
                        engine.Stop()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Display status
                        elapsed := time.Since(startTime)
                        simTime := engine.GetSimulationTime()
                        platforms := engine.GetAllPlatforms()

                        fmt.Printf("Real time: %.1fs, Sim time: %.1fs, Platforms: %d\n",
                                elapsed.Seconds(), simTime, len(platforms))

                        // Display platform positions
                        if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                                displayPlatformStatus(platforms)
                        }</span>
                }
        }
}

func displayPlatformInfo(platform models.Platform) <span class="cov0" title="0">{
        state := platform.GetState()
        fmt.Printf("  %s (%s) - %s\n", platform.GetName(), platform.GetClass(), platform.GetCallSign())
        fmt.Printf("    Type: %s | Position: %.4f,%.4f @ %.0fm\n",
                platform.GetType(), state.Position.Latitude, state.Position.Longitude, state.Position.Altitude)
        fmt.Printf("    Specs: L=%.1fm, W=%.1fm, H=%.1fm, Mass=%.0fkg\n",
                platform.GetLength(), platform.GetWidth(), platform.GetHeight(), platform.GetMass())
        fmt.Printf("    Performance: Max=%.1fm/s (%.1fkts), Max Alt=%.0fm\n",
                platform.GetMaxSpeed(), platform.GetMaxSpeed()*1.944, platform.GetMaxAltitude())
}</span>

func displayPlatformStatus(platforms []models.Platform) <span class="cov0" title="0">{
        for _, platform := range platforms </span><span class="cov0" title="0">{
                state := platform.GetState()
                fmt.Printf("  %s: Lat=%.4f, Lon=%.4f, Alt=%.0fm, Speed=%.1fm/s, Hdg=%.1f°\n",
                        platform.GetCallSign(),
                        state.Position.Latitude,
                        state.Position.Longitude,
                        state.Position.Altitude,
                        state.Speed,
                        state.Heading,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "math"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

func main() <span class="cov0" title="0">{
        startPos := models.Position{Latitude: 40.0, Longitude: -74.0, Altitude: 10000}
        dest := models.Position{Latitude: 40.1, Longitude: -74.0, Altitude: 10000}

        aircraft := models.NewBoeing737_800("TEST-004", "TEST101", startPos)
        if err := aircraft.SetDestination(dest); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error setting destination: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">aircraft.UniversalPlatform.State.Speed = 200

        fmt.Printf("Initial heading: %.1f°\n", aircraft.UniversalPlatform.State.Heading)

        // Calculate bearing manually to debug
        lat1 := startPos.Latitude * math.Pi / 180.0
        lat2 := dest.Latitude * math.Pi / 180.0
        deltaLon := (dest.Longitude - startPos.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        for bearing &lt; 0 </span><span class="cov0" title="0">{
                bearing += 360
        }</span>

        <span class="cov0" title="0">fmt.Printf("Bearing to destination: %.1f°\n", bearing)

        headingError := bearing - aircraft.UniversalPlatform.State.Heading
        fmt.Printf("Heading error: %.1f°\n", headingError)

        fmt.Printf("Initial roll: %.3f°\n", aircraft.UniversalPlatform.State.Physics.Attitude.Roll)

        // Test what happens during a full Update call
        if err := aircraft.Update(time.Second); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating aircraft: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("Roll after Update: %.3f°\n", aircraft.UniversalPlatform.State.Physics.Attitude.Roll)
        fmt.Printf("Heading after Update: %.1f°\n", aircraft.UniversalPlatform.State.Heading)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config represents the main configuration structure
type Config struct {
        Simulation SimulationConfig `yaml:"simulation"`
        Platforms  PlatformRegistry `yaml:"platforms"`
        Server     ServerConfig     `yaml:"server"`
        Output     OutputConfig     `yaml:"output"`
}

// SimulationConfig contains simulation runtime parameters
type SimulationConfig struct {
        UpdateInterval string       `yaml:"update_interval" default:"1s"`
        TimeScale      float64      `yaml:"time_scale" default:"1.0"`
        MaxDuration    string       `yaml:"max_duration" default:"1h"`
        StartTime      string       `yaml:"start_time,omitempty"`
        BoundingBox    *BoundingBox `yaml:"bounding_box,omitempty"`
}

// BoundingBox defines simulation area limits
type BoundingBox struct {
        North float64 `yaml:"north"`
        South float64 `yaml:"south"`
        East  float64 `yaml:"east"`
        West  float64 `yaml:"west"`
}

// ServerConfig contains web server settings
type ServerConfig struct {
        Port    int    `yaml:"port" default:"8080"`
        Host    string `yaml:"host" default:"localhost"`
        WebRoot string `yaml:"web_root" default:"web"`
}

// OutputConfig contains CoT and other output settings
type OutputConfig struct {
        CoT     CoTConfig     `yaml:"cot"`
        Logging LoggingConfig `yaml:"logging"`
}

// CoTConfig contains Cursor-on-Target output settings
type CoTConfig struct {
        Enabled    bool   `yaml:"enabled" default:"true"`
        Endpoint   string `yaml:"endpoint" default:"udp://239.2.3.1:6969"`
        UpdateRate string `yaml:"update_rate" default:"5s"`
}

// LoggingConfig contains logging settings
type LoggingConfig struct {
        Level  string `yaml:"level" default:"info"`
        Format string `yaml:"format" default:"text"`
        File   string `yaml:"file,omitempty"`
}

// PlatformRegistry contains all platform type definitions and scenarios
type PlatformRegistry struct {
        // Platform type definitions (the "database tables")
        AirborneTypes PlatformTypeDefinitions `yaml:"airborne_types"`
        MaritimeTypes PlatformTypeDefinitions `yaml:"maritime_types"`
        LandTypes     PlatformTypeDefinitions `yaml:"land_types"`
        SpaceTypes    PlatformTypeDefinitions `yaml:"space_types"`

        // Scenario definitions (instances to create)
        Scenarios map[string]ScenarioConfig `yaml:"scenarios"`
}

// PlatformTypeDefinitions represents a collection of platform type definitions
type PlatformTypeDefinitions map[string]PlatformTypeDefinition

// PlatformTypeDefinition defines a real-world platform type with all its characteristics
type PlatformTypeDefinition struct {
        // Basic identification
        Name     string `yaml:"name"`
        Class    string `yaml:"class"`
        Type     string `yaml:"type"`     // airborne, maritime, land, space
        Category string `yaml:"category"` // commercial, military, civilian

        // Performance characteristics
        MaxSpeed       float64 `yaml:"max_speed"`                 // m/s
        CruiseSpeed    float64 `yaml:"cruise_speed"`              // m/s
        MaxAltitude    float64 `yaml:"max_altitude"`              // meters
        ServiceCeiling float64 `yaml:"service_ceiling,omitempty"` // meters

        // Physical characteristics
        Length float64 `yaml:"length"` // meters
        Width  float64 `yaml:"width"`  // meters (wingspan for aircraft, beam for ships)
        Height float64 `yaml:"height"` // meters
        Mass   float64 `yaml:"mass"`   // kg

        // Type-specific characteristics
        Draft        float64 `yaml:"draft,omitempty"`         // meters (ships)
        Displacement float64 `yaml:"displacement,omitempty"`  // tonnes (ships)
        FuelCapacity float64 `yaml:"fuel_capacity,omitempty"` // liters (land/air)
        Range        float64 `yaml:"range,omitempty"`         // meters
        MaxGradient  float64 `yaml:"max_gradient,omitempty"`  // degrees (land)

        // Orbital characteristics (space)
        OrbitalPeriod float64 `yaml:"orbital_period,omitempty"` // seconds
        Apogee        float64 `yaml:"apogee,omitempty"`         // meters
        Perigee       float64 `yaml:"perigee,omitempty"`        // meters
        Inclination   float64 `yaml:"inclination,omitempty"`    // degrees

        // Call sign patterns
        CallSignPrefix string `yaml:"callsign_prefix,omitempty"`
        CallSignFormat string `yaml:"callsign_format,omitempty"` // e.g., "{prefix}{id}"
}

// ScenarioConfig defines a simulation scenario with platform instances
type ScenarioConfig struct {
        Name        string             `yaml:"name"`
        Description string             `yaml:"description,omitempty"`
        Duration    string             `yaml:"duration,omitempty"`
        Instances   []PlatformInstance `yaml:"instances"`
}

// PlatformInstance defines a specific platform instance in a scenario
type PlatformInstance struct {
        ID          string          `yaml:"id"`
        TypeID      string          `yaml:"type_id"`            // References PlatformTypeDefinition
        Name        string          `yaml:"name"`               // Display name/flight number
        CallSign    string          `yaml:"callsign,omitempty"` // Override callsign
        StartPos    Position        `yaml:"start_position"`
        Destination *Position       `yaml:"destination,omitempty"`
        Route       []Position      `yaml:"route,omitempty"`
        Behavior    *BehaviorConfig `yaml:"behavior,omitempty"`
}

// Position represents a 3D position
type Position struct {
        Latitude  float64 `yaml:"latitude"`
        Longitude float64 `yaml:"longitude"`
        Altitude  float64 `yaml:"altitude"`
}

// BehaviorConfig defines platform-specific behavior parameters
type BehaviorConfig struct {
        Patrol        *PatrolBehavior     `yaml:"patrol,omitempty"`
        CircuitFlight *CircuitBehavior    `yaml:"circuit,omitempty"`
        RandomWalk    *RandomWalkBehavior `yaml:"random_walk,omitempty"`
}

// PatrolBehavior defines patrol pattern behavior
type PatrolBehavior struct {
        Pattern   string     `yaml:"pattern"` // "line", "box", "circle"
        Points    []Position `yaml:"points"`
        Speed     float64    `yaml:"speed,omitempty"`
        LoopCount int        `yaml:"loop_count,omitempty"` // -1 for infinite
}

// CircuitBehavior defines circuit flight pattern
type CircuitBehavior struct {
        Center Position `yaml:"center"`
        Radius float64  `yaml:"radius"`
        Speed  float64  `yaml:"speed,omitempty"`
}

// RandomWalkBehavior defines random movement
type RandomWalkBehavior struct {
        Area        BoundingBox `yaml:"area"`
        MaxDistance float64     `yaml:"max_distance"`
        Speed       float64     `yaml:"speed,omitempty"`
}

// LoadConfig loads configuration from a YAML file
func LoadConfig(filename string) (*Config, error) <span class="cov0" title="0">{
        // Validate filename to prevent path traversal attacks
        if filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("absolute paths not allowed for config files")
        }</span>

        // Clean the path to prevent directory traversal
        <span class="cov0" title="0">cleanPath := filepath.Clean(filename)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path traversal not allowed in config filename")
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov0" title="0">if err := applyDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply defaults: %w", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// applyDefaults applies default values to configuration
func applyDefaults(config *Config) error <span class="cov0" title="0">{
        // Apply simulation defaults
        if config.Simulation.UpdateInterval == "" </span><span class="cov0" title="0">{
                config.Simulation.UpdateInterval = "1s"
        }</span>
        <span class="cov0" title="0">if config.Simulation.TimeScale == 0 </span><span class="cov0" title="0">{
                config.Simulation.TimeScale = 1.0
        }</span>
        <span class="cov0" title="0">if config.Simulation.MaxDuration == "" </span><span class="cov0" title="0">{
                config.Simulation.MaxDuration = "1h"
        }</span>

        // Apply server defaults
        <span class="cov0" title="0">if config.Server.Port == 0 </span><span class="cov0" title="0">{
                config.Server.Port = 8080
        }</span>
        <span class="cov0" title="0">if config.Server.Host == "" </span><span class="cov0" title="0">{
                config.Server.Host = "localhost"
        }</span>
        <span class="cov0" title="0">if config.Server.WebRoot == "" </span><span class="cov0" title="0">{
                config.Server.WebRoot = "web"
        }</span>

        // Apply output defaults
        <span class="cov0" title="0">if config.Output.CoT.UpdateRate == "" </span><span class="cov0" title="0">{
                config.Output.CoT.UpdateRate = "5s"
        }</span>
        <span class="cov0" title="0">if config.Output.CoT.Endpoint == "" </span><span class="cov0" title="0">{
                config.Output.CoT.Endpoint = "udp://239.2.3.1:6969"
        }</span>
        <span class="cov0" title="0">if config.Output.Logging.Level == "" </span><span class="cov0" title="0">{
                config.Output.Logging.Level = "info"
        }</span>
        <span class="cov0" title="0">if config.Output.Logging.Format == "" </span><span class="cov0" title="0">{
                config.Output.Logging.Format = "text"
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateConfig validates the configuration
func validateConfig(config *Config) error <span class="cov0" title="0">{
        // Validate server port
        if config.Server.Port &lt; 1 || config.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server port: %d", config.Server.Port)
        }</span>

        // Validate time scale
        <span class="cov0" title="0">if config.Simulation.TimeScale &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid time scale: %f", config.Simulation.TimeScale)
        }</span>

        // Validate platform type references in scenarios
        <span class="cov0" title="0">for scenarioName, scenario := range config.Platforms.Scenarios </span><span class="cov0" title="0">{
                for i, instance := range scenario.Instances </span><span class="cov0" title="0">{
                        if !config.Platforms.HasType(instance.TypeID) </span><span class="cov0" title="0">{
                                return fmt.Errorf("scenario %s, instance %d: unknown platform type %s",
                                        scenarioName, i, instance.TypeID)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// HasType checks if a platform type exists in the registry
func (pr *PlatformRegistry) HasType(typeID string) bool <span class="cov0" title="0">{
        if _, exists := pr.AirborneTypes[typeID]; exists </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, exists := pr.MaritimeTypes[typeID]; exists </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, exists := pr.LandTypes[typeID]; exists </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, exists := pr.SpaceTypes[typeID]; exists </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetType retrieves a platform type definition by ID
func (pr *PlatformRegistry) GetType(typeID string) (*PlatformTypeDefinition, error) <span class="cov0" title="0">{
        if def, exists := pr.AirborneTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov0" title="0">if def, exists := pr.MaritimeTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov0" title="0">if def, exists := pr.LandTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov0" title="0">if def, exists := pr.SpaceTypes[typeID]; exists </span><span class="cov0" title="0">{
                return &amp;def, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("platform type not found: %s", typeID)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

// PlatformFactory creates platform instances from configuration data
type PlatformFactory struct {
        registry *PlatformRegistry
}

// NewPlatformFactory creates a new platform factory
func NewPlatformFactory(registry *PlatformRegistry) *PlatformFactory <span class="cov0" title="0">{
        return &amp;PlatformFactory{
                registry: registry,
        }
}</span>

// CreatePlatform creates a universal platform instance from configuration
func (f *PlatformFactory) CreatePlatform(instance PlatformInstance) (models.Platform, error) <span class="cov0" title="0">{
        // Get the platform type definition
        typeDef, err := f.registry.GetType(instance.TypeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get platform type %s: %w", instance.TypeID, err)
        }</span>

        // Convert config position to models position
        <span class="cov0" title="0">startPos := models.Position{
                Latitude:  instance.StartPos.Latitude,
                Longitude: instance.StartPos.Longitude,
                Altitude:  instance.StartPos.Altitude,
        }

        // Generate call sign if not provided
        callSign := instance.CallSign
        if callSign == "" </span><span class="cov0" title="0">{
                callSign = f.generateCallSign(typeDef, instance.ID)
        }</span>

        // Determine platform type from configuration
        <span class="cov0" title="0">platformType := f.determinePlatformType(typeDef.Type)

        // Convert PlatformTypeDefinition to models.PlatformTypeDefinition
        modelTypeDef := f.convertToModelTypeDefinition(typeDef)

        // Create platform configuration
        platformConfig := &amp;models.PlatformConfiguration{
                ID:            instance.ID,
                Type:          typeDef.Type,
                Name:          instance.Name,
                StartPosition: startPos,
                Mission: models.MissionConfiguration{
                        Type:       "standard",
                        Parameters: make(map[string]interface{}),
                },
        }

        // Create universal platform
        platform := &amp;models.UniversalPlatform{
                ID:           instance.ID,
                PlatformType: platformType,
                TypeDef:      modelTypeDef,
                Config:       platformConfig,
                CallSign:     callSign,
                State: models.PlatformState{
                        ID:          instance.ID,
                        Position:    startPos,
                        Velocity:    models.Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                FuelRemaining: modelTypeDef.Physical.FuelCapacity,
                MissionTime:   0,
        }

        return platform, nil</span>
}

// CreateScenario creates all platforms for a given scenario - only loads specified platforms
func (f *PlatformFactory) CreateScenario(scenarioName string) ([]models.Platform, error) <span class="cov0" title="0">{
        scenario, exists := f.registry.Scenarios[scenarioName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scenario not found: %s", scenarioName)
        }</span>

        <span class="cov0" title="0">var platforms []models.Platform

        // Only create platforms that are explicitly defined in the scenario
        for _, instance := range scenario.Instances </span><span class="cov0" title="0">{
                // Verify the platform type exists in configuration
                if !f.registry.HasType(instance.TypeID) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("platform type %s not found in configuration for instance %s",
                                instance.TypeID, instance.ID)
                }</span>

                <span class="cov0" title="0">platform, err := f.CreatePlatform(instance)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create platform %s: %w", instance.ID, err)
                }</span>

                // Set destination if specified
                <span class="cov0" title="0">if instance.Destination != nil </span><span class="cov0" title="0">{
                        dest := models.Position{
                                Latitude:  instance.Destination.Latitude,
                                Longitude: instance.Destination.Longitude,
                                Altitude:  instance.Destination.Altitude,
                        }
                        if err := platform.SetDestination(dest); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to set destination for %s: %w", instance.ID, err)
                        }</span>
                }

                <span class="cov0" title="0">platforms = append(platforms, platform)</span>
        }

        <span class="cov0" title="0">return platforms, nil</span>
}

// GetAvailablePlatformTypes returns only the platform types that are actually configured
func (f *PlatformFactory) GetAvailablePlatformTypes() map[string][]string <span class="cov0" title="0">{
        available := make(map[string][]string)

        // Only include platform types that are defined in the configuration
        if len(f.registry.AirborneTypes) &gt; 0 </span><span class="cov0" title="0">{
                var airborneTypes []string
                for typeID := range f.registry.AirborneTypes </span><span class="cov0" title="0">{
                        airborneTypes = append(airborneTypes, typeID)
                }</span>
                <span class="cov0" title="0">available["airborne"] = airborneTypes</span>
        }

        <span class="cov0" title="0">if len(f.registry.MaritimeTypes) &gt; 0 </span><span class="cov0" title="0">{
                var maritimeTypes []string
                for typeID := range f.registry.MaritimeTypes </span><span class="cov0" title="0">{
                        maritimeTypes = append(maritimeTypes, typeID)
                }</span>
                <span class="cov0" title="0">available["maritime"] = maritimeTypes</span>
        }

        <span class="cov0" title="0">if len(f.registry.LandTypes) &gt; 0 </span><span class="cov0" title="0">{
                var landTypes []string
                for typeID := range f.registry.LandTypes </span><span class="cov0" title="0">{
                        landTypes = append(landTypes, typeID)
                }</span>
                <span class="cov0" title="0">available["land"] = landTypes</span>
        }

        <span class="cov0" title="0">if len(f.registry.SpaceTypes) &gt; 0 </span><span class="cov0" title="0">{
                var spaceTypes []string
                for typeID := range f.registry.SpaceTypes </span><span class="cov0" title="0">{
                        spaceTypes = append(spaceTypes, typeID)
                }</span>
                <span class="cov0" title="0">available["space"] = spaceTypes</span>
        }

        <span class="cov0" title="0">return available</span>
}

// ValidateScenario validates that all platforms in a scenario reference valid types
func (f *PlatformFactory) ValidateScenario(scenarioName string) error <span class="cov0" title="0">{
        scenario, exists := f.registry.Scenarios[scenarioName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario not found: %s", scenarioName)
        }</span>

        <span class="cov0" title="0">for i, instance := range scenario.Instances </span><span class="cov0" title="0">{
                if !f.registry.HasType(instance.TypeID) </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario %s, instance %d (%s): unknown platform type %s",
                                scenarioName, i, instance.ID, instance.TypeID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateCallSign generates a call sign based on the platform type definition
func (f *PlatformFactory) generateCallSign(typeDef *PlatformTypeDefinition, instanceID string) string <span class="cov0" title="0">{
        if typeDef.CallSignPrefix != "" </span><span class="cov0" title="0">{
                if typeDef.CallSignFormat != "" </span><span class="cov0" title="0">{
                        // Use custom format
                        callSign := strings.ReplaceAll(typeDef.CallSignFormat, "{prefix}", typeDef.CallSignPrefix)
                        callSign = strings.ReplaceAll(callSign, "{id}", instanceID)
                        return callSign
                }</span>
                // Default format: prefix + last 3 chars of ID
                <span class="cov0" title="0">suffix := instanceID
                if len(instanceID) &gt; 3 </span><span class="cov0" title="0">{
                        suffix = instanceID[len(instanceID)-3:]
                }</span>
                <span class="cov0" title="0">return typeDef.CallSignPrefix + suffix</span>
        }

        // Fallback to instance ID
        <span class="cov0" title="0">return instanceID</span>
}

// determinePlatformType converts string type to PlatformType enum
func (f *PlatformFactory) determinePlatformType(typeStr string) models.PlatformType <span class="cov0" title="0">{
        switch typeStr </span>{
        case "airborne":<span class="cov0" title="0">
                return models.PlatformTypeAirborne</span>
        case "maritime":<span class="cov0" title="0">
                return models.PlatformTypeMaritime</span>
        case "land":<span class="cov0" title="0">
                return models.PlatformTypeLand</span>
        case "space":<span class="cov0" title="0">
                return models.PlatformTypeSpace</span>
        default:<span class="cov0" title="0">
                return models.PlatformTypeAirborne</span> // Default fallback
        }
}

// convertToModelTypeDefinition converts config type definition to models type definition
func (f *PlatformFactory) convertToModelTypeDefinition(configDef *PlatformTypeDefinition) *models.PlatformTypeDefinition <span class="cov0" title="0">{
        return &amp;models.PlatformTypeDefinition{
                Class:    configDef.Class,
                Category: configDef.Category,
                Performance: models.PerformanceCharacteristics{
                        MaxSpeed:        configDef.MaxSpeed,
                        CruiseSpeed:     configDef.CruiseSpeed,
                        MaxAltitude:     configDef.MaxAltitude,
                        FuelConsumption: calculateFuelConsumption(configDef),
                        TurningRadius:   calculateTurningRadius(configDef),
                        Acceleration:    calculateAcceleration(configDef),
                        MaxGradient:     configDef.MaxGradient,
                        ClimbRate:       calculateClimbRate(configDef),

                        // Orbital characteristics
                        OrbitalVelocity: configDef.MaxSpeed, // Use max speed as orbital velocity for space platforms
                        OrbitalPeriod:   configDef.OrbitalPeriod,
                        OrbitalAltitude: configDef.MaxAltitude, // Use max altitude as orbital altitude
                        Inclination:     configDef.Inclination,
                        Eccentricity:    0.0, // Assume circular orbits for simplicity
                },
                Physical: models.PhysicalCharacteristics{
                        Length:       configDef.Length,
                        Width:        configDef.Width,
                        Height:       configDef.Height,
                        Mass:         configDef.Mass,
                        FuelCapacity: configDef.FuelCapacity,
                        Draft:        configDef.Draft,
                },
                Operational: models.OperationalCharacteristics{
                        Range: configDef.Range,
                },
                CallsignConf: models.CallsignConfiguration{
                        Prefix: configDef.CallSignPrefix,
                        Format: configDef.CallSignFormat,
                },
        }
}</span>

// Helper functions to calculate missing performance characteristics

func calculateFuelConsumption(def *PlatformTypeDefinition) float64 <span class="cov0" title="0">{
        // Estimate fuel consumption based on platform characteristics
        if def.FuelCapacity &gt; 0 &amp;&amp; def.Range &gt; 0 </span><span class="cov0" title="0">{
                // Fuel consumption rate in liters per meter
                fuelRate := def.FuelCapacity / def.Range
                // Convert to liters per second at cruise speed
                return fuelRate * def.CruiseSpeed
        }</span>
        <span class="cov0" title="0">return 0.1</span> // Default minimal fuel consumption
}

func calculateTurningRadius(def *PlatformTypeDefinition) float64 <span class="cov0" title="0">{
        // Estimate turning radius based on platform type and size
        switch def.Type </span>{
        case "airborne":<span class="cov0" title="0">
                // Aircraft turning radius based on speed and banking
                if def.CruiseSpeed &gt; 0 </span><span class="cov0" title="0">{
                        // Assume 30 degree bank angle for commercial aircraft
                        bankAngle := 30.0 * math.Pi / 180.0
                        return (def.CruiseSpeed * def.CruiseSpeed) / (9.81 * math.Tan(bankAngle))
                }</span>
                <span class="cov0" title="0">return def.Length * 10</span> // Fallback: 10x length
        case "maritime":<span class="cov0" title="0">
                // Ship turning radius
                return def.Length * 5</span> // Ships typically turn in 5-10 ship lengths
        case "land":<span class="cov0" title="0">
                // Vehicle turning radius
                return def.Length * 2</span> // Vehicles can turn tighter
        case "space":<span class="cov0" title="0">
                // Orbital mechanics - very large turning radius
                return def.MaxAltitude</span> // Use orbital altitude as turning "radius"
        default:<span class="cov0" title="0">
                return def.Length * 3</span>
        }
}

func calculateAcceleration(def *PlatformTypeDefinition) float64 <span class="cov0" title="0">{
        // Estimate acceleration based on platform type
        switch def.Type </span>{
        case "airborne":<span class="cov0" title="0">
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 5.0 // Military aircraft: higher acceleration
                }</span>
                <span class="cov0" title="0">return 2.0</span> // Commercial aircraft: moderate acceleration
        case "maritime":<span class="cov0" title="0">
                return 0.5</span> // Ships: slow acceleration
        case "land":<span class="cov0" title="0">
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 3.0 // Military vehicles: good acceleration
                }</span>
                <span class="cov0" title="0">return 2.0</span> // Civilian vehicles: moderate acceleration
        case "space":<span class="cov0" title="0">
                return 0.01</span> // Space platforms: very low acceleration
        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

func calculateClimbRate(def *PlatformTypeDefinition) float64 <span class="cov0" title="0">{
        // Estimate climb rate for aircraft
        if def.Type == "airborne" </span><span class="cov0" title="0">{
                if def.Category == "military" </span><span class="cov0" title="0">{
                        return 20.0 // Military aircraft: higher climb rate
                }</span>
                <span class="cov0" title="0">return 10.0</span> // Commercial aircraft: standard climb rate
        }
        <span class="cov0" title="0">return 0.0</span> // Non-aircraft don't climb
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// AirbornePlatform represents aircraft platforms with enhanced physics
type AirbornePlatform struct {
        // Embed UniversalPlatform for base functionality
        UniversalPlatform

        // Enhanced flight characteristics (aircraft-specific)
        MaxRollRate     float64 // degrees/second
        MaxPitchRate    float64 // degrees/second
        MaxYawRate      float64 // degrees/second
        MaxBankAngle    float64 // degrees
        MaxPitchAngle   float64 // degrees
        MaxLoadFactor   float64 // g-force
        StallSpeed      float64 // m/s
        MaxAcceleration float64 // m/s²
        MaxDeceleration float64 // m/s²

        // Physical characteristics (additional to base)
        WingArea        float64         // m²
        WingLoading     float64         // kg/m²
        CenterOfGravity CenterOfGravity // center of mass location

        // Flight state
        FlightPhase FlightPhase // takeoff, climb, cruise, descent, approach, landing
}

// FlightPhase represents the current phase of flight
type FlightPhase string

const (
        FlightPhaseTakeoff  FlightPhase = "takeoff"
        FlightPhaseClimb    FlightPhase = "climb"
        FlightPhaseCruise   FlightPhase = "cruise"
        FlightPhaseDescent  FlightPhase = "descent"
        FlightPhaseApproach FlightPhase = "approach"
        FlightPhaseLanding  FlightPhase = "landing"
        FlightPhaseParked   FlightPhase = "parked"
)

// Core Platform interface implementation - delegate to embedded UniversalPlatform
func (a *AirbornePlatform) GetID() string           <span class="cov8" title="1">{ return a.UniversalPlatform.GetID() }</span>
func (a *AirbornePlatform) GetType() PlatformType   <span class="cov8" title="1">{ return a.UniversalPlatform.GetType() }</span>
func (a *AirbornePlatform) GetClass() string        <span class="cov8" title="1">{ return a.UniversalPlatform.GetClass() }</span>
func (a *AirbornePlatform) GetName() string         <span class="cov8" title="1">{ return a.UniversalPlatform.GetName() }</span>
func (a *AirbornePlatform) GetCallSign() string     <span class="cov0" title="0">{ return a.UniversalPlatform.GetCallSign() }</span>
func (a *AirbornePlatform) GetState() PlatformState <span class="cov8" title="1">{ return a.UniversalPlatform.GetState() }</span>
func (a *AirbornePlatform) GetMaxSpeed() float64    <span class="cov8" title="1">{ return a.UniversalPlatform.GetMaxSpeed() }</span>
func (a *AirbornePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return a.UniversalPlatform.GetMaxAltitude() }</span>
func (a *AirbornePlatform) GetLength() float64      <span class="cov8" title="1">{ return a.UniversalPlatform.GetLength() }</span>
func (a *AirbornePlatform) GetWidth() float64       <span class="cov0" title="0">{ return a.UniversalPlatform.GetWidth() }</span>
func (a *AirbornePlatform) GetHeight() float64      <span class="cov0" title="0">{ return a.UniversalPlatform.GetHeight() }</span>
func (a *AirbornePlatform) GetMass() float64        <span class="cov0" title="0">{ return a.UniversalPlatform.GetMass() }</span>

func (a *AirbornePlatform) UpdateState(state PlatformState) <span class="cov8" title="1">{
        a.UniversalPlatform.UpdateState(state)
}</span>

func (a *AirbornePlatform) SetDestination(pos Position) error <span class="cov8" title="1">{
        return a.UniversalPlatform.SetDestination(pos)
}</span>

// Enhanced 3D physics methods
func (a *AirbornePlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        // Initialize physics state with aircraft characteristics
        a.UniversalPlatform.State.Physics = PhysicsState{
                Position:            a.UniversalPlatform.State.Position,
                Velocity:            a.UniversalPlatform.State.Velocity,
                Acceleration:        Acceleration{},
                Attitude:            Attitude{Yaw: a.UniversalPlatform.State.Heading},
                AngularVelocity:     AngularVelocity{},
                AngularAcceleration: AngularAcceleration{},
                Mass:                a.UniversalPlatform.GetMass(),
                MomentOfInertia:     a.calculateMomentOfInertia(),
                Forces:              Forces{Weight: a.UniversalPlatform.GetMass() * 9.81},
                Torques:             Torques{},
        }
}</span>

func (a *AirbornePlatform) calculateMomentOfInertia() MomentOfInertia <span class="cov0" title="0">{
        // Calculate realistic moment of inertia for aircraft
        mass := a.UniversalPlatform.GetMass()
        length := a.UniversalPlatform.GetLength()
        width := a.UniversalPlatform.GetWidth()
        height := a.UniversalPlatform.GetHeight()

        return MomentOfInertia{
                Ixx: mass * (width*width + height*height) / 20,   // Roll axis
                Iyy: mass * (length*length + height*height) / 20, // Pitch axis
                Izz: mass * (length*length + width*width) / 20,   // Yaw axis
        }
}</span>

func (a *AirbornePlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov0" title="0">{
        // Use the existing enhanced Update method which already includes 3D physics
        return a.Update(deltaTime)
}</span>

func (a *AirbornePlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return a.UniversalPlatform.State.Physics
}</span>

func (a *AirbornePlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        a.UniversalPlatform.State.Physics = physics
        // Update legacy compatibility fields
        a.UniversalPlatform.State.Position = physics.Position
        a.UniversalPlatform.State.Velocity = physics.Velocity
        a.UniversalPlatform.State.Heading = physics.Attitude.Yaw
}</span>

// Update implements enhanced aircraft physics and flight dynamics
func (a *AirbornePlatform) Update(deltaTime time.Duration) error <span class="cov8" title="1">{
        if a.UniversalPlatform.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">dt := deltaTime.Seconds()

        // Calculate 3D distance and bearing to destination
        deltaLat := a.UniversalPlatform.Destination.Latitude - a.UniversalPlatform.State.Position.Latitude
        deltaLon := a.UniversalPlatform.Destination.Longitude - a.UniversalPlatform.State.Position.Longitude
        deltaAlt := a.UniversalPlatform.Destination.Altitude - a.UniversalPlatform.State.Position.Altitude

        distance := math.Sqrt(deltaLat*deltaLat + deltaLon*deltaLon)
        distance3D := math.Sqrt(distance*distance + (deltaAlt/111320)*(deltaAlt/111320))

        if distance3D &lt; 0.001 </span><span class="cov0" title="0">{ // Close enough
                a.UniversalPlatform.Destination = nil
                return nil
        }</span>

        // Initialize physics if not already done
        <span class="cov8" title="1">if a.UniversalPlatform.State.Physics.Mass == 0 </span><span class="cov0" title="0">{
                a.Initialize3DPhysics()
        }</span>

        // Enhanced flight physics
        <span class="cov8" title="1">a.updateFlightPhase()
        a.updateFlightDynamics(dt)

        // Apply aerodynamic forces and moments
        a.calculateAerodynamicForces()
        a.updateAttitude(dt)

        // Update position based on velocity
        a.updatePosition(dt)

        a.UniversalPlatform.State.LastUpdated = time.Now()
        return nil</span>
}

// updateFlightPhase determines the current phase of flight
func (a *AirbornePlatform) updateFlightPhase() <span class="cov8" title="1">{
        // If we have a destination and are at low altitude with low speed, start takeoff
        if a.UniversalPlatform.Destination != nil &amp;&amp; a.UniversalPlatform.State.Position.Altitude &lt; 100 &amp;&amp; a.UniversalPlatform.State.Speed &lt; 50 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseTakeoff
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &lt; 100 &amp;&amp; a.UniversalPlatform.State.Speed &lt; 50 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseParked
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &lt; 300 &amp;&amp; a.UniversalPlatform.State.Velocity.Up &gt; 0 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseTakeoff
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Velocity.Up &gt; 5 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseClimb
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Velocity.Up &lt; -5 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseDescent
        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Position.Altitude &gt; 1000 </span><span class="cov8" title="1">{
                a.FlightPhase = FlightPhaseCruise
        }</span> else<span class="cov0" title="0"> {
                a.FlightPhase = FlightPhaseApproach
        }</span>
}

// updateFlightDynamics applies realistic flight dynamics
func (a *AirbornePlatform) updateFlightDynamics(dt float64) <span class="cov8" title="1">{
        // Calculate target velocity based on flight phase
        var targetSpeed float64
        var targetAltitude float64

        cruiseSpeed := a.UniversalPlatform.GetMaxSpeed() * 0.9  // Use 90% of max speed as cruise
        cruiseAlt := a.UniversalPlatform.GetMaxAltitude() * 0.8 // Use 80% of max altitude as cruise

        switch a.FlightPhase </span>{
        case FlightPhaseTakeoff:<span class="cov8" title="1">
                targetSpeed = math.Min(cruiseSpeed*0.8, a.UniversalPlatform.State.Speed+a.MaxAcceleration*dt)
                targetAltitude = a.UniversalPlatform.State.Position.Altitude + 10*dt</span> // 10 m/s climb rate
        case FlightPhaseClimb:<span class="cov0" title="0">
                targetSpeed = cruiseSpeed
                targetAltitude = math.Min(a.UniversalPlatform.Destination.Altitude, a.UniversalPlatform.State.Position.Altitude+15*dt)</span>
        case FlightPhaseCruise:<span class="cov8" title="1">
                targetSpeed = cruiseSpeed
                targetAltitude = cruiseAlt</span>
        case FlightPhaseDescent:<span class="cov0" title="0">
                targetSpeed = cruiseSpeed * 0.9
                targetAltitude = math.Max(a.UniversalPlatform.Destination.Altitude, a.UniversalPlatform.State.Position.Altitude-12*dt)</span>
        case FlightPhaseApproach:<span class="cov0" title="0">
                targetSpeed = math.Max(a.StallSpeed*1.3, cruiseSpeed*0.6)
                targetAltitude = a.UniversalPlatform.Destination.Altitude</span>
        default:<span class="cov0" title="0">
                targetSpeed = 0
                targetAltitude = a.UniversalPlatform.State.Position.Altitude</span>
        }

        // Apply acceleration constraints
        <span class="cov8" title="1">speedDiff := targetSpeed - a.UniversalPlatform.State.Speed
        maxSpeedChange := a.MaxAcceleration * dt

        if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed = targetSpeed
        }</span> else<span class="cov8" title="1"> if speedDiff &gt; 0 </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed += maxSpeedChange
        }</span> else<span class="cov0" title="0"> {
                a.UniversalPlatform.State.Speed -= math.Min(maxSpeedChange, a.MaxDeceleration*dt)
        }</span>

        // Ensure minimum flying speed
        <span class="cov8" title="1">if a.UniversalPlatform.State.Position.Altitude &gt; 50 &amp;&amp; a.UniversalPlatform.State.Speed &lt; a.StallSpeed </span><span class="cov8" title="1">{
                a.UniversalPlatform.State.Speed = a.StallSpeed
        }</span>

        // Calculate climb/descent rate
        <span class="cov8" title="1">altDiff := targetAltitude - a.UniversalPlatform.State.Position.Altitude
        a.UniversalPlatform.State.Velocity.Up = math.Max(-15, math.Min(15, altDiff/dt))</span> // Limit vertical speed
}

// calculateAerodynamicForces computes forces acting on the aircraft
func (a *AirbornePlatform) calculateAerodynamicForces() <span class="cov8" title="1">{
        // Air density at altitude (simplified)
        airDensity := 1.225 * math.Exp(-a.UniversalPlatform.State.Position.Altitude/8400) // kg/m³

        // Dynamic pressure
        dynamicPressure := 0.5 * airDensity * a.UniversalPlatform.State.Speed * a.UniversalPlatform.State.Speed

        // Lift force (simplified)
        liftCoeff := 0.8 // Typical cruise lift coefficient
        a.UniversalPlatform.State.Physics.Forces.Lift = liftCoeff * dynamicPressure * a.WingArea

        // Drag force
        dragCoeff := 0.025 + (liftCoeff*liftCoeff)/(math.Pi*8*0.8) // Induced drag
        a.UniversalPlatform.State.Physics.Forces.Drag = dragCoeff * dynamicPressure * a.WingArea

        // Weight
        gravity := 9.81
        a.UniversalPlatform.State.Physics.Forces.Weight = a.UniversalPlatform.GetMass() * gravity

        // Thrust (to maintain speed)
        a.UniversalPlatform.State.Physics.Forces.Thrust = a.UniversalPlatform.State.Physics.Forces.Drag

        // Calculate accelerations
        mass := a.UniversalPlatform.GetMass()
        a.UniversalPlatform.State.Physics.Acceleration.North = (a.UniversalPlatform.State.Physics.Forces.Thrust - a.UniversalPlatform.State.Physics.Forces.Drag) / mass
        a.UniversalPlatform.State.Physics.Acceleration.Up = (a.UniversalPlatform.State.Physics.Forces.Lift - a.UniversalPlatform.State.Physics.Forces.Weight) / mass
}</span>

// updateAttitude updates aircraft orientation based on flight dynamics
func (a *AirbornePlatform) updateAttitude(dt float64) <span class="cov8" title="1">{
        // Calculate desired bank angle for turns
        if a.UniversalPlatform.Destination != nil </span><span class="cov8" title="1">{
                desiredHeading := a.calculateBearing(a.UniversalPlatform.State.Position, *a.UniversalPlatform.Destination)
                headingError := desiredHeading - a.UniversalPlatform.State.Heading

                // Normalize heading error to [-180, 180]
                for headingError &gt; 180 </span><span class="cov8" title="1">{
                        headingError -= 360
                }</span>
                <span class="cov8" title="1">for headingError &lt; -180 </span><span class="cov0" title="0">{
                        headingError += 360
                }</span>

                // Calculate bank angle for coordinated turn - use a proportional controller
                // Larger heading errors require more bank angle
                <span class="cov8" title="1">maxBankForTurn := math.Min(a.MaxBankAngle, 30) // Limit to 30 degrees for normal flight

                // Use a gain factor to make the aircraft more responsive to heading errors
                bankGain := 1.5 // Adjust this to make turns more or less aggressive
                desiredBank := math.Max(-maxBankForTurn, math.Min(maxBankForTurn, headingError*bankGain))

                // Only bank if there's a significant heading error (more than 2 degrees)
                if math.Abs(headingError) &gt; 2.0 </span><span class="cov8" title="1">{
                        // Apply roll rate limits
                        rollError := desiredBank - a.UniversalPlatform.State.Physics.Attitude.Roll
                        maxRollChange := a.MaxRollRate * dt

                        if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll = desiredBank
                        }</span> else<span class="cov8" title="1"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                        }</span> else<span class="cov8" title="1"> {
                                a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Level off if close to desired heading
                        rollError := -a.UniversalPlatform.State.Physics.Attitude.Roll
                        maxRollChange := a.MaxRollRate * dt

                        if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll = 0
                        }</span> else<span class="cov0" title="0"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                        }</span> else<span class="cov0" title="0"> {
                                a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                        }</span>
                }

                // Calculate turn rate from bank angle (coordinated turn formula)
                <span class="cov8" title="1">if a.UniversalPlatform.State.Speed &gt; 0 &amp;&amp; math.Abs(a.UniversalPlatform.State.Physics.Attitude.Roll) &gt; 1.0 </span><span class="cov8" title="1">{
                        // Turn rate = (g * tan(bank_angle)) / velocity (in radians/second)
                        bankRad := a.UniversalPlatform.State.Physics.Attitude.Roll * math.Pi / 180
                        turnRate := (9.81 * math.Tan(bankRad)) / a.UniversalPlatform.State.Speed * 180 / math.Pi // Convert to degrees/second
                        a.UniversalPlatform.State.Physics.AngularVelocity.YawRate = turnRate
                        a.UniversalPlatform.State.Heading += turnRate * dt

                        // Normalize heading to [0, 360)
                        if a.UniversalPlatform.State.Heading &gt;= 360 </span><span class="cov0" title="0">{
                                a.UniversalPlatform.State.Heading -= 360
                        }</span> else<span class="cov8" title="1"> if a.UniversalPlatform.State.Heading &lt; 0 </span><span class="cov8" title="1">{
                                a.UniversalPlatform.State.Heading += 360
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // No destination - level off the aircraft
                rollError := -a.UniversalPlatform.State.Physics.Attitude.Roll
                maxRollChange := a.MaxRollRate * dt

                if math.Abs(rollError) &lt;= maxRollChange </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Roll = 0
                }</span> else<span class="cov0" title="0"> if rollError &gt; 0 </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Roll += maxRollChange
                }</span> else<span class="cov0" title="0"> {
                        a.UniversalPlatform.State.Physics.Attitude.Roll -= maxRollChange
                }</span>
        }

        // Calculate pitch angle based on climb/descent
        <span class="cov8" title="1">if a.UniversalPlatform.State.Speed &gt; 0 </span><span class="cov8" title="1">{
                desiredPitch := math.Atan(a.UniversalPlatform.State.Velocity.Up/a.UniversalPlatform.State.Speed) * 180 / math.Pi
                desiredPitch = math.Max(-a.MaxPitchAngle, math.Min(a.MaxPitchAngle, desiredPitch))

                pitchError := desiredPitch - a.UniversalPlatform.State.Physics.Attitude.Pitch
                maxPitchChange := a.MaxPitchRate * dt

                if math.Abs(pitchError) &lt;= maxPitchChange </span><span class="cov8" title="1">{
                        a.UniversalPlatform.State.Physics.Attitude.Pitch = desiredPitch
                }</span> else<span class="cov0" title="0"> if pitchError &gt; 0 </span><span class="cov0" title="0">{
                        a.UniversalPlatform.State.Physics.Attitude.Pitch += maxPitchChange
                }</span> else<span class="cov0" title="0"> {
                        a.UniversalPlatform.State.Physics.Attitude.Pitch -= maxPitchChange
                }</span>
        }

        // Update yaw to match heading
        <span class="cov8" title="1">a.UniversalPlatform.State.Physics.Attitude.Yaw = a.UniversalPlatform.State.Heading
        // Update roll for compatibility
        a.UniversalPlatform.State.Roll = a.UniversalPlatform.State.Physics.Attitude.Roll</span>
}

// updatePosition calculates new position based on current heading and speed
func (a *AirbornePlatform) updatePosition(deltaSeconds float64) <span class="cov8" title="1">{
        if a.UniversalPlatform.State.Speed &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert heading to radians (0° = North, 90° = East)
        <span class="cov8" title="1">headingRad := a.UniversalPlatform.State.Heading * math.Pi / 180.0

        // Calculate distance moved
        distance := a.UniversalPlatform.State.Speed * deltaSeconds

        // Earth radius in meters
        earthRadius := 6371000.0

        // Calculate new position
        deltaLat := (distance * math.Cos(headingRad)) / earthRadius * 180.0 / math.Pi
        deltaLon := (distance * math.Sin(headingRad)) / earthRadius * 180.0 / math.Pi / math.Cos(a.UniversalPlatform.State.Position.Latitude*math.Pi/180.0)

        a.UniversalPlatform.State.Position.Latitude += deltaLat
        a.UniversalPlatform.State.Position.Longitude += deltaLon

        // Update altitude based on climb rate
        climbRate := a.UniversalPlatform.State.Velocity.Up
        a.UniversalPlatform.State.Position.Altitude += climbRate * deltaSeconds

        // Sync with physics state
        a.UniversalPlatform.State.Physics.Position = a.UniversalPlatform.State.Position
        a.UniversalPlatform.State.Physics.Velocity.North = a.UniversalPlatform.State.Speed * math.Cos(headingRad)
        a.UniversalPlatform.State.Physics.Velocity.East = a.UniversalPlatform.State.Speed * math.Sin(headingRad)
        a.UniversalPlatform.State.Physics.Velocity.Up = climbRate</span>
}

// calculateBearing calculates bearing from one position to another
func (a *AirbornePlatform) calculateBearing(from, to Position) float64 <span class="cov8" title="1">{
        lat1 := from.Latitude * math.Pi / 180.0
        lat2 := to.Latitude * math.Pi / 180.0
        deltaLon := (to.Longitude - from.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi

        // Normalize to [0, 360)
        for bearing &lt; 0 </span><span class="cov8" title="1">{
                bearing += 360
        }</span>
        <span class="cov8" title="1">for bearing &gt;= 360 </span><span class="cov0" title="0">{
                bearing -= 360
        }</span>

        <span class="cov8" title="1">return bearing</span>
}

// Aircraft factory functions with enhanced physics parameters

// NewBoeing737_800 creates a Boeing 737-800 with realistic physics
func NewBoeing737_800(id, flightNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 79010.0   // kg
        wingArea := 124.6 // m²

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "Boeing 737-800",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      257,   // m/s (500 kts)
                        CruiseSpeed:   230,   // m/s (447 kts)
                        MaxAltitude:   12500, // meters (41,000 ft)
                        ClimbRate:     15,    // m/s
                        Acceleration:  1.5,   // m/s²
                        TurningRadius: 1000,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 39.5, // meters
                        Width:  35.8, // wingspan
                        Height: 12.5, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: flightNumber,
                Type: "Boeing 737-800",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     flightNumber,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 15.0 * 15.0,
                                        Iyy: mass * 20.0 * 20.0,
                                        Izz: mass * 20.0 * 20.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       15,  // degrees/second
                MaxPitchRate:      5,   // degrees/second
                MaxYawRate:        3,   // degrees/second
                MaxBankAngle:      30,  // degrees (normal ops)
                MaxPitchAngle:     15,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        77,  // m/s (150 kts)
                MaxAcceleration:   1.5, // m/s²
                MaxDeceleration:   3.0, // m/s²
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 18.0, Y: 0, Z: 2.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewAirbusA320 creates an Airbus A320 with realistic physics
func NewAirbusA320(id, flightNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 78000.0   // kg
        wingArea := 122.6 // m²

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "Airbus A320",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      257,   // m/s (500 kts)
                        CruiseSpeed:   230,   // m/s (447 kts)
                        MaxAltitude:   12000, // meters (39,370 ft)
                        ClimbRate:     15,    // m/s
                        Acceleration:  1.5,   // m/s²
                        TurningRadius: 1000,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 37.6, // meters
                        Width:  36.0, // wingspan
                        Height: 11.8, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: flightNumber,
                Type: "Airbus A320",
        }

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     flightNumber,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 18.0 * 18.0,
                                        Iyy: mass * 19.0 * 19.0,
                                        Izz: mass * 19.0 * 19.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       15,  // degrees/second
                MaxPitchRate:      5,   // degrees/second
                MaxYawRate:        3,   // degrees/second
                MaxBankAngle:      30,  // degrees
                MaxPitchAngle:     15,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        77,  // m/s (150 kts)
                MaxAcceleration:   1.5, // m/s²
                MaxDeceleration:   3.0, // m/s²
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 17.0, Y: 0, Z: 2.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewF16FightingFalcon creates an F-16 with enhanced military flight dynamics
func NewF16FightingFalcon(id, tailNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 19187.0   // kg
        wingArea := 27.87 // m²

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "F-16 Fighting Falcon",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      617,   // m/s (Mach 2.0+ at altitude)
                        CruiseSpeed:   257,   // m/s (500 kts)
                        MaxAltitude:   15240, // meters (50,000 ft)
                        ClimbRate:     25,    // m/s
                        Acceleration:  8.0,   // m/s²
                        TurningRadius: 500,   // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 15.0, // meters
                        Width:  10.0, // wingspan
                        Height: 5.1,  // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: tailNumber,
                Type: "F-16 Fighting Falcon",
        }

        callSign := fmt.Sprintf("VIPER%s", tailNumber[len(tailNumber)-3:])

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     callSign,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 5.0 * 5.0,
                                        Iyy: mass * 7.5 * 7.5,
                                        Izz: mass * 7.5 * 7.5,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       720,  // degrees/second (highly maneuverable)
                MaxPitchRate:      40,   // degrees/second
                MaxYawRate:        20,   // degrees/second
                MaxBankAngle:      90,   // degrees (fighter aircraft)
                MaxPitchAngle:     60,   // degrees
                MaxLoadFactor:     9.0,  // g-force
                StallSpeed:        93,   // m/s (180 kts)
                MaxAcceleration:   8.0,  // m/s² (high thrust-to-weight)
                MaxDeceleration:   15.0, // m/s² (air brakes)
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 7.5, Y: 0, Z: 1.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>

// NewC130Hercules creates a C-130 military transport with cargo aircraft characteristics
func NewC130Hercules(id, tailNumber string, startPos Position) *AirbornePlatform <span class="cov8" title="1">{
        mass := 70300.0   // kg
        wingArea := 162.1 // m²

        // Create the base UniversalPlatform
        typeDef := &amp;PlatformTypeDefinition{
                Class: "C-130 Hercules",
                Performance: PerformanceCharacteristics{
                        MaxSpeed:      190,   // m/s (370 kts)
                        CruiseSpeed:   160,   // m/s (310 kts)
                        MaxAltitude:   10060, // meters (33,000 ft)
                        ClimbRate:     8,     // m/s
                        Acceleration:  1.0,   // m/s²
                        TurningRadius: 1500,  // meters
                },
                Physical: PhysicalCharacteristics{
                        Length: 29.8, // meters
                        Width:  40.4, // wingspan
                        Height: 11.7, // meters
                        Mass:   mass,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:   id,
                Name: tailNumber,
                Type: "C-130 Hercules",
        }

        callSign := fmt.Sprintf("HERKY%s", tailNumber[len(tailNumber)-2:])

        universalPlatform := UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                CallSign:     callSign,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 20.0 * 20.0,
                                        Iyy: mass * 15.0 * 15.0,
                                        Izz: mass * 25.0 * 25.0,
                                },
                        },
                },
        }

        return &amp;AirbornePlatform{
                UniversalPlatform: universalPlatform,
                MaxRollRate:       10,  // degrees/second (large aircraft)
                MaxPitchRate:      3,   // degrees/second
                MaxYawRate:        2,   // degrees/second
                MaxBankAngle:      25,  // degrees (transport aircraft)
                MaxPitchAngle:     10,  // degrees
                MaxLoadFactor:     2.5, // g-force
                StallSpeed:        61,  // m/s (119 kts)
                MaxAcceleration:   1.0, // m/s²
                MaxDeceleration:   2.5, // m/s²
                WingArea:          wingArea,
                WingLoading:       mass / wingArea,
                CenterOfGravity:   CenterOfGravity{X: 14.9, Y: 0, Z: 3.0},
                FlightPhase:       FlightPhaseParked,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "fmt"
        "time"
)

// UnifiedPlatformFactory provides factory functions for creating UniversalPlatform instances
// with realistic configurations for different platform types

// Aircraft Factories

// NewBoeing737_800Universal creates a Boeing 737-800 using UniversalPlatform
func NewBoeing737_800Universal(id, flightNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 79010.0   // kg
        wingArea := 124.6 // m²

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Boeing 737-800",
                Category: "commercial",
                Physical: PhysicalCharacteristics{
                        Length:      39.5,
                        Width:       35.8, // wingspan
                        Height:      12.5,
                        Mass:        mass,
                        WingArea:    wingArea,
                        FrontalArea: 15.0, // Estimated
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:          257,     // m/s (500 kts)
                        CruiseSpeed:       230,     // m/s (447 kts)
                        MaxAltitude:       12500,   // meters (41,000 ft)
                        FuelConsumption:   3.5,     // kg/s fuel consumption rate
                        TurningRadius:     3000,    // meters turning radius
                        Acceleration:      1.5,     // m/s²
                        ClimbRate:         12.0,    // m/s climb rate
                        Range:             5665000, // meters range
                        MaxThrustToWeight: 0.28,    // Typical for commercial aircraft
                        MaxRollRate:       15,      // degrees/second
                        MaxPitchRate:      5,       // degrees/second
                        MaxYawRate:        3,       // degrees/second
                        MaxBankAngle:      30,      // degrees (normal ops)
                        MaxPitchAngle:     15,      // degrees
                        MaxLoadFactor:     2.5,     // g-force
                        StallSpeed:        77,      // m/s (150 kts)
                        MaxAcceleration:   1.5,     // m/s²
                        MaxDeceleration:   3.0,     // m/s²
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    100000, // 100km weather radar
                        OpticalRange:  50000,  // 50km visibility
                        InfraredRange: 20000,  // 20km
                },
                Operational: OperationalCharacteristics{
                        Range:             5665000, // meters (3,060 nm)
                        PassengerCapacity: 189,
                        CrewCapacity:      6,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "airborne",
                Name:          flightNumber,
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 15.0 * 15.0, // wingspan
                                        Iyy: mass * 20.0 * 20.0, // length
                                        Izz: mass * 20.0 * 20.0, // length
                                },
                        },
                },
                CallSign:      flightNumber,
                FuelRemaining: 26000,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.95},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.98},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.99},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "N/A", // Civilian aircraft
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// NewF16FightingFalconUniversal creates an F-16 using UniversalPlatform
func NewF16FightingFalconUniversal(id, tailNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 19187.0   // kg
        wingArea := 27.87 // m²

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "F-16 Fighting Falcon",
                Category: "military",
                Physical: PhysicalCharacteristics{
                        Length:       15.0,
                        Width:        10.0, // wingspan
                        Height:       5.1,
                        Mass:         mass,
                        WingArea:     wingArea,
                        FrontalArea:  8.0,  // Estimated
                        FuelCapacity: 3200, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:          617,   // m/s (Mach 2.0+ at altitude)
                        CruiseSpeed:       257,   // m/s (500 kts)
                        MaxAltitude:       15240, // meters (50,000 ft)
                        MaxThrustToWeight: 1.2,   // High performance fighter
                        MaxRollRate:       720,   // degrees/second
                        MaxPitchRate:      40,    // degrees/second
                        MaxYawRate:        20,    // degrees/second
                        MaxBankAngle:      90,    // degrees
                        MaxPitchAngle:     60,    // degrees
                        MaxLoadFactor:     9.0,   // g-force
                        StallSpeed:        93,    // m/s (180 kts)
                        MaxAcceleration:   8.0,   // m/s²
                        MaxDeceleration:   15.0,  // m/s²
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    200000, // 200km air-to-air radar
                        OpticalRange:  50000,  // 50km
                        InfraredRange: 100000, // 100km IRST
                },
                Operational: OperationalCharacteristics{
                        Range:         2220000, // meters (1,200 nm)
                        CrewCapacity:  1,
                        WeaponSystems: []string{"AIM-120", "AIM-9", "20mm Cannon"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "airborne",
                Name:          tailNumber,
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeAirborne,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 5.0 * 5.0,
                                        Iyy: mass * 7.5 * 7.5,
                                        Izz: mass * 7.5 * 7.5,
                                },
                        },
                },
                CallSign:      fmt.Sprintf("VIPER%s", tailNumber[len(tailNumber)-3:]),
                FuelRemaining: 3200,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.98},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.99},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.95},
                        WeaponSystem:        SystemState{Operational: true, Efficiency: 1.0},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "ARMED", // Military fighter
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// Land Vehicle Factories

// NewM1A2AbramsUniversal creates an M1A2 Abrams tank using UniversalPlatform
func NewM1A2AbramsUniversal(id, unitDesignation string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 62000.0 // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "M1A2 Abrams MBT",
                Category: "military",
                Physical: PhysicalCharacteristics{
                        Length:       9.8,
                        Width:        3.7,
                        Height:       2.4,
                        Mass:         mass,
                        FrontalArea:  8.9,  // width × height
                        FuelCapacity: 1900, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        20,   // m/s (45 mph)
                        CruiseSpeed:     13.4, // m/s (30 mph)
                        MaxAltitude:     0,    // Ground vehicle
                        MaxAcceleration: 2.0,  // m/s²
                        MaxDeceleration: 8.0,  // m/s²
                        MaxGradient:     30.0, // degrees
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      false, // Ground vehicles don't typically have radar
                        HasCompass:    true,
                        RadarRange:    0,
                        OpticalRange:  5000,  // 5km visual
                        InfraredRange: 10000, // 10km thermal imaging
                },
                Operational: OperationalCharacteristics{
                        Range:         426000, // meters (265 miles)
                        CrewCapacity:  4,
                        WeaponSystems: []string{"120mm M256", "M240 Machine Gun"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "land",
                Name:          unitDesignation,
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeLand,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 1.8 * 1.8, // width
                                        Iyy: mass * 4.9 * 4.9, // length
                                        Izz: mass * 4.9 * 4.9, // length
                                },
                        },
                },
                CallSign:      fmt.Sprintf("ARMOR%s", id[len(id)-2:]),
                FuelRemaining: 1900,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.90},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.95},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.92},
                        WeaponSystem:        SystemState{Operational: true, Efficiency: 1.0},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "ARMED", // Military tank
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// Maritime Factories

// NewArleighBurkeDestroyerUniversal creates an Arleigh Burke destroyer using UniversalPlatform
func NewArleighBurkeDestroyerUniversal(id, shipName string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 0 // Sea level
        mass := 9200000.0     // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Arleigh Burke-class",
                Category: "naval",
                Physical: PhysicalCharacteristics{
                        Length:       155,
                        Width:        20, // beam
                        Height:       18, // above waterline
                        Mass:         mass,
                        WetArea:      3100,    // underwater hull area
                        Draft:        6.3,     // depth below waterline
                        FuelCapacity: 1200000, // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        15.4, // m/s (30+ knots)
                        CruiseSpeed:     10.3, // m/s (20 knots)
                        MaxAcceleration: 0.5,  // m/s²
                        MaxDeceleration: 2.0,  // m/s²
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    300000, // 300km long-range naval radar
                        OpticalRange:  50000,  // 50km
                        InfraredRange: 100000, // 100km
                },
                Operational: OperationalCharacteristics{
                        Range:         8000000, // meters (4,320 nm)
                        CrewCapacity:  323,
                        WeaponSystems: []string{"Tomahawk", "Standard Missile", "5\" Gun"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "maritime",
                Name:          fmt.Sprintf("USS %s", shipName),
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 10.0 * 10.0, // beam
                                        Iyy: mass * 77.5 * 77.5, // length
                                        Izz: mass * 77.5 * 77.5, // length
                                },
                        },
                },
                CallSign:      fmt.Sprintf("NAVY%s", id[len(id)-3:]),
                FuelRemaining: 1200000,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.95},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.98},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.96},
                        WeaponSystem:        SystemState{Operational: true, Efficiency: 1.0},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "ARMED", // Naval destroyer
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// Space Platform Factories

// NewStarlinkSatelliteUniversal creates a Starlink satellite using UniversalPlatform
func NewStarlinkSatelliteUniversal(id, satelliteNumber string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 550000 // 550 km altitude
        mass := 260.0              // kg

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Starlink Satellite",
                Category: "communications",
                Physical: PhysicalCharacteristics{
                        Length:         2.8,
                        Width:          1.9,
                        Height:         0.32,
                        Mass:           mass,
                        SolarPanelArea: 32.0, // m²
                        FuelCapacity:   50,   // kg xenon propellant
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        7590,   // m/s orbital velocity
                        CruiseSpeed:     7590,   // same as max for satellites
                        MaxAltitude:     550000, // meters
                        OrbitalPeriod:   5760,   // seconds (96 minutes)
                        OrbitalVelocity: 7590,   // m/s
                        OrbitalAltitude: 550000, // meters
                        Inclination:     53.0,   // degrees
                        MaxAcceleration: 0.001,  // m/s² (ion thrusters)
                        MaxDeceleration: 0.001,  // m/s²
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        false, // Satellites don't use GPS
                        HasRadar:      false,
                        HasCompass:    false, // Not useful in space
                        RadarRange:    0,
                        OpticalRange:  1000000, // 1000km space observation
                        InfraredRange: 500000,  // 500km
                },
                Operational: OperationalCharacteristics{
                        MissionLife:    5.0, // years
                        FrequencyBands: []string{"Ku-band", "Ka-band"},
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "space",
                Name:          fmt.Sprintf("Starlink-%s", satelliteNumber),
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeSpace,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90, // Eastward orbital motion
                        Speed:       7590,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                                MomentOfInertia: MomentOfInertia{
                                        Ixx: mass * 0.95 * 0.95, // width
                                        Iyy: mass * 1.4 * 1.4,   // length
                                        Izz: mass * 1.4 * 1.4,   // length
                                },
                        },
                },
                CallSign:      fmt.Sprintf("STARLINK%s", id[len(id)-3:]),
                FuelRemaining: 50,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.98},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 1.0},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.99},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "N/A", // Civilian satellite
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// Additional factory functions for comprehensive coverage

// NewCivilianCarUniversal creates a civilian passenger car
func NewCivilianCarUniversal(id, model string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        mass := 1500.0 // kg typical passenger car

        typeDef := &amp;PlatformTypeDefinition{
                Class:    model,
                Category: "civilian",
                Physical: PhysicalCharacteristics{
                        Length:       4.5,
                        Width:        1.8,
                        Height:       1.4,
                        Mass:         mass,
                        FrontalArea:  2.5, // typical car
                        FuelCapacity: 60,  // liters
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        50,  // m/s (112 mph)
                        CruiseSpeed:     25,  // m/s (56 mph)
                        MaxAcceleration: 3.0, // m/s²
                        MaxDeceleration: 8.0, // m/s²
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      false, // Basic civilian car
                        HasCompass:    true,
                        RadarRange:    0,
                        OpticalRange:  1000, // 1km visual
                        InfraredRange: 0,
                },
                Operational: OperationalCharacteristics{
                        Range:             600000, // meters (600 km)
                        PassengerCapacity: 5,
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "land",
                Name:          fmt.Sprintf("Vehicle %s", id),
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeLand,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                        },
                },
                CallSign:      fmt.Sprintf("CAR%s", id[len(id)-3:]),
                FuelRemaining: 60,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.95},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.98},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.99},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "N/A", // Civilian vehicle
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// NewContainerShipUniversal creates a large container vessel
func NewContainerShipUniversal(id, shipName string, startPos Position) *UniversalPlatform <span class="cov8" title="1">{
        startPos.Altitude = 0 // Sea level
        mass := 200000000.0   // kg (200,000 tonnes)

        typeDef := &amp;PlatformTypeDefinition{
                Class:    "Ultra Large Container Vessel",
                Category: "commercial",
                Physical: PhysicalCharacteristics{
                        Length:       400,
                        Width:        59, // beam
                        Height:       73, // above waterline
                        Mass:         mass,
                        WetArea:      24000,    // large underwater hull
                        Draft:        16,       // deep draft
                        FuelCapacity: 15000000, // liters (massive fuel capacity)
                },
                Performance: PerformanceCharacteristics{
                        MaxSpeed:        12.9,     // m/s (25 knots)
                        CruiseSpeed:     10.3,     // m/s (20 knots)
                        MaxAcceleration: 0.1,      // m/s² (very slow acceleration)
                        MaxDeceleration: 0.5,      // m/s²
                        Range:           24000000, // meters (global range) - FIXED: Added missing Range field
                },
                Sensors: SensorCharacteristics{
                        HasGPS:        true,
                        HasRadar:      true,
                        HasCompass:    true,
                        RadarRange:    50000, // 50km navigation radar
                        OpticalRange:  20000, // 20km
                        InfraredRange: 10000, // 10km
                },
                Operational: OperationalCharacteristics{
                        Range:         24000000, // meters (global range)
                        CrewCapacity:  25,
                        CargoCapacity: 24000, // containers
                },
        }

        config := &amp;PlatformConfiguration{
                ID:            id,
                Type:          "maritime",
                Name:          shipName,
                StartPosition: startPos,
        }

        platform := &amp;UniversalPlatform{
                ID:           id,
                PlatformType: PlatformTypeMaritime,
                TypeDef:      typeDef,
                Config:       config,
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                        Physics: PhysicsState{
                                Position: startPos,
                                Mass:     mass,
                        },
                },
                CallSign:      fmt.Sprintf("CARGO%s", id[len(id)-3:]),
                FuelRemaining: 15000000,
                MissionTime:   0,
                SystemStatus: SystemStatus{
                        PowerSystem:         SystemState{Operational: true, Efficiency: 1.0},
                        PropulsionSystem:    SystemState{Operational: true, Efficiency: 0.92},
                        NavigationSystem:    SystemState{Operational: true, Efficiency: 1.0},
                        CommunicationSystem: SystemState{Operational: true, Efficiency: 0.96},
                        SensorSystem:        SystemState{Operational: true, Efficiency: 0.98},
                        FuelSystem:          SystemState{Operational: true, Efficiency: 1.0},
                        WeaponStatus:        "N/A", // Commercial vessel
                },
                lastPosition: startPos,
                acceleration: 0,
        }

        return platform
}</span>

// Utility functions for platform creation

// CreatePlatformFromConfig creates a UniversalPlatform from configuration data
func CreatePlatformFromConfig(config map[string]interface{}) (*UniversalPlatform, error) <span class="cov8" title="1">{
        // This would parse configuration and create appropriate platform
        // Implementation would depend on configuration format
        // For now, return a basic platform

        id, ok := config["id"].(string)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing or invalid platform ID")
        }</span>

        <span class="cov8" title="1">platformType, ok := config["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing or invalid platform type")
        }</span>

        <span class="cov8" title="1">var pos Position
        if posData, ok := config["position"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if lat, ok := posData["latitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Latitude = lat
                }</span>
                <span class="cov8" title="1">if lon, ok := posData["longitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Longitude = lon
                }</span>
                <span class="cov8" title="1">if alt, ok := posData["altitude"].(float64); ok </span><span class="cov8" title="1">{
                        pos.Altitude = alt
                }</span>
        }

        // Create basic platform based on type
        <span class="cov8" title="1">switch platformType </span>{
        case "airborne":<span class="cov8" title="1">
                return NewBoeing737_800Universal(id, id, pos), nil</span>
        case "land":<span class="cov0" title="0">
                return NewCivilianCarUniversal(id, "Generic Car", pos), nil</span>
        case "maritime":<span class="cov0" title="0">
                return NewContainerShipUniversal(id, "Generic Ship", pos), nil</span>
        case "space":<span class="cov0" title="0">
                return NewStarlinkSatelliteUniversal(id, id, pos), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown platform type: %s", platformType)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// LandPlatform represents ground vehicles and installations
type LandPlatform struct {
        // Base identification
        ID       string
        Class    string // Vehicle/platform type
        Name     string // Unit designation
        CallSign string

        // Current state
        State PlatformState

        // Land characteristics
        MaxSpeed     float64 // m/s
        CruiseSpeed  float64 // m/s
        MaxGradient  float64 // degrees (max slope)
        FuelCapacity float64 // liters
        Range        float64 // meters

        // Physical characteristics
        Length float64 // meters
        Width  float64 // meters
        Height float64 // meters
        Mass   float64 // kg

        // Navigation
        Destination *Position
        Route       []Position
}

// Core Platform interface implementation
func (l *LandPlatform) GetID() string           <span class="cov0" title="0">{ return l.ID }</span>
func (l *LandPlatform) GetType() PlatformType   <span class="cov0" title="0">{ return PlatformTypeLand }</span>
func (l *LandPlatform) GetClass() string        <span class="cov0" title="0">{ return l.Class }</span>
func (l *LandPlatform) GetName() string         <span class="cov0" title="0">{ return l.Name }</span>
func (l *LandPlatform) GetCallSign() string     <span class="cov0" title="0">{ return l.CallSign }</span>
func (l *LandPlatform) GetState() PlatformState <span class="cov0" title="0">{ return l.State }</span>
func (l *LandPlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return l.MaxSpeed }</span>
func (l *LandPlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return 0 }</span> // Ground vehicles
func (l *LandPlatform) GetLength() float64      <span class="cov0" title="0">{ return l.Length }</span>
func (l *LandPlatform) GetWidth() float64       <span class="cov0" title="0">{ return l.Width }</span>
func (l *LandPlatform) GetHeight() float64      <span class="cov0" title="0">{ return l.Height }</span>
func (l *LandPlatform) GetMass() float64        <span class="cov0" title="0">{ return l.Mass }</span>

func (l *LandPlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        l.State = state
}</span>

func (l *LandPlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        l.Destination = &amp;pos
        return nil
}</span>

func (l *LandPlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        if l.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Simple movement towards destination
        <span class="cov0" title="0">dt := deltaTime.Seconds()

        // Calculate distance and bearing to destination
        deltaLat := l.Destination.Latitude - l.State.Position.Latitude
        deltaLon := l.Destination.Longitude - l.State.Position.Longitude

        distance := math.Sqrt(deltaLat*deltaLat + deltaLon*deltaLon)

        if distance &lt; 0.00001 </span><span class="cov0" title="0">{ // Close enough (very small threshold for ground vehicles)
                l.Destination = nil
                return nil
        }</span>

        // Move towards destination at cruise speed
        <span class="cov0" title="0">speed := math.Min(l.CruiseSpeed, l.MaxSpeed)

        // Update position
        factor := (speed * dt) / (distance * 111320) // rough meters per degree
        l.State.Position.Latitude += deltaLat * factor
        l.State.Position.Longitude += deltaLon * factor
        // Note: Altitude changes would be based on terrain, keeping simple for now

        // Update heading and speed
        l.State.Heading = math.Atan2(deltaLon, deltaLat) * 180 / math.Pi
        if l.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                l.State.Heading += 360
        }</span>
        <span class="cov0" title="0">l.State.Speed = speed
        l.State.LastUpdated = time.Now()

        return nil</span>
}

// Land platform factory functions for real-world platforms

// NewM1A2Abrams creates an M1A2 Abrams main battle tank
func NewM1A2Abrams(id, unitDesignation string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        return &amp;LandPlatform{
                ID:       id,
                Class:    "M1A2 Abrams MBT",
                Name:     unitDesignation,
                CallSign: fmt.Sprintf("ARMOR%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     20,     // m/s (45 mph)
                CruiseSpeed:  13.4,   // m/s (30 mph)
                MaxGradient:  30,     // degrees
                FuelCapacity: 1900,   // liters
                Range:        426000, // meters (265 miles)
                Length:       9.8,    // meters
                Width:        3.7,    // meters
                Height:       2.4,    // meters
                Mass:         62000,  // kg
        }
}</span>

// NewHMMWV creates a High Mobility Multipurpose Wheeled Vehicle (Humvee)
func NewHMMWV(id, unitDesignation string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        return &amp;LandPlatform{
                ID:       id,
                Class:    "HMMWV",
                Name:     unitDesignation,
                CallSign: fmt.Sprintf("HUMVEE%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     31,     // m/s (70 mph)
                CruiseSpeed:  22.4,   // m/s (50 mph)
                MaxGradient:  40,     // degrees
                FuelCapacity: 95,     // liters
                Range:        480000, // meters (300 miles)
                Length:       4.6,    // meters
                Width:        2.2,    // meters
                Height:       1.8,    // meters
                Mass:         5900,   // kg
        }
}</span>

// NewFreightlinerCascadia creates a commercial freight truck
func NewFreightlinerCascadia(id, truckNumber string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        return &amp;LandPlatform{
                ID:       id,
                Class:    "Freightliner Cascadia",
                Name:     truckNumber,
                CallSign: fmt.Sprintf("TRUCK%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     33.5,    // m/s (75 mph)
                CruiseSpeed:  29.1,    // m/s (65 mph)
                MaxGradient:  15,      // degrees
                FuelCapacity: 1135,    // liters (300 gallons)
                Range:        1600000, // meters (1000 miles)
                Length:       6.1,     // meters (tractor only)
                Width:        2.6,     // meters
                Height:       4.0,     // meters
                Mass:         16000,   // kg (tractor only)
        }
}</span>

// NewPolicePatrolCar creates a police patrol vehicle
func NewPolicePatrolCar(id, unitNumber string, startPos Position) *LandPlatform <span class="cov0" title="0">{
        return &amp;LandPlatform{
                ID:       id,
                Class:    "Ford Police Interceptor",
                Name:     fmt.Sprintf("Unit %s", unitNumber),
                CallSign: fmt.Sprintf("PATROL%s", unitNumber),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     50,     // m/s (112 mph)
                CruiseSpeed:  26.8,   // m/s (60 mph)
                MaxGradient:  25,     // degrees
                FuelCapacity: 68,     // liters (18 gallons)
                Range:        640000, // meters (400 miles)
                Length:       5.2,    // meters
                Width:        1.9,    // meters
                Height:       1.5,    // meters
                Mass:         2000,   // kg
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// MaritimePlatform represents naval and commercial vessels
type MaritimePlatform struct {
        // Base identification
        ID       string
        Class    string // Ship class/model
        Name     string // Ship name
        CallSign string

        // Current state
        State PlatformState

        // Maritime characteristics
        MaxSpeed     float64 // m/s
        CruiseSpeed  float64 // m/s
        Draft        float64 // meters (depth below waterline)
        Displacement float64 // tonnes
        Range        float64 // nautical miles (required by tests)

        // Physical characteristics
        Length float64 // meters
        Width  float64 // beam in meters
        Height float64 // meters (above waterline)
        Mass   float64 // kg

        // Navigation
        Destination *Position
        Route       []Position
}

// Core Platform interface implementation
func (m *MaritimePlatform) GetID() string           <span class="cov0" title="0">{ return m.ID }</span>
func (m *MaritimePlatform) GetType() PlatformType   <span class="cov0" title="0">{ return PlatformTypeMaritime }</span>
func (m *MaritimePlatform) GetClass() string        <span class="cov0" title="0">{ return m.Class }</span>
func (m *MaritimePlatform) GetName() string         <span class="cov0" title="0">{ return m.Name }</span>
func (m *MaritimePlatform) GetCallSign() string     <span class="cov0" title="0">{ return m.CallSign }</span>
func (m *MaritimePlatform) GetState() PlatformState <span class="cov0" title="0">{ return m.State }</span>
func (m *MaritimePlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return m.MaxSpeed }</span>
func (m *MaritimePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return 0 }</span> // Ships don't fly
func (m *MaritimePlatform) GetLength() float64      <span class="cov0" title="0">{ return m.Length }</span>
func (m *MaritimePlatform) GetWidth() float64       <span class="cov0" title="0">{ return m.Width }</span>
func (m *MaritimePlatform) GetHeight() float64      <span class="cov0" title="0">{ return m.Height }</span>
func (m *MaritimePlatform) GetMass() float64        <span class="cov0" title="0">{ return m.Mass }</span>

func (m *MaritimePlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        m.State = state
        // Keep ships at sea level
        m.State.Position.Altitude = 0
}</span>

func (m *MaritimePlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        // Force maritime platforms to sea level
        pos.Altitude = 0
        m.Destination = &amp;pos
        return nil
}</span>

func (m *MaritimePlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        if m.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Simple movement towards destination
        <span class="cov0" title="0">dt := deltaTime.Seconds()

        // Calculate distance and bearing to destination
        deltaLat := m.Destination.Latitude - m.State.Position.Latitude
        deltaLon := m.Destination.Longitude - m.State.Position.Longitude

        distance := math.Sqrt(deltaLat*deltaLat + deltaLon*deltaLon)

        if distance &lt; 0.0001 </span><span class="cov0" title="0">{ // Close enough (smaller threshold for ships)
                m.Destination = nil
                return nil
        }</span>

        // Move towards destination at cruise speed
        <span class="cov0" title="0">speed := math.Min(m.CruiseSpeed, m.MaxSpeed)

        // Update position
        factor := (speed * dt) / (distance * 111320) // rough meters per degree
        m.State.Position.Latitude += deltaLat * factor
        m.State.Position.Longitude += deltaLon * factor
        m.State.Position.Altitude = 0 // Always at sea level

        // Update heading and speed
        m.State.Heading = math.Atan2(deltaLon, deltaLat) * 180 / math.Pi
        if m.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                m.State.Heading += 360
        }</span>
        <span class="cov0" title="0">m.State.Speed = speed
        m.State.LastUpdated = time.Now()

        return nil</span>
}

// Ship factory functions for real-world platforms

// NewArleighBurkeDestroyer creates an Arleigh Burke-class destroyer (US Navy)
func NewArleighBurkeDestroyer(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0 // Ensure at sea level
        return &amp;MaritimePlatform{
                ID:       id,
                Class:    "Arleigh Burke-class",
                Name:     fmt.Sprintf("USS %s", shipName),
                CallSign: fmt.Sprintf("NAVY%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     15.4,    // m/s (30+ knots)
                CruiseSpeed:  10.3,    // m/s (20 knots)
                Draft:        6.3,     // meters
                Displacement: 9200,    // tonnes
                Length:       155,     // meters
                Width:        20,      // meters
                Height:       18,      // meters
                Mass:         9200000, // kg
                Range:        4000,    // nautical miles
        }
}</span>

// NewTiconderogaCruiser creates a Ticonderoga-class cruiser (US Navy)
func NewTiconderogaCruiser(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0
        return &amp;MaritimePlatform{
                ID:       id,
                Class:    "Ticonderoga-class",
                Name:     fmt.Sprintf("USS %s", shipName),
                CallSign: fmt.Sprintf("NAVY%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     15.4,    // m/s (30+ knots)
                CruiseSpeed:  10.3,    // m/s (20 knots)
                Draft:        10.2,    // meters
                Displacement: 9800,    // tonnes
                Length:       173,     // meters
                Width:        16.8,    // meters
                Height:       20,      // meters
                Mass:         9800000, // kg
                Range:        5000,    // nautical miles
        }
}</span>

// NewContainerShip creates a large container vessel (commercial)
func NewContainerShip(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0
        return &amp;MaritimePlatform{
                ID:       id,
                Class:    "Ultra Large Container Vessel",
                Name:     shipName,
                CallSign: fmt.Sprintf("CARGO%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     12.9,      // m/s (25 knots)
                CruiseSpeed:  10.3,      // m/s (20 knots)
                Draft:        16,        // meters
                Displacement: 200000,    // tonnes
                Length:       400,       // meters
                Width:        59,        // meters
                Height:       73,        // meters
                Mass:         200000000, // kg
                Range:        10000,     // nautical miles
        }
}</span>

// NewOilTanker creates a large crude oil tanker (commercial)
func NewOilTanker(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0
        return &amp;MaritimePlatform{
                ID:       id,
                Class:    "Very Large Crude Carrier",
                Name:     shipName,
                CallSign: fmt.Sprintf("TANKER%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     8.2,       // m/s (16 knots)
                CruiseSpeed:  6.7,       // m/s (13 knots)
                Draft:        22,        // meters
                Displacement: 320000,    // tonnes
                Length:       330,       // meters
                Width:        60,        // meters
                Height:       35,        // meters
                Mass:         320000000, // kg
                Range:        12000,     // nautical miles
        }
}</span>

// NewCoastGuardCutter creates a Coast Guard cutter
func NewCoastGuardCutter(id, shipName string, startPos Position) *MaritimePlatform <span class="cov0" title="0">{
        startPos.Altitude = 0
        return &amp;MaritimePlatform{
                ID:       id,
                Class:    "Legend-class Cutter",
                Name:     fmt.Sprintf("USCGC %s", shipName),
                CallSign: fmt.Sprintf("COASTGUARD%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     0,
                        Speed:       0,
                        LastUpdated: time.Now(),
                },
                MaxSpeed:     14.4,    // m/s (28 knots)
                CruiseSpeed:  10.3,    // m/s (20 knots)
                Draft:        6.7,     // meters
                Displacement: 4500,    // tonnes
                Length:       127,     // meters
                Width:        16.4,    // meters
                Height:       15,      // meters
                Mass:         4500000, // kg
                Range:        3000,    // nautical miles
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// PlatformType represents the category of platform
type PlatformType string

const (
        PlatformTypeAirborne PlatformType = "airborne"
        PlatformTypeMaritime PlatformType = "maritime"
        PlatformTypeLand     PlatformType = "land"
        PlatformTypeSpace    PlatformType = "space"
)

// Position represents a 3D position in space
type Position struct {
        Latitude  float64 `json:"latitude"`  // degrees
        Longitude float64 `json:"longitude"` // degrees
        Altitude  float64 `json:"altitude"`  // meters above sea level
}

// Velocity represents 3D velocity vector
type Velocity struct {
        North float64 `json:"north"` // m/s
        East  float64 `json:"east"`  // m/s
        Up    float64 `json:"up"`    // m/s
}

// Acceleration represents 3D acceleration vector
type Acceleration struct {
        North float64 `json:"north"` // m/s²
        East  float64 `json:"east"`  // m/s²
        Up    float64 `json:"up"`    // m/s²
}

// Attitude represents rotational orientation in 3D space
type Attitude struct {
        Roll  float64 `json:"roll"`  // degrees, rotation around longitudinal axis
        Pitch float64 `json:"pitch"` // degrees, rotation around lateral axis
        Yaw   float64 `json:"yaw"`   // degrees, rotation around vertical axis (same as heading)
}

// AngularVelocity represents rotational rates
type AngularVelocity struct {
        RollRate  float64 `json:"roll_rate"`  // degrees/second
        PitchRate float64 `json:"pitch_rate"` // degrees/second
        YawRate   float64 `json:"yaw_rate"`   // degrees/second
}

// AngularAcceleration represents rotational accelerations
type AngularAcceleration struct {
        RollAccel  float64 `json:"roll_accel"`  // degrees/second²
        PitchAccel float64 `json:"pitch_accel"` // degrees/second²
        YawAccel   float64 `json:"yaw_accel"`   // degrees/second²
}

// PhysicsState represents comprehensive 3D physics state
type PhysicsState struct {
        Position            Position            `json:"position"`
        Velocity            Velocity            `json:"velocity"`
        Acceleration        Acceleration        `json:"acceleration"`
        Attitude            Attitude            `json:"attitude"`
        AngularVelocity     AngularVelocity     `json:"angular_velocity"`
        AngularAcceleration AngularAcceleration `json:"angular_acceleration"`
        Mass                float64             `json:"mass"`              // kg
        MomentOfInertia     MomentOfInertia     `json:"moment_of_inertia"` // kg⋅m²
        Forces              Forces              `json:"forces"`            // N
        Torques             Torques             `json:"torques"`           // N⋅m
}

// MomentOfInertia represents rotational inertia in 3 axes
type MomentOfInertia struct {
        Ixx float64 `json:"ixx"` // kg⋅m² around x-axis (roll)
        Iyy float64 `json:"iyy"` // kg⋅m² around y-axis (pitch)
        Izz float64 `json:"izz"` // kg⋅m² around z-axis (yaw)
}

// Forces represents applied forces in 3D
type Forces struct {
        Thrust float64 `json:"thrust"` // N, forward force
        Drag   float64 `json:"drag"`   // N, opposing motion
        Lift   float64 `json:"lift"`   // N, upward force (aircraft)
        Weight float64 `json:"weight"` // N, gravitational force
        Normal float64 `json:"normal"` // N, surface reaction force
}

// Torques represents applied torques in 3D
type Torques struct {
        Roll  float64 `json:"roll"`  // N⋅m around longitudinal axis
        Pitch float64 `json:"pitch"` // N⋅m around lateral axis
        Yaw   float64 `json:"yaw"`   // N⋅m around vertical axis
}

// PlatformState represents the current state of a platform (backwards compatible)
type PlatformState struct {
        ID          string    `json:"id"`
        Position    Position  `json:"position"`
        Velocity    Velocity  `json:"velocity"`
        Heading     float64   `json:"heading"` // degrees, 0-360 (maintained for compatibility)
        Speed       float64   `json:"speed"`   // m/s (maintained for compatibility)
        Roll        float64   `json:"roll"`    // degrees, banking angle for aircraft
        LastUpdated time.Time `json:"lastUpdated"`

        // Enhanced physics state
        Physics PhysicsState `json:"physics"`
}

// PerformanceCharacteristics holds configurable performance data
type PerformanceCharacteristics struct {
        MaxSpeed        float64 `yaml:"max_speed"`
        CruiseSpeed     float64 `yaml:"cruise_speed"`
        MaxAltitude     float64 `yaml:"max_altitude,omitempty"`
        FuelConsumption float64 `yaml:"fuel_consumption"`
        TurningRadius   float64 `yaml:"turning_radius,omitempty"`
        Acceleration    float64 `yaml:"acceleration"`
        MaxGradient     float64 `yaml:"max_gradient,omitempty"`
        ClimbRate       float64 `yaml:"climb_rate,omitempty"`
        StallSpeed      float64 `yaml:"stall_speed,omitempty"`
        Range           float64 `yaml:"range"`

        // Enhanced performance characteristics
        MaxAcceleration   float64 `yaml:"max_acceleration,omitempty"`     // m/s²
        MaxDeceleration   float64 `yaml:"max_deceleration,omitempty"`     // m/s²
        MaxRollRate       float64 `yaml:"max_roll_rate,omitempty"`        // degrees/second
        MaxPitchRate      float64 `yaml:"max_pitch_rate,omitempty"`       // degrees/second
        MaxYawRate        float64 `yaml:"max_yaw_rate,omitempty"`         // degrees/second
        MaxBankAngle      float64 `yaml:"max_bank_angle,omitempty"`       // degrees
        MaxPitchAngle     float64 `yaml:"max_pitch_angle,omitempty"`      // degrees
        MaxThrustToWeight float64 `yaml:"max_thrust_to_weight,omitempty"` // ratio
        MaxLoadFactor     float64 `yaml:"max_load_factor,omitempty"`      // g-force

        // Control surface effectiveness
        ElevatorAuthority float64 `yaml:"elevator_authority,omitempty"` // degrees
        RudderAuthority   float64 `yaml:"rudder_authority,omitempty"`   // degrees
        AileronAuthority  float64 `yaml:"aileron_authority,omitempty"`  // degrees

        // Orbital characteristics for space platforms
        OrbitalVelocity float64 `yaml:"orbital_velocity,omitempty"`
        OrbitalPeriod   float64 `yaml:"orbital_period,omitempty"`
        OrbitalAltitude float64 `yaml:"orbital_altitude,omitempty"`
        Inclination     float64 `yaml:"inclination,omitempty"`
        Eccentricity    float64 `yaml:"eccentricity,omitempty"`
}

// PhysicalCharacteristics holds physical properties
type PhysicalCharacteristics struct {
        Length          float64 `yaml:"length"`
        Width           float64 `yaml:"width"`
        Height          float64 `yaml:"height"`
        Mass            float64 `yaml:"mass"`
        FuelCapacity    float64 `yaml:"fuel_capacity,omitempty"`
        Draft           float64 `yaml:"draft,omitempty"`            // Maritime
        GroundClearance float64 `yaml:"ground_clearance,omitempty"` // Land
        SolarPanelArea  float64 `yaml:"solar_panel_area,omitempty"` // Space

        // Enhanced physical characteristics for realistic physics
        CenterOfGravity CenterOfGravity `yaml:"center_of_gravity,omitempty"`
        EmptyWeight     float64         `yaml:"empty_weight,omitempty"` // kg
        MaxWeight       float64         `yaml:"max_weight,omitempty"`   // kg
        WingArea        float64         `yaml:"wing_area,omitempty"`    // m² (aircraft)
        WetArea         float64         `yaml:"wet_area,omitempty"`     // m² (ships)
        FrontalArea     float64         `yaml:"frontal_area,omitempty"` // m² (land vehicles)
}

// CenterOfGravity represents the center of mass location
type CenterOfGravity struct {
        X float64 `yaml:"x"` // meters from nose/bow/front
        Y float64 `yaml:"y"` // meters from centerline (positive = starboard/right)
        Z float64 `yaml:"z"` // meters from keel/ground (positive = up)
}

// CallsignConfiguration defines how callsigns are generated
type CallsignConfiguration struct {
        Prefix      string   `yaml:"prefix"`
        Format      string   `yaml:"format"`
        NumberRange [2]int   `yaml:"number_range,omitempty"`
        Names       []string `yaml:"names,omitempty"`
        Modules     []string `yaml:"modules,omitempty"`
}

// PlatformTypeDefinition defines the characteristics of a platform type
type PlatformTypeDefinition struct {
        Class        string                     `yaml:"class"`
        Category     string                     `yaml:"category"`
        Performance  PerformanceCharacteristics `yaml:"performance"`
        Physical     PhysicalCharacteristics    `yaml:"physical"`
        Operational  OperationalCharacteristics `yaml:"operational"`
        Sensors      SensorCharacteristics      `yaml:"sensors"`
        CallsignConf CallsignConfiguration      `yaml:"callsign_config"`
}

// SensorCharacteristics defines sensor capabilities
type SensorCharacteristics struct {
        HasGPS        bool    `yaml:"has_gps"`
        HasRadar      bool    `yaml:"has_radar"`
        HasCompass    bool    `yaml:"has_compass"`
        RadarRange    float64 `yaml:"radar_range,omitempty"`    // meters
        SonarRange    float64 `yaml:"sonar_range,omitempty"`    // meters
        OpticalRange  float64 `yaml:"optical_range,omitempty"`  // meters
        InfraredRange float64 `yaml:"infrared_range,omitempty"` // meters
}

// MissionConfiguration defines platform-specific mission parameters
type MissionConfiguration struct {
        Type       string                 `yaml:"type"`
        Parameters map[string]interface{} `yaml:",inline"`
}

// PlatformConfiguration represents a configured platform instance
type PlatformConfiguration struct {
        ID            string               `yaml:"id"`
        Type          string               `yaml:"type"`
        Name          string               `yaml:"name"`
        StartPosition Position             `yaml:"start_position"`
        Mission       MissionConfiguration `yaml:"mission"`
}

// UniversalPlatform implements the Platform interface using configuration data
type UniversalPlatform struct {
        ID           string                  `json:"id"`
        PlatformType PlatformType            `json:"platform_type"`
        TypeDef      *PlatformTypeDefinition `json:"type_def"`
        Config       *PlatformConfiguration  `json:"config"`
        State        PlatformState           `json:"state"`
        CallSign     string                  `json:"call_sign"`

        // Navigation
        Destination *Position  `json:"destination,omitempty"`
        Route       []Position `json:"route,omitempty"`

        // Runtime state
        FuelRemaining float64       `json:"fuel_remaining"`
        MissionTime   time.Duration `json:"mission_time"`
        SystemStatus  SystemStatus  `json:"system_status"`

        // Physics state
        lastPosition  Position `json:"-"`    // Internal field, don't serialize
        acceleration  float64  `json:"-"`    // Internal field, don't serialize
        Mass          float64  `json:"mass"` // Mass for physics calculations
        AngularForces struct { // Angular forces for attitude control
                X float64 `json:"x"`
                Y float64 `json:"y"`
                Z float64 `json:"z"`
        } `json:"angular_forces"`
}

// SystemStatus represents the operational status of various platform systems
type SystemStatus struct {
        PowerSystem         SystemState `json:"power_system"`
        PropulsionSystem    SystemState `json:"propulsion_system"`
        NavigationSystem    SystemState `json:"navigation_system"`
        CommunicationSystem SystemState `json:"communication_system"`
        SensorSystem        SystemState `json:"sensor_system"`
        WeaponSystem        SystemState `json:"weapon_system,omitempty"`
        LifeSupport         SystemState `json:"life_support,omitempty"`
        FuelSystem          SystemState `json:"fuel_system"`
        WeaponStatus        string      `json:"weapon_status"` // "ARMED", "SAFE", "N/A"
}

// SystemState represents the operational state of a system
type SystemState struct {
        Operational bool      `json:"operational"`
        Efficiency  float64   `json:"efficiency"` // 0.0 to 1.0
        LastCheck   time.Time `json:"last_check"`
        Notes       string    `json:"notes,omitempty"`
}

// Platform interface implementation
func (up *UniversalPlatform) GetID() string <span class="cov8" title="1">{
        return up.ID
}</span>

func (up *UniversalPlatform) GetType() PlatformType <span class="cov8" title="1">{
        return up.PlatformType
}</span>

func (up *UniversalPlatform) GetClass() string <span class="cov8" title="1">{
        return up.TypeDef.Class
}</span>

func (up *UniversalPlatform) GetName() string <span class="cov8" title="1">{
        return up.Config.Name
}</span>

func (up *UniversalPlatform) GetCallSign() string <span class="cov0" title="0">{
        return up.CallSign
}</span>

func (up *UniversalPlatform) GetState() PlatformState <span class="cov8" title="1">{
        return up.State
}</span>

func (up *UniversalPlatform) UpdateState(state PlatformState) <span class="cov8" title="1">{
        up.State = state
}</span>

func (up *UniversalPlatform) GetMaxSpeed() float64 <span class="cov8" title="1">{
        return up.TypeDef.Performance.MaxSpeed
}</span>

func (up *UniversalPlatform) GetMaxAltitude() float64 <span class="cov8" title="1">{
        if up.TypeDef.Performance.OrbitalAltitude &gt; 0 </span><span class="cov0" title="0">{
                return up.TypeDef.Performance.OrbitalAltitude
        }</span>
        <span class="cov8" title="1">return up.TypeDef.Performance.MaxAltitude</span>
}

func (up *UniversalPlatform) GetLength() float64 <span class="cov8" title="1">{
        return up.TypeDef.Physical.Length
}</span>

func (up *UniversalPlatform) GetWidth() float64 <span class="cov0" title="0">{
        return up.TypeDef.Physical.Width
}</span>

func (up *UniversalPlatform) GetHeight() float64 <span class="cov0" title="0">{
        return up.TypeDef.Physical.Height
}</span>

func (up *UniversalPlatform) GetMass() float64 <span class="cov8" title="1">{
        return up.TypeDef.Physical.Mass
}</span>

func (up *UniversalPlatform) SetDestination(pos Position) error <span class="cov8" title="1">{
        up.Destination = &amp;pos
        return nil
}</span>

// GetPerformanceCharacteristic allows access to any performance parameter
func (up *UniversalPlatform) GetPerformanceCharacteristic(name string) (float64, error) <span class="cov8" title="1">{
        switch name </span>{
        case "cruise_speed":<span class="cov8" title="1">
                return up.TypeDef.Performance.CruiseSpeed, nil</span>
        case "fuel_consumption":<span class="cov8" title="1">
                return up.TypeDef.Performance.FuelConsumption, nil</span>
        case "turning_radius":<span class="cov8" title="1">
                return up.TypeDef.Performance.TurningRadius, nil</span>
        case "acceleration":<span class="cov8" title="1">
                return up.TypeDef.Performance.Acceleration, nil</span>
        case "climb_rate":<span class="cov8" title="1">
                return up.TypeDef.Performance.ClimbRate, nil</span>
        case "orbital_period":<span class="cov8" title="1">
                return up.TypeDef.Performance.OrbitalPeriod, nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("unknown performance characteristic: %s", name)</span>
        }
}

// Update updates the platform's state for the given time step
func (up *UniversalPlatform) Update(deltaTime time.Duration) error <span class="cov8" title="1">{
        deltaSeconds := deltaTime.Seconds()

        // Update mission time
        up.MissionTime += deltaTime

        // Consume fuel if engines are running
        if up.State.Speed &gt; 0 || up.Destination != nil </span><span class="cov8" title="1">{
                fuelRate := up.TypeDef.Performance.FuelConsumption
                if fuelRate &gt; 0 </span><span class="cov8" title="1">{
                        fuelConsumed := fuelRate * deltaSeconds
                        up.FuelRemaining = math.Max(0, up.FuelRemaining-fuelConsumed)
                }</span>
        }

        // If no destination but has velocity, update position from current velocity
        <span class="cov8" title="1">if up.Destination == nil </span><span class="cov8" title="1">{
                if up.State.Velocity.North != 0 || up.State.Velocity.East != 0 || up.State.Velocity.Up != 0 </span><span class="cov8" title="1">{
                        up.updatePositionFromVelocity(deltaSeconds)
                        up.State.LastUpdated = time.Now()
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Update based on platform type
        <span class="cov8" title="1">switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov8" title="1">
                return up.updateAirborneMovement(deltaSeconds)</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                return up.updateMaritimeMovement(deltaSeconds)</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                return up.updateLandMovement(deltaSeconds)</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                return up.updateSpaceMovement(deltaSeconds)</span>
        default:<span class="cov0" title="0">
                return up.updateGenericMovement(deltaSeconds)</span>
        }
}

func (up *UniversalPlatform) updateAirborneMovement(deltaSeconds float64) error <span class="cov8" title="1">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                // Even without destination, update position if there's velocity
                if up.State.Velocity.North != 0 || up.State.Velocity.East != 0 || up.State.Velocity.Up != 0 </span><span class="cov0" title="0">{
                        up.updatePositionFromVelocity(deltaSeconds)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Enhanced aircraft movement with realistic climb rates and banking
        <span class="cov8" title="1">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 100 </span><span class="cov0" title="0">{ // 100 meter threshold
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Calculate desired heading
        <span class="cov8" title="1">desiredHeading := up.calculateBearing(*up.Destination)

        // Apply turning constraints
        if up.TypeDef.Performance.TurningRadius &gt; 0 </span><span class="cov0" title="0">{
                up.applyTurningConstraints(desiredHeading, deltaSeconds)
        }</span> else<span class="cov8" title="1"> {
                up.State.Heading = desiredHeading
        }</span>

        // Calculate altitude change with climb rate constraints
        <span class="cov8" title="1">altitudeDiff := up.Destination.Altitude - up.State.Position.Altitude
        if math.Abs(altitudeDiff) &gt; 10 </span><span class="cov0" title="0">{
                climbRate := up.TypeDef.Performance.ClimbRate
                if climbRate == 0 </span><span class="cov0" title="0">{
                        climbRate = 10.0 // Default 10 m/s
                }</span>

                <span class="cov0" title="0">maxAltChange := climbRate * deltaSeconds
                if math.Abs(altitudeDiff) &lt;= maxAltChange </span><span class="cov0" title="0">{
                        up.State.Position.Altitude = up.Destination.Altitude
                        up.State.Velocity.Up = 0
                }</span> else<span class="cov0" title="0"> if altitudeDiff &gt; 0 </span><span class="cov0" title="0">{
                        up.State.Position.Altitude += maxAltChange
                        up.State.Velocity.Up = climbRate
                }</span> else<span class="cov0" title="0"> {
                        up.State.Position.Altitude -= maxAltChange
                        up.State.Velocity.Up = -climbRate
                }</span>
        }

        // Apply acceleration constraints
        <span class="cov8" title="1">targetSpeed := up.TypeDef.Performance.CruiseSpeed
        if up.TypeDef.Performance.Acceleration &gt; 0 </span><span class="cov8" title="1">{
                up.applyAccelerationConstraints(targetSpeed, deltaSeconds)
        }</span> else<span class="cov0" title="0"> {
                up.State.Speed = targetSpeed
        }</span>

        // Update position based on current heading and speed
        <span class="cov8" title="1">up.updatePositionFromHeadingAndSpeed(deltaSeconds)

        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateMaritimeMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Maritime movement with ship dynamics
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 10 </span><span class="cov0" title="0">{ // 10 meter threshold for ships
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Ships have turning constraints based on their size and speed
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)

        // Use turning radius for maritime movement calculations
        if up.TypeDef.Performance.TurningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius := up.TypeDef.Physical.Length * 5 // Default: 5x ship length
                up.TypeDef.Performance.TurningRadius = turningRadius
        }</span>

        <span class="cov0" title="0">up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Calculate movement with maritime characteristics
        targetSpeed := up.TypeDef.Performance.MaxSpeed * 0.9 // Ships can maintain near max speed in open water

        // Apply acceleration with maritime characteristics
        acceleration := up.TypeDef.Performance.Acceleration
        if acceleration == 0 </span><span class="cov0" title="0">{
                acceleration = 0.5 // Default slow acceleration for ships
        }</span>
        <span class="cov0" title="0">up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        up.updatePositionFromHeadingAndSpeed(deltaSeconds)
        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateLandMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Land movement with terrain and gradient constraints
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 10 </span><span class="cov0" title="0">{ // 10 meter threshold for land vehicles
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Apply gradient constraints for altitude changes
        altitudeDiff := up.Destination.Altitude - up.State.Position.Altitude
        horizontalDist := up.calculateHorizontalDistance(*up.Destination)

        if horizontalDist &gt; 0 </span><span class="cov0" title="0">{
                gradient := math.Atan(altitudeDiff/horizontalDist) * 180.0 / math.Pi
                maxGradient := up.TypeDef.Performance.MaxGradient
                if maxGradient == 0 </span><span class="cov0" title="0">{
                        maxGradient = 30.0 // Default 30 degree max gradient
                }</span>

                <span class="cov0" title="0">if math.Abs(gradient) &gt; maxGradient </span><span class="cov0" title="0">{
                        // Reduce speed when climbing steep grades
                        up.State.Speed *= (maxGradient / math.Abs(gradient))
                }</span>
        }

        <span class="cov0" title="0">targetSpeed := up.TypeDef.Performance.CruiseSpeed
        up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        up.updatePositionFromHeadingAndSpeed(deltaSeconds)
        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateSpaceMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Space movement with orbital mechanics
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 100 </span><span class="cov0" title="0">{ // 100 meter threshold for satellites
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Satellites move in predictable orbital paths
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)

        // Space vehicles have different movement characteristics
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Calculate movement with orbital velocity
        targetSpeed := up.TypeDef.Performance.MaxSpeed * 0.8 // Most satellites maintain consistent orbital speed

        // Maintain orbital altitude
        up.State.Position.Altitude = up.TypeDef.Performance.OrbitalAltitude
        up.State.Speed = targetSpeed
        up.State.Heading = 90 // Generally eastward

        up.State.LastUpdated = time.Now()
        return nil</span>
}

func (up *UniversalPlatform) updateGenericMovement(deltaSeconds float64) error <span class="cov0" title="0">{
        if up.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Generic movement for unknown platform types
        <span class="cov0" title="0">distance := up.calculateGreatCircleDistance(*up.Destination)
        if distance &lt; 50 </span><span class="cov0" title="0">{ // 50 meter threshold
                up.State.Position = *up.Destination
                up.Destination = nil
                up.State.Speed = 0
                return nil
        }</span>

        // Calculate desired heading
        <span class="cov0" title="0">desiredHeading := up.calculateBearing(*up.Destination)
        up.applyTurningConstraints(desiredHeading, deltaSeconds)

        // Apply generic acceleration
        targetSpeed := up.TypeDef.Performance.CruiseSpeed
        up.applyAccelerationConstraints(targetSpeed, deltaSeconds)

        // Update position based on current heading and speed
        up.updatePositionFromHeadingAndSpeed(deltaSeconds)

        up.State.LastUpdated = time.Now()
        return nil</span>
}

// Physics helper functions

func (up *UniversalPlatform) calculateGreatCircleDistance(target Position) float64 <span class="cov8" title="1">{
        // Haversine formula for great circle distance
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLat := (target.Latitude - up.State.Position.Latitude) * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := 6371000.0 // meters
        distance := earthRadius * c

        // Add altitude difference
        altDiff := target.Altitude - up.State.Position.Altitude
        return math.Sqrt(distance*distance + altDiff*altDiff)
}</span>

func (up *UniversalPlatform) calculateHorizontalDistance(target Position) float64 <span class="cov8" title="1">{
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLat := (target.Latitude - up.State.Position.Latitude) * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        earthRadius := 6371000.0 // meters
        return earthRadius * c
}</span>

func (up *UniversalPlatform) calculateBearing(target Position) float64 <span class="cov8" title="1">{
        lat1 := up.State.Position.Latitude * math.Pi / 180.0
        lat2 := target.Latitude * math.Pi / 180.0
        deltaLon := (target.Longitude - up.State.Position.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        return math.Mod(bearing+360, 360) // Normalize to 0-360
}</span>

func (up *UniversalPlatform) applyTurningConstraints(desiredHeading, deltaSeconds float64) <span class="cov8" title="1">{
        currentHeading := up.State.Heading
        headingDiff := desiredHeading - currentHeading

        // Normalize heading difference to -180 to 180
        for headingDiff &gt; 180 </span><span class="cov0" title="0">{
                headingDiff -= 360
        }</span>
        <span class="cov8" title="1">for headingDiff &lt; -180 </span><span class="cov0" title="0">{
                headingDiff += 360
        }</span>

        // Calculate maximum turn rate based on turning radius and speed
        <span class="cov8" title="1">if up.TypeDef.Performance.TurningRadius &gt; 0 &amp;&amp; up.State.Speed &gt; 0 </span><span class="cov8" title="1">{
                maxTurnRate := (up.State.Speed / up.TypeDef.Performance.TurningRadius) * 180.0 / math.Pi // deg/s
                maxTurnChange := maxTurnRate * deltaSeconds

                if math.Abs(headingDiff) &lt;= maxTurnChange </span><span class="cov0" title="0">{
                        up.State.Heading = desiredHeading
                }</span> else<span class="cov8" title="1"> if headingDiff &gt; 0 </span><span class="cov8" title="1">{
                        up.State.Heading = math.Mod(currentHeading+maxTurnChange, 360)
                }</span> else<span class="cov0" title="0"> {
                        up.State.Heading = math.Mod(currentHeading-maxTurnChange+360, 360)
                }</span>
        } else<span class="cov0" title="0"> {
                up.State.Heading = desiredHeading
        }</span>
}

func (up *UniversalPlatform) applyAccelerationConstraints(targetSpeed, deltaSeconds float64) <span class="cov8" title="1">{
        speedDiff := targetSpeed - up.State.Speed

        if up.TypeDef.Performance.Acceleration &gt; 0 </span><span class="cov8" title="1">{
                maxSpeedChange := up.TypeDef.Performance.Acceleration * deltaSeconds

                if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov0" title="0">{
                        up.State.Speed = targetSpeed
                }</span> else<span class="cov8" title="1"> if speedDiff &gt; 0 </span><span class="cov8" title="1">{
                        up.State.Speed += maxSpeedChange
                }</span> else<span class="cov8" title="1"> {
                        up.State.Speed -= maxSpeedChange
                }</span>
        } else<span class="cov0" title="0"> {
                up.State.Speed = targetSpeed
        }</span>

        // Ensure speed doesn't exceed maximum
        <span class="cov8" title="1">if up.State.Speed &gt; up.TypeDef.Performance.MaxSpeed </span><span class="cov8" title="1">{
                up.State.Speed = up.TypeDef.Performance.MaxSpeed
        }</span>

        // Ensure speed isn't negative
        <span class="cov8" title="1">if up.State.Speed &lt; 0 </span><span class="cov0" title="0">{
                up.State.Speed = 0
        }</span>
}

func (up *UniversalPlatform) updatePositionFromHeadingAndSpeed(deltaSeconds float64) <span class="cov8" title="1">{
        // Convert heading to radians (0 degrees = North, 90 degrees = East)
        // Navigation heading: 0° = North, 90° = East, 180° = South, 270° = West
        headingRad := up.State.Heading * math.Pi / 180.0

        // Calculate distance moved
        distance := up.State.Speed * deltaSeconds

        // Earth radius in meters
        earthRadius := 6371000.0

        // Calculate new position using proper navigation calculations
        // North component: distance * cos(heading)
        // East component: distance * sin(heading)
        deltaLat := distance * math.Cos(headingRad) / earthRadius * 180.0 / math.Pi
        deltaLon := distance * math.Sin(headingRad) / earthRadius * 180.0 / math.Pi / math.Cos(up.State.Position.Latitude*math.Pi/180.0)

        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon

        // Calculate velocity components for state tracking
        up.State.Velocity.North = up.State.Speed * math.Cos(headingRad)
        up.State.Velocity.East = up.State.Speed * math.Sin(headingRad)
        up.State.Velocity.Up = 0 // Will be calculated separately for altitude changes
}</span>

// updatePositionFromVelocity updates position based on current velocity components
func (up *UniversalPlatform) updatePositionFromVelocity(deltaSeconds float64) <span class="cov8" title="1">{
        // Earth radius in meters
        earthRadius := 6371000.0

        // Convert North/East velocity to lat/lon changes
        deltaLat := up.State.Velocity.North * deltaSeconds / earthRadius * 180.0 / math.Pi
        deltaLon := up.State.Velocity.East * deltaSeconds / (earthRadius * math.Cos(up.State.Position.Latitude*math.Pi/180.0)) * 180.0 / math.Pi
        deltaAlt := up.State.Velocity.Up * deltaSeconds

        // Update position
        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon
        up.State.Position.Altitude += deltaAlt

        // Sync physics state
        up.State.Physics.Position = up.State.Position

        // Update heading and speed from velocity
        if up.State.Velocity.East != 0 || up.State.Velocity.North != 0 </span><span class="cov8" title="1">{
                up.State.Heading = math.Atan2(up.State.Velocity.East, up.State.Velocity.North) * 180.0 / math.Pi
                if up.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                        up.State.Heading += 360
                }</span>
        }

        <span class="cov8" title="1">up.State.Speed = math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East)</span>
}

// OperationalCharacteristics holds mission and operational data
type OperationalCharacteristics struct {
        Range             float64  `yaml:"range"`
        CrewCapacity      int      `yaml:"crew_capacity,omitempty"`
        PassengerCapacity int      `yaml:"passenger_capacity,omitempty"`
        CargoCapacity     float64  `yaml:"cargo_capacity,omitempty"`
        MissionLife       float64  `yaml:"mission_life,omitempty"`    // Space platforms
        SensorRange       float64  `yaml:"sensor_range,omitempty"`    // Naval platforms
        WeaponSystems     []string `yaml:"weapon_systems,omitempty"`  // Military platforms
        FrequencyBands    []string `yaml:"frequency_bands,omitempty"` // Satellites
}

// Platform interface defines the contract for all platform types
type Platform interface {
        // Core identification
        GetID() string
        GetType() PlatformType
        GetClass() string // e.g., "Boeing 737-800", "Arleigh Burke-class"
        GetName() string  // e.g., "United 1234", "USS Cole"

        // State management
        GetState() PlatformState
        UpdateState(state PlatformState)

        // Behavior
        Update(deltaTime time.Duration) error
        SetDestination(pos Position) error

        // Properties
        GetMaxSpeed() float64    // m/s
        GetMaxAltitude() float64 // meters (for applicable platforms)
        GetCallSign() string

        // Real-world characteristics
        GetLength() float64 // meters
        GetWidth() float64  // meters
        GetHeight() float64 // meters
        GetMass() float64   // kg

        // Enhanced 3D physics methods
        Initialize3DPhysics()
        Update3DPhysics(deltaTime time.Duration) error
        GetPhysicsState() PhysicsState
        SetPhysicsState(physics PhysicsState)
}

// Enhanced 3D physics methods for UniversalPlatform

// Initialize3DPhysics sets up realistic physics parameters based on platform type
func (up *UniversalPlatform) Initialize3DPhysics() <span class="cov0" title="0">{
        // Initialize physics state with platform characteristics
        up.State.Physics = PhysicsState{
                Position:            up.State.Position,
                Velocity:            up.State.Velocity,
                Acceleration:        Acceleration{},
                Attitude:            Attitude{Yaw: up.State.Heading},
                AngularVelocity:     AngularVelocity{},
                AngularAcceleration: AngularAcceleration{},
                Mass:                up.TypeDef.Physical.Mass,
                MomentOfInertia:     up.calculateMomentOfInertia(),
                Forces:              Forces{Weight: up.TypeDef.Physical.Mass * 9.81},
                Torques:             Torques{},
        }
}</span>

// calculateMomentOfInertia estimates moment of inertia based on platform geometry
func (up *UniversalPlatform) calculateMomentOfInertia() MomentOfInertia <span class="cov0" title="0">{
        mass := up.TypeDef.Physical.Mass
        length := up.TypeDef.Physical.Length
        width := up.TypeDef.Physical.Width
        height := up.TypeDef.Physical.Height

        // Simplified calculations for different platform types
        switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov0" title="0">
                // Aircraft approximated as elongated ellipsoid
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 20,   // Roll axis
                        Iyy: mass * (length*length + height*height) / 20, // Pitch axis
                        Izz: mass * (length*length + width*width) / 20,   // Yaw axis
                }</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                // Ship approximated as rectangular prism
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                // Vehicle approximated as box
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                // Satellite approximated as uniform distribution
                avgDim := (length + width + height) / 3
                return MomentOfInertia{
                        Ixx: mass * avgDim * avgDim / 6,
                        Iyy: mass * avgDim * avgDim / 6,
                        Izz: mass * avgDim * avgDim / 6,
                }</span>
        default:<span class="cov0" title="0">
                // Default calculation
                return MomentOfInertia{
                        Ixx: mass * (width*width + height*height) / 12,
                        Iyy: mass * (length*length + height*height) / 12,
                        Izz: mass * (length*length + width*width) / 12,
                }</span>
        }
}

// Update3DPhysics applies 3D physics simulation to the platform
func (up *UniversalPlatform) Update3DPhysics(deltaTime time.Duration) error <span class="cov8" title="1">{
        deltaSeconds := deltaTime.Seconds()

        // Apply platform-specific forces
        switch up.PlatformType </span>{
        case PlatformTypeAirborne:<span class="cov8" title="1">
                up.applyAerodynamicForces()
                up.applyThrustForces()
                up.applyGravity()</span>
        case PlatformTypeLand:<span class="cov0" title="0">
                up.applyGroundForces()
                up.applyEngineForces()
                up.applyGravity()</span>
        case PlatformTypeMaritime:<span class="cov0" title="0">
                up.applyHydrodynamicForces()
                up.applyPropulsionForces()
                up.applyBuoyancyAndGravity()</span>
        case PlatformTypeSpace:<span class="cov0" title="0">
                up.applyOrbitalForces()
                up.applyThrusterForces()</span>
        default:<span class="cov0" title="0">
                up.applyBasicForces()</span>
        }

        // Integrate forces to acceleration and velocity
        <span class="cov8" title="1">up.integrateForces(deltaSeconds)

        // Integrate velocity to position
        up.integrateVelocity(deltaSeconds)

        // Update attitude from angular forces
        up.updateAttitudeFromForces(deltaSeconds)

        // Update timestamp
        up.State.LastUpdated = time.Now()

        return nil</span>
}

// updateAircraft3DPhysics applies aircraft-specific physics
func (up *UniversalPlatform) updateAircraft3DPhysics(deltaTime float64) <span class="cov0" title="0">{
        // For aircraft, update position based on speed and heading
        up.updatePositionFromHeadingAndSpeed(deltaTime)
}</span>

// updateLand3DPhysics applies land vehicle physics
func (up *UniversalPlatform) updateLand3DPhysics(deltaTime float64) <span class="cov0" title="0">{
        // For land vehicles, update position based on speed and heading
        up.updatePositionFromHeadingAndSpeed(deltaTime)
}</span>

// updateMaritime3DPhysics applies maritime vehicle physics
func (up *UniversalPlatform) updateMaritime3DPhysics(deltaTime float64) <span class="cov0" title="0">{
        // For maritime vehicles, update position based on speed and heading
        up.updatePositionFromHeadingAndSpeed(deltaTime)
}</span>

// updateSpace3DPhysics applies space vehicle physics
func (up *UniversalPlatform) updateSpace3DPhysics(deltaTime float64) <span class="cov0" title="0">{
        // For space vehicles, update position based on speed and heading
        up.updatePositionFromHeadingAndSpeed(deltaTime)
}</span>

// Force represents a 3D force vector
type Force struct {
        X float64 `json:"x"` // Forward/backward force (N)
        Y float64 `json:"y"` // Left/right force (N)
        Z float64 `json:"z"` // Up/down force (N)
}

// Force application methods
func (up *UniversalPlatform) applyAerodynamicForces() <span class="cov8" title="1">{
        // Basic aerodynamic forces - can be expanded later
        // For now, apply basic drag opposing motion
        speed := math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East + up.State.Velocity.Up*up.State.Velocity.Up)
        if speed &gt; 0 </span><span class="cov0" title="0">{
                dragCoeff := 0.1
                up.State.Physics.Forces.Drag -= dragCoeff * speed * speed // Apply drag force
        }</span>
}

func (up *UniversalPlatform) applyThrustForces() <span class="cov8" title="1">{
        // Convert speed and heading to thrust forces
        if up.State.Speed &gt; 0 </span><span class="cov0" title="0">{
                headingRad := up.State.Heading * math.Pi / 180.0
                thrustMagnitude := up.State.Speed * 0.1 // Simple thrust model
                up.State.Physics.Forces.Thrust += thrustMagnitude * math.Sin(headingRad)
                up.State.Physics.Forces.Normal += thrustMagnitude * math.Cos(headingRad)
        }</span>
}

func (up *UniversalPlatform) applyGravity() <span class="cov8" title="1">{
        up.State.Physics.Forces.Weight = 9.81 * up.State.Physics.Mass // Standard gravity
}</span>

func (up *UniversalPlatform) applyHydrodynamicForces() <span class="cov0" title="0">{
        // Similar to aerodynamic but for water
        up.applyAerodynamicForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyPropulsionForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyBuoyancyAndGravity() <span class="cov0" title="0">{
        up.applyGravity()
        // Add buoyancy force to counteract gravity for surface vessels
        up.State.Physics.Forces.Lift += 9.81 * up.State.Physics.Mass // Simplified buoyancy
}</span>

func (up *UniversalPlatform) applyGroundForces() <span class="cov0" title="0">{
        // Ground friction and resistance
        up.applyAerodynamicForces() // Simplified friction model
}</span>

func (up *UniversalPlatform) applyEngineForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyOrbitalForces() <span class="cov0" title="0">{
        // Basic orbital mechanics - simplified
        up.applyGravity()
}</span>

func (up *UniversalPlatform) applyThrusterForces() <span class="cov0" title="0">{
        up.applyThrustForces() // Simplified for now
}</span>

func (up *UniversalPlatform) applyBasicForces() <span class="cov0" title="0">{
        up.applyThrustForces()
        up.applyGravity()
}</span>

// Force and velocity integration methods
func (up *UniversalPlatform) integrateForces(deltaTime float64) <span class="cov8" title="1">{
        if up.State.Physics.Mass &gt; 0 </span><span class="cov8" title="1">{
                // F = ma, so a = F/m
                up.State.Physics.Acceleration.North = up.State.Physics.Forces.Thrust / up.State.Physics.Mass
                up.State.Physics.Acceleration.East = up.State.Physics.Forces.Normal / up.State.Physics.Mass
                up.State.Physics.Acceleration.Up = up.State.Physics.Forces.Lift / up.State.Physics.Mass

                // Integrate acceleration to velocity
                up.State.Physics.Velocity.North += up.State.Physics.Acceleration.North * deltaTime
                up.State.Physics.Velocity.East += up.State.Physics.Acceleration.East * deltaTime
                up.State.Physics.Velocity.Up += up.State.Physics.Acceleration.Up * deltaTime

                // Reset forces for next iteration
                up.State.Physics.Forces.Thrust = 0
                up.State.Physics.Forces.Normal = 0
                up.State.Physics.Forces.Lift = 0
        }</span>
}

func (up *UniversalPlatform) integrateVelocity(deltaTime float64) <span class="cov8" title="1">{
        // Convert velocity to lat/lon/alt changes
        earthRadius := 6371000.0 // Earth radius in meters

        // Convert North/East velocity to lat/lon changes
        deltaLat := up.State.Velocity.North * deltaTime / earthRadius * 180.0 / math.Pi
        deltaLon := up.State.Velocity.East * deltaTime / (earthRadius * math.Cos(up.State.Position.Latitude*math.Pi/180.0)) * 180.0 / math.Pi
        deltaAlt := up.State.Velocity.Up * deltaTime

        // Update position
        up.State.Position.Latitude += deltaLat
        up.State.Position.Longitude += deltaLon
        up.State.Position.Altitude += deltaAlt

        // Update speed from velocity magnitude
        up.State.Speed = math.Sqrt(up.State.Velocity.North*up.State.Velocity.North + up.State.Velocity.East*up.State.Velocity.East + up.State.Velocity.Up*up.State.Velocity.Up)

        // Update heading from velocity direction
        if up.State.Velocity.East != 0 || up.State.Velocity.North != 0 </span><span class="cov0" title="0">{
                up.State.Heading = math.Atan2(up.State.Velocity.East, up.State.Velocity.North) * 180.0 / math.Pi
                if up.State.Heading &lt; 0 </span><span class="cov0" title="0">{
                        up.State.Heading += 360
                }</span>
        }
}

func (up *UniversalPlatform) updateAttitudeFromForces(deltaTime float64) <span class="cov8" title="1">{
        // Apply angular velocity to attitude changes
        up.State.Physics.Attitude.Roll += up.State.Physics.AngularVelocity.RollRate * deltaTime
        up.State.Physics.Attitude.Pitch += up.State.Physics.AngularVelocity.PitchRate * deltaTime
        up.State.Physics.Attitude.Yaw += up.State.Physics.AngularVelocity.YawRate * deltaTime

        // Update legacy roll field for compatibility
        up.State.Roll = up.State.Physics.Attitude.Roll

        // Basic attitude control from angular forces
        if up.AngularForces.X != 0 || up.AngularForces.Y != 0 || up.AngularForces.Z != 0 </span><span class="cov0" title="0">{
                // Integrate angular forces to angular velocity
                if up.State.Physics.Mass &gt; 0 </span><span class="cov0" title="0">{
                        up.State.Physics.AngularVelocity.RollRate += up.AngularForces.X * deltaTime / up.State.Physics.Mass
                        up.State.Physics.AngularVelocity.PitchRate += up.AngularForces.Y * deltaTime / up.State.Physics.Mass
                        up.State.Physics.AngularVelocity.YawRate += up.AngularForces.Z * deltaTime / up.State.Physics.Mass
                }</span>

                // Reset angular forces
                <span class="cov0" title="0">up.AngularForces.X = 0
                up.AngularForces.Y = 0
                up.AngularForces.Z = 0</span>
        }
}

// GetPhysicsState returns the current physics state
func (up *UniversalPlatform) GetPhysicsState() PhysicsState <span class="cov0" title="0">{
        return up.State.Physics
}</span>

// SetPhysicsState sets the physics state
func (up *UniversalPlatform) SetPhysicsState(physics PhysicsState) <span class="cov0" title="0">{
        up.State.Physics = physics
        // Sync legacy state
        up.State.Position = physics.Position
        up.State.Velocity = physics.Velocity
        up.State.Heading = physics.Attitude.Yaw
        up.State.Speed = math.Sqrt(physics.Velocity.North*physics.Velocity.North + physics.Velocity.East*physics.Velocity.East)
}</span>

// CalculateDistanceTo calculates distance to another position
func (up *UniversalPlatform) CalculateDistanceTo(target Position) float64 <span class="cov8" title="1">{
        return up.calculateGreatCircleDistance(target)
}</span>

// GetStatus returns a status summary of the platform
func (up *UniversalPlatform) GetStatus() PlatformStatus <span class="cov8" title="1">{
        return PlatformStatus{
                ID:           up.ID,
                PlatformType: up.PlatformType,
                Position:     up.State.Position,
                Velocity:     up.State.Velocity,
                Heading:      up.State.Heading,
                Speed:        up.State.Speed,
                LastUpdated:  up.State.LastUpdated,
        }
}</span>

// ApplyForce applies a 3D force to the platform
func (up *UniversalPlatform) ApplyForce(force Force) <span class="cov8" title="1">{
        // Add the applied force to existing forces
        up.State.Physics.Forces.Thrust += force.X
        up.State.Physics.Forces.Normal += force.Y
        up.State.Physics.Forces.Lift += force.Z
}</span>

// calculateTurningRate calculates the turning rate for the platform
func (p *UniversalPlatform) calculateTurningRate(deltaTime time.Duration) float64 <span class="cov0" title="0">{
        // Get turning radius from performance characteristics
        turningRadius := p.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius = 500.0 // Default turning radius in meters
        }</span>

        // Calculate turning rate based on current speed and turning radius
        // Angular velocity = linear velocity / radius
        <span class="cov0" title="0">if p.State.Speed &gt; 0 &amp;&amp; turningRadius &gt; 0 </span><span class="cov0" title="0">{
                return p.State.Speed / turningRadius // radians per second
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// PlatformStatus represents a summary of platform state
type PlatformStatus struct {
        ID           string       `json:"id"`
        PlatformType PlatformType `json:"platform_type"`
        Position     Position     `json:"position"`
        Velocity     Velocity     `json:"velocity"`
        Heading      float64      `json:"heading"`
        Speed        float64      `json:"speed"`
        LastUpdated  time.Time    `json:"last_updated"`
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "fmt"
        "math"
        "time"
)

// SpacePlatform represents satellites and spacecraft
type SpacePlatform struct {
        // Base identification
        ID       string
        Class    string // Spacecraft/satellite type
        Name     string // Mission designation
        CallSign string

        // Current state
        State PlatformState

        // Orbital characteristics
        MaxSpeed      float64 // m/s (orbital velocity)
        OrbitalPeriod float64 // seconds (time for one orbit)
        Apogee        float64 // meters (highest point)
        Perigee       float64 // meters (lowest point)
        Inclination   float64 // degrees (orbital plane angle)

        // Physical characteristics
        Length float64 // meters
        Width  float64 // meters
        Height float64 // meters
        Mass   float64 // kg

        // Navigation (simplified orbital mechanics)
        Destination *Position
        OrbitCenter Position // Usually Earth center for LEO/GEO
}

// Core Platform interface implementation
func (s *SpacePlatform) GetID() string           <span class="cov0" title="0">{ return s.ID }</span>
func (s *SpacePlatform) GetType() PlatformType   <span class="cov0" title="0">{ return PlatformTypeSpace }</span>
func (s *SpacePlatform) GetClass() string        <span class="cov0" title="0">{ return s.Class }</span>
func (s *SpacePlatform) GetName() string         <span class="cov0" title="0">{ return s.Name }</span>
func (s *SpacePlatform) GetCallSign() string     <span class="cov0" title="0">{ return s.CallSign }</span>
func (s *SpacePlatform) GetState() PlatformState <span class="cov0" title="0">{ return s.State }</span>
func (s *SpacePlatform) GetMaxSpeed() float64    <span class="cov0" title="0">{ return s.MaxSpeed }</span>
func (s *SpacePlatform) GetMaxAltitude() float64 <span class="cov0" title="0">{ return s.Apogee }</span>
func (s *SpacePlatform) GetLength() float64      <span class="cov0" title="0">{ return s.Length }</span>
func (s *SpacePlatform) GetWidth() float64       <span class="cov0" title="0">{ return s.Width }</span>
func (s *SpacePlatform) GetHeight() float64      <span class="cov0" title="0">{ return s.Height }</span>
func (s *SpacePlatform) GetMass() float64        <span class="cov0" title="0">{ return s.Mass }</span>

func (s *SpacePlatform) UpdateState(state PlatformState) <span class="cov0" title="0">{
        s.State = state
}</span>

func (s *SpacePlatform) SetDestination(pos Position) error <span class="cov0" title="0">{
        s.Destination = &amp;pos
        return nil
}</span>

func (s *SpacePlatform) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        // Simplified orbital mechanics - circular orbit approximation
        dt := deltaTime.Seconds()

        // Calculate orbital velocity based on altitude
        earthRadius := 6371000.0 // meters
        altitude := s.State.Position.Altitude
        orbitalRadius := earthRadius + altitude

        // Simplified orbital velocity: v = sqrt(GM/r)
        // Using approximation for Earth: GM ≈ 3.986e14 m³/s²
        GM := 3.986e14
        orbitalVelocity := math.Sqrt(GM / orbitalRadius)

        // Angular velocity (radians per second)
        angularVelocity := orbitalVelocity / orbitalRadius

        // Update position in simplified circular orbit
        // Convert lat/lon to radians for calculation
        lonRad := s.State.Position.Longitude * math.Pi / 180

        // Simple eastward progression (simplified)
        lonRad += angularVelocity * dt

        // Wrap longitude
        for lonRad &gt; math.Pi </span><span class="cov0" title="0">{
                lonRad -= 2 * math.Pi
        }</span>
        <span class="cov0" title="0">for lonRad &lt; -math.Pi </span><span class="cov0" title="0">{
                lonRad += 2 * math.Pi
        }</span>

        // Convert back to degrees
        <span class="cov0" title="0">s.State.Position.Longitude = lonRad * 180 / math.Pi

        // Update speed and heading
        s.State.Speed = orbitalVelocity
        s.State.Heading = 90 // Eastward movement
        s.State.LastUpdated = time.Now()

        return nil</span>
}

// Space platform factory functions for real-world platforms

// NewISSModule creates an International Space Station module
func NewISSModule(id, moduleName string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // ISS orbits at approximately 408 km altitude
        startPos.Altitude = 408000
        return &amp;SpacePlatform{
                ID:       id,
                Class:    "ISS Module",
                Name:     fmt.Sprintf("ISS %s", moduleName),
                CallSign: fmt.Sprintf("ISS%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,   // Eastward
                        Speed:       7660, // m/s (ISS orbital velocity)
                        LastUpdated: time.Now(),
                },
                MaxSpeed:      7660,   // m/s
                OrbitalPeriod: 5520,   // seconds (92 minutes)
                Apogee:        420000, // meters
                Perigee:       408000, // meters
                Inclination:   51.6,   // degrees
                Length:        73,     // meters (full ISS)
                Width:         109,    // meters (solar array span)
                Height:        20,     // meters
                Mass:          420000, // kg
        }
}</span>

// NewStarlinkSatellite creates a Starlink communication satellite
func NewStarlinkSatellite(id, satelliteNumber string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Starlink operates at ~550 km altitude
        startPos.Altitude = 550000
        return &amp;SpacePlatform{
                ID:       id,
                Class:    "Starlink Satellite",
                Name:     fmt.Sprintf("Starlink-%s", satelliteNumber),
                CallSign: fmt.Sprintf("STARLINK%s", id[len(id)-3:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7590, // m/s
                        LastUpdated: time.Now(),
                },
                MaxSpeed:      7590,   // m/s
                OrbitalPeriod: 5760,   // seconds (96 minutes)
                Apogee:        550000, // meters
                Perigee:       550000, // meters (circular orbit)
                Inclination:   53.0,   // degrees
                Length:        2.8,    // meters
                Width:         1.9,    // meters
                Height:        0.32,   // meters
                Mass:          260,    // kg
        }
}</span>

// NewGPSSatellite creates a GPS navigation satellite
func NewGPSSatellite(id, satelliteNumber string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // GPS operates at ~20,200 km altitude
        startPos.Altitude = 20200000
        return &amp;SpacePlatform{
                ID:       id,
                Class:    "GPS Block III",
                Name:     fmt.Sprintf("GPS III-%s", satelliteNumber),
                CallSign: fmt.Sprintf("GPS%s", satelliteNumber),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       3870, // m/s
                        LastUpdated: time.Now(),
                },
                MaxSpeed:      3870,     // m/s
                OrbitalPeriod: 43200,    // seconds (12 hours)
                Apogee:        20200000, // meters
                Perigee:       20200000, // meters
                Inclination:   55.0,     // degrees
                Length:        3.0,      // meters
                Width:         2.0,      // meters
                Height:        1.7,      // meters
                Mass:          2000,     // kg
        }
}</span>

// NewHubbleTelescope creates the Hubble Space Telescope
func NewHubbleTelescope(id string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Hubble orbits at ~547 km altitude
        startPos.Altitude = 547000
        return &amp;SpacePlatform{
                ID:       id,
                Class:    "Space Telescope",
                Name:     "Hubble Space Telescope",
                CallSign: "HUBBLE",
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7590, // m/s
                        LastUpdated: time.Now(),
                },
                MaxSpeed:      7590,   // m/s
                OrbitalPeriod: 5730,   // seconds (95.5 minutes)
                Apogee:        547000, // meters
                Perigee:       547000, // meters
                Inclination:   28.5,   // degrees
                Length:        13.3,   // meters
                Width:         4.3,    // meters (diameter)
                Height:        4.3,    // meters
                Mass:          11110,  // kg
        }
}</span>

// NewDragonCapsule creates a SpaceX Dragon spacecraft
func NewDragonCapsule(id, missionName string, startPos Position) *SpacePlatform <span class="cov0" title="0">{
        // Dragon typically operates at ISS altitude
        startPos.Altitude = 408000
        return &amp;SpacePlatform{
                ID:       id,
                Class:    "Dragon 2 Capsule",
                Name:     fmt.Sprintf("Dragon %s", missionName),
                CallSign: fmt.Sprintf("DRAGON%s", id[len(id)-2:]),
                State: PlatformState{
                        ID:          id,
                        Position:    startPos,
                        Velocity:    Velocity{},
                        Heading:     90,
                        Speed:       7660, // m/s
                        LastUpdated: time.Now(),
                },
                MaxSpeed:      7660,   // m/s
                OrbitalPeriod: 5520,   // seconds
                Apogee:        420000, // meters
                Perigee:       408000, // meters
                Inclination:   51.6,   // degrees
                Length:        8.1,    // meters (with trunk)
                Width:         3.7,    // meters (diameter)
                Height:        3.7,    // meters
                Mass:          12055,  // kg (fully loaded)
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
        "github.com/rhino11/trafficsim/internal/sim"
)

// Enhanced logging for web interface debugging
func logWebRequest(r *http.Request, status string) <span class="cov0" title="0">{
        log.Printf("[WEB] %s %s - %s - User-Agent: %s - RemoteAddr: %s",
                r.Method, r.URL.Path, status, r.UserAgent(), r.RemoteAddr)
}</span>

func logWebError(context string, err error) <span class="cov0" title="0">{
        log.Printf("[WEB-ERROR] %s: %v", context, err)
}</span>

func logWebSocket(action string, clientCount int) <span class="cov0" title="0">{
        log.Printf("[WEBSOCKET] %s - Active clients: %d", action, clientCount)
}</span>

func logJSLoad(filename string, status string) <span class="cov0" title="0">{
        log.Printf("[JS-LOAD] %s - %s", filename, status)
}</span>

func logInitialization(component string, status string, duration time.Duration) <span class="cov0" title="0">{
        log.Printf("[INIT] %s - %s (took %v)", component, status, duration)
}</span>

func logSimulationEvent(event string, details interface{}) <span class="cov0" title="0">{
        log.Printf("[SIM] %s - %+v", event, details)
}</span>

func logPerformance(metric string, value interface{}) <span class="cov0" title="0">{
        log.Printf("[PERF] %s: %v", metric, value)
}</span>

func logDebug(component string, message string, data interface{}) <span class="cov0" title="0">{
        log.Printf("[DEBUG] [%s] %s - %+v", component, message, data)
}</span>

func logClientMessage(msgType string, clientAddr string, data interface{}) <span class="cov0" title="0">{
        log.Printf("[CLIENT-MSG] Type: %s, From: %s, Data: %+v", msgType, clientAddr, data)
}</span>

func logDataStream(component string, action string, details interface{}) <span class="cov0" title="0">{
        log.Printf("[STREAM] [%s] %s - %+v", component, action, details)
}</span>

func logPlatformUpdate(platformCount int, action string) <span class="cov0" title="0">{
        log.Printf("[PLATFORM] %s - Count: %d", action, platformCount)
}</span>

// Server represents the web server for the traffic simulation
type Server struct {
        config     *config.Config
        simulation *sim.Engine
        router     *mux.Router
        upgrader   websocket.Upgrader
        clients    map[*websocket.Conn]bool
        clientsMux sync.RWMutex
        broadcast  chan []byte
        ctx        context.Context
        cancel     context.CancelFunc
}

// Client represents a connected WebSocket client
type Client struct {
        conn   *websocket.Conn
        send   chan []byte
        server *Server
}

// Message represents a WebSocket message
type Message struct {
        Type      string      `json:"type"`
        Data      interface{} `json:"data,omitempty"`
        Timestamp int64       `json:"timestamp"`
}

// PlatformUpdate represents a platform update message
type PlatformUpdate struct {
        Type      string            `json:"type"`
        Platforms []models.Platform `json:"platforms"`
        Timestamp int64             `json:"timestamp"`
}

// SimulationStatus represents simulation status
type SimulationStatus struct {
        Running       bool    `json:"running"`
        Time          float64 `json:"time"`
        PlatformCount int     `json:"platform_count"`
        Speed         float64 `json:"speed"`
}

// NewServer creates a new web server instance
func NewServer(cfg *config.Config, simulation *sim.Engine) *Server <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        server := &amp;Server{
                config:     cfg,
                simulation: simulation,
                router:     mux.NewRouter(),
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true // Allow all origins for development
                        }</span>,
                },
                clients:   make(map[*websocket.Conn]bool),
                broadcast: make(chan []byte, 256),
                ctx:       ctx,
                cancel:    cancel,
        }

        <span class="cov0" title="0">server.setupRoutes()
        return server</span>
}

// setupRoutes configures all HTTP routes
func (s *Server) setupRoutes() <span class="cov0" title="0">{
        // Static files with logging
        staticHandler := http.StripPrefix("/static/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                logWebRequest(r, "SERVING_STATIC")

                // Serve the file
                fileServer := http.FileServer(http.Dir("web/static/"))
                fileServer.ServeHTTP(w, r)

                duration := time.Since(start)
                logPerformance("static_file_serve", map[string]interface{}{
                        "file":     r.URL.Path,
                        "duration": duration,
                })

                // Log JavaScript file loads specifically
                if strings.HasSuffix(r.URL.Path, ".js") </span><span class="cov0" title="0">{
                        logJSLoad(r.URL.Path, "LOADED")
                }</span>
        }))
        <span class="cov0" title="0">s.router.PathPrefix("/static/").Handler(staticHandler)

        // WebSocket endpoint
        s.router.HandleFunc("/ws", s.handleWebSocket)

        // API endpoints with logging middleware
        api := s.router.PathPrefix("/api").Subrouter()
        api.Use(s.loggingMiddleware)
        api.HandleFunc("/platforms", s.handleGetPlatforms).Methods("GET")
        api.HandleFunc("/simulation/start", s.handleStartSimulation).Methods("POST")
        api.HandleFunc("/simulation/stop", s.handleStopSimulation).Methods("POST")
        api.HandleFunc("/simulation/reset", s.handleResetSimulation).Methods("POST")
        api.HandleFunc("/simulation/status", s.handleSimulationStatus).Methods("GET")
        api.HandleFunc("/stream/platforms", s.handleSSEPlatforms).Methods("GET")
        // Performance monitoring endpoint
        api.HandleFunc("/metrics", s.handleMetrics).Methods("GET")
        // Client logging endpoint for debugging
        api.HandleFunc("/log", s.handleClientLog).Methods("POST")

        // Main page
        s.router.HandleFunc("/", s.handleIndex).Methods("GET")

        logInitialization("Router", "CONFIGURED", 0)</span>
}

// Start starts the web server
func (s *Server) Start(port string) error <span class="cov0" title="0">{
        log.Printf("Starting web server on port %s", port)

        // Start the broadcast goroutine
        go s.handleBroadcast()

        // Start simulation updates if simulation is running
        go s.streamSimulationUpdates()

        // Create HTTP server with proper timeouts for security
        server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      s.router,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        return server.ListenAndServe()
}</span>

// Stop stops the web server
func (s *Server) Stop() <span class="cov0" title="0">{
        s.cancel()

        // Close all WebSocket connections with proper error handling
        s.clientsMux.Lock()
        for client := range s.clients </span><span class="cov0" title="0">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection: %v", err)
                }</span>
        }
        <span class="cov0" title="0">s.clientsMux.Unlock()</span>
}

// handleIndex serves the main HTML page
func (s *Server) handleIndex(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl, err := template.ParseFiles("web/templates/index.html")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error loading template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Traffic Simulation",
        }

        if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error executing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// handleWebSocket handles WebSocket connections
func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;Client{
                conn:   conn,
                send:   make(chan []byte, 256),
                server: s,
        }

        s.clientsMux.Lock()
        s.clients[conn] = true
        s.clientsMux.Unlock()

        logWebSocket("New connection", len(s.clients))

        // Send initial data
        go s.sendInitialData(client)

        // Start goroutines for this client
        go client.writePump()
        go client.readPump()</span>
}

// sendInitialData sends initial platform data to a new client
func (s *Server) sendInitialData(client *Client) <span class="cov0" title="0">{
        platforms := s.simulation.GetAllPlatforms()

        message := PlatformUpdate{
                Type:      "platform_update",
                Platforms: platforms,
                Timestamp: time.Now().UnixMilli(),
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling initial data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">select </span>{
        case client.send &lt;- data:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                log.Printf("Timeout sending initial data to client")</span>
        }
}

// handleGetPlatforms returns all current platforms
func (s *Server) handleGetPlatforms(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        platforms := s.simulation.GetAllPlatforms()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(platforms); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error encoding platforms: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

// handleStartSimulation starts the simulation
func (s *Server) handleStartSimulation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := s.simulation.Start(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error starting simulation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "started"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Start simulation response encoding", err)
        }</span>
}

// handleStopSimulation stops the simulation
func (s *Server) handleStopSimulation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.simulation.Stop()
        s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "stopped"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Stop simulation response encoding", err)
        }</span>
}

// handleResetSimulation resets the simulation
func (s *Server) handleResetSimulation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := s.simulation.Reset(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error resetting simulation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s.broadcastSimulationStatus()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"status": "reset"}); err != nil </span><span class="cov0" title="0">{
                logWebError("Reset simulation response encoding", err)
        }</span>
}

// handleSimulationStatus returns simulation status
func (s *Server) handleSimulationStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        status := SimulationStatus{
                Running:       s.simulation.IsRunning(),
                Time:          s.simulation.GetSimulationTime(),
                PlatformCount: len(s.simulation.GetAllPlatforms()),
                Speed:         1.0, // Default speed
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(status); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding status response: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// handleSSEPlatforms handles Server-Sent Events for platform updates
func (s *Server) handleSSEPlatforms(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
                return
        }</span>

        // Send initial data
        <span class="cov0" title="0">platforms := s.simulation.GetAllPlatforms()
        if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                data, _ := json.Marshal(platforms)
                fmt.Fprintf(w, "data: %s\n\n", data)
                flusher.Flush()
                log.Printf("SSE: Sent initial data with %d platforms", len(platforms))
        }</span>

        // Create a ticker to send regular updates
        <span class="cov0" title="0">ticker := time.NewTicker(100 * time.Millisecond) // 10 FPS
        defer ticker.Stop()

        // Keep connection alive ticker
        heartbeatTicker := time.NewTicker(30 * time.Second)
        defer heartbeatTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-r.Context().Done():<span class="cov0" title="0">
                        log.Printf("SSE: Client disconnected")
                        return</span>
                case &lt;-heartbeatTicker.C:<span class="cov0" title="0">
                        fmt.Fprintf(w, ": heartbeat\n\n")
                        flusher.Flush()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if s.simulation.IsRunning() </span><span class="cov0" title="0">{
                                platforms := s.simulation.GetAllPlatforms()
                                if len(platforms) &gt; 0 </span><span class="cov0" title="0">{
                                        message := PlatformUpdate{
                                                Type:      "platform_update",
                                                Platforms: platforms,
                                                Timestamp: time.Now().UnixMilli(),
                                        }

                                        data, err := json.Marshal(message)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error marshaling SSE platform update: %v", err)
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">fmt.Fprintf(w, "data: %s\n\n", data)
                                        flusher.Flush()</span>
                                }
                        }
                }
        }
}

// streamSimulationUpdates continuously streams simulation updates to WebSocket clients
func (s *Server) streamSimulationUpdates() <span class="cov0" title="0">{
        ticker := time.NewTicker(100 * time.Millisecond) // 10 FPS
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if s.simulation.IsRunning() </span><span class="cov0" title="0">{
                                platforms := s.simulation.GetAllPlatforms()

                                message := PlatformUpdate{
                                        Type:      "platform_update",
                                        Platforms: platforms,
                                        Timestamp: time.Now().UnixMilli(),
                                }

                                data, err := json.Marshal(message)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error marshaling platform update: %v", err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">select </span>{
                                case s.broadcast &lt;- data:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Channel is full, skip this update
                                }
                        }
                }
        }
}

// broadcastSimulationStatus broadcasts simulation status to all clients
func (s *Server) broadcastSimulationStatus() <span class="cov0" title="0">{
        status := SimulationStatus{
                Running:       s.simulation.IsRunning(),
                Time:          s.simulation.GetSimulationTime(),
                PlatformCount: len(s.simulation.GetAllPlatforms()),
                Speed:         1.0,
        }

        message := Message{
                Type:      "simulation_status",
                Data:      status,
                Timestamp: time.Now().UnixMilli(),
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling simulation status: %v", err)
                return
        }</span>

        <span class="cov0" title="0">select </span>{
        case s.broadcast &lt;- data:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip this update
        }
}

// handleBroadcast handles broadcasting messages to all connected clients
func (s *Server) handleBroadcast() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case message := &lt;-s.broadcast:<span class="cov0" title="0">
                        s.clientsMux.RLock()
                        clientsToRemove := make([]*websocket.Conn, 0)

                        for client := range s.clients </span><span class="cov0" title="0">{
                                err := client.WriteMessage(websocket.TextMessage, message)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error writing to WebSocket client: %v", err)
                                        clientsToRemove = append(clientsToRemove, client)
                                }</span>
                        }
                        <span class="cov0" title="0">s.clientsMux.RUnlock()

                        // Remove failed clients
                        if len(clientsToRemove) &gt; 0 </span><span class="cov0" title="0">{
                                s.clientsMux.Lock()
                                for _, client := range clientsToRemove </span><span class="cov0" title="0">{
                                        delete(s.clients, client)
                                        if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error closing failed WebSocket client: %v", err)
                                        }</span>
                                }
                                <span class="cov0" title="0">s.clientsMux.Unlock()
                                logWebSocket("Removed failed clients", len(s.clients))</span>
                        }
                }
        }
}

// Client methods for WebSocket handling

// readPump handles reading messages from the WebSocket connection
func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.server.clientsMux.Lock()
                delete(c.server.clients, c.conn)
                c.server.clientsMux.Unlock()
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection in readPump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">c.conn.SetReadLimit(512)
        if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting read deadline: %v", err)
        }</span>
        <span class="cov0" title="0">c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error setting pong read deadline: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Handle incoming messages (ping, control messages, etc.)
                <span class="cov0" title="0">c.handleMessage(message)</span>
        }
}

// writePump handles writing messages to the WebSocket connection
func (c *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(54 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing WebSocket connection in writePump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        if err := c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error setting write deadline: %v", err)
                        }</span>
                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                if err := c.conn.WriteMessage(websocket.CloseMessage, []byte{}); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error sending close message: %v", err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error setting ping write deadline: %v", err)
                        }</span>
                        <span class="cov0" title="0">if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleMessage handles incoming WebSocket messages
func (c *Client) handleMessage(data []byte) <span class="cov0" title="0">{
        clientAddr := c.conn.RemoteAddr().String()

        var msg Message
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                logWebError("Message unmarshaling", err)
                return
        }</span>

        <span class="cov0" title="0">logClientMessage(msg.Type, clientAddr, msg.Data)

        switch msg.Type </span>{
        case "ping":<span class="cov0" title="0">
                // Respond with pong
                response := Message{
                        Type:      "pong",
                        Timestamp: time.Now().UnixMilli(),
                }
                responseData, _ := json.Marshal(response)
                select </span>{
                case c.send &lt;- responseData:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">logDebug("WEBSOCKET", "Pong sent", map[string]interface{}{
                        "client":  clientAddr,
                        "latency": time.Now().UnixMilli() - msg.Timestamp,
                })</span>

        case "viewport_update":<span class="cov0" title="0">
                // Handle viewport changes for server-side filtering
                logDataStream("VIEWPORT", "Update received", msg.Data)</span>
                // Future: Implement viewport-based platform filtering

        case "filter_update":<span class="cov0" title="0">
                // Handle platform filter changes
                logDataStream("FILTER", "Update received", msg.Data)</span>
                // Future: Implement server-side platform filtering

        case "request_initial_data":<span class="cov0" title="0">
                // Send current platform data
                logDataStream("CLIENT", "Initial data requested", clientAddr)
                go c.server.sendInitialData(c)</span>

        case "start_simulation":<span class="cov0" title="0">
                // Handle simulation start command
                logSimulationEvent("START_REQUESTED", map[string]interface{}{
                        "client":    clientAddr,
                        "timestamp": msg.Timestamp,
                })
                if err := c.server.simulation.Start(); err != nil </span><span class="cov0" title="0">{
                        logWebError("Simulation start", err)
                }</span> else<span class="cov0" title="0"> {
                        c.server.broadcastSimulationStatus()
                }</span>

        case "stop_simulation":<span class="cov0" title="0">
                // Handle simulation stop command
                logSimulationEvent("STOP_REQUESTED", map[string]interface{}{
                        "client":    clientAddr,
                        "timestamp": msg.Timestamp,
                })
                c.server.simulation.Stop()
                c.server.broadcastSimulationStatus()</span>

        case "control":<span class="cov0" title="0">
                // Handle other simulation control messages
                logSimulationEvent("CONTROL_MESSAGE", msg.Data)</span>

        default:<span class="cov0" title="0">
                // Log unknown message types with full context for debugging
                logDebug("WEBSOCKET", "Unknown message type received", map[string]interface{}{
                        "type":      msg.Type,
                        "client":    clientAddr,
                        "data":      msg.Data,
                        "timestamp": msg.Timestamp,
                })</span>
        }
}

// handleClientLog handles client-side logging for debugging
func (s *Server) handleClientLog(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var logData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;logData); err != nil </span><span class="cov0" title="0">{
                logWebError("Client log decode", err)
                http.Error(w, "Invalid log data", http.StatusBadRequest)
                return
        }</span>

        // Log client-side events with context
        <span class="cov0" title="0">logType, _ := logData["type"].(string)
        step, _ := logData["step"].(string)
        message, _ := logData["message"].(string)
        timestamp, _ := logData["timestamp"].(string)
        userAgent, _ := logData["userAgent"].(string)

        switch logType </span>{
        case "client_log":<span class="cov0" title="0">
                log.Printf("[CLIENT-LOG] [%s] %s: %s - UA: %s", step, timestamp, message, userAgent)</span>
        case "client_error":<span class="cov0" title="0">
                errorMsg, _ := logData["error"].(string)
                context, _ := logData["context"].(string)
                stack, _ := logData["stack"].(string)
                log.Printf("[CLIENT-ERROR] [%s] %s: %s - Context: %s - Stack: %s - UA: %s",
                        step, timestamp, errorMsg, context, stack, userAgent)</span>
        default:<span class="cov0" title="0">
                log.Printf("[CLIENT-UNKNOWN] %+v", logData)</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// loggingMiddleware adds request/response logging to API endpoints
func (s *Server) loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                logWebRequest(r, "API_REQUEST_START")

                // Create a response writer wrapper to capture status code
                wrapper := &amp;responseWriter{ResponseWriter: w, statusCode: 200}

                next.ServeHTTP(wrapper, r)

                duration := time.Since(start)
                logPerformance("api_request", map[string]interface{}{
                        "endpoint": r.URL.Path,
                        "method":   r.Method,
                        "status":   wrapper.statusCode,
                        "duration": duration,
                })
        }</span>)
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// handleMetrics returns comprehensive performance metrics
func (s *Server) handleMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stats := s.simulation.GetStatistics()

        metrics := map[string]interface{}{
                "simulation": stats,
                "server": map[string]interface{}{
                        "active_websocket_clients": len(s.clients),
                        "uptime_seconds":           time.Since(time.Now()).Seconds(), // Will be corrected with actual start time
                },
                "platforms": map[string]interface{}{
                        "total": stats.TotalPlatforms,
                        "by_type": map[string]interface{}{
                                "airborne": stats.AirbornePlatforms,
                                "maritime": stats.MaritimePlatforms,
                                "land":     stats.LandPlatforms,
                                "space":    stats.SpacePlatforms,
                        },
                },
                "timestamp": time.Now().Unix(),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logWebError("Metrics encoding", err)
                http.Error(w, "Error encoding metrics", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package sim

import (
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/rhino11/trafficsim/internal/config"
        "github.com/rhino11/trafficsim/internal/models"
)

// Enhanced logging for simulation debugging
func logSimulationStart(platformCount int, updateInterval time.Duration) <span class="cov0" title="0">{
        log.Printf("[SIM-START] Starting simulation with %d platforms at %v update interval", platformCount, updateInterval)
}</span>

func logSimulationStop(reason string) <span class="cov0" title="0">{
        log.Printf("[SIM-STOP] Simulation stopped: %s", reason)
}</span>

func logPlatformOperation(operation string, platformID string, details interface{}) <span class="cov0" title="0">{
        log.Printf("[PLATFORM-OP] %s - ID: %s - Details: %+v", operation, platformID, details)
}</span>

func logSimulationPerformance(updateCount int, avgUpdateTime time.Duration, platformCount int) <span class="cov0" title="0">{
        log.Printf("[SIM-PERF] Updates: %d, Avg Update Time: %v, Platforms: %d", updateCount, avgUpdateTime, platformCount)
}</span>

func logSimulationError(context string, err error, platformID string) <span class="cov0" title="0">{
        log.Printf("[SIM-ERROR] Context: %s, Platform: %s, Error: %v", context, platformID, err)
}</span>

// Engine represents the main simulation engine that orchestrates all platform movement
type Engine struct {
        config         *config.Config
        physics        *PhysicsEngine
        platforms      map[string]models.Platform
        platformsMux   sync.RWMutex
        isRunning      bool
        runningMux     sync.RWMutex
        updateTicker   *time.Ticker
        stopCh         chan struct{}
        simulationTime float64
        timeMux        sync.RWMutex
        updateInterval time.Duration

        // Performance tracking
        updateCount     int64
        totalUpdateTime time.Duration
        lastPerfLog     time.Time
}

// NewEngine creates a new simulation engine
func NewEngine(cfg *config.Config) *Engine <span class="cov0" title="0">{
        updateInterval := time.Second / 60 // 60 FPS default
        if cfg != nil &amp;&amp; cfg.Simulation.UpdateInterval != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(cfg.Simulation.UpdateInterval); err == nil </span><span class="cov0" title="0">{
                        updateInterval = parsed
                }</span>
        }

        <span class="cov0" title="0">return &amp;Engine{
                config:         cfg,
                physics:        NewPhysicsEngine(),
                platforms:      make(map[string]models.Platform),
                stopCh:         make(chan struct{}),
                updateInterval: updateInterval,
        }</span>
}

// Start begins the simulation loop
func (e *Engine) Start() error <span class="cov0" title="0">{
        e.runningMux.Lock()
        defer e.runningMux.Unlock()

        if e.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("simulation is already running")
        }</span>

        <span class="cov0" title="0">e.isRunning = true
        e.stopCh = make(chan struct{})
        e.updateTicker = time.NewTicker(e.updateInterval)

        // Start the simulation loop in a goroutine
        go e.simulationLoop()

        logSimulationStart(len(e.platforms), e.updateInterval)
        return nil</span>
}

// Stop halts the simulation
func (e *Engine) Stop() <span class="cov0" title="0">{
        e.runningMux.Lock()
        defer e.runningMux.Unlock()

        if !e.isRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">e.isRunning = false
        if e.updateTicker != nil </span><span class="cov0" title="0">{
                e.updateTicker.Stop()
        }</span>
        <span class="cov0" title="0">close(e.stopCh)

        logSimulationStop("User requested stop")</span>
}

// Reset resets the simulation to initial state
func (e *Engine) Reset() error <span class="cov0" title="0">{
        wasRunning := e.IsRunning()
        if wasRunning </span><span class="cov0" title="0">{
                e.Stop()
        }</span>

        <span class="cov0" title="0">e.timeMux.Lock()
        e.simulationTime = 0
        e.timeMux.Unlock()

        // Reset all platforms to their initial positions
        e.platformsMux.Lock()
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        universalPlatform.State.Position = universalPlatform.Config.StartPosition
                        universalPlatform.State.Speed = 0
                        universalPlatform.State.Heading = 0
                        universalPlatform.State.Velocity = models.Velocity{}
                        universalPlatform.MissionTime = 0
                        universalPlatform.State.LastUpdated = time.Now()
                }</span>
        }
        <span class="cov0" title="0">e.platformsMux.Unlock()

        if wasRunning </span><span class="cov0" title="0">{
                return e.Start()
        }</span>

        <span class="cov0" title="0">log.Printf("Simulation reset")
        return nil</span>
}

// IsRunning returns whether the simulation is currently running
func (e *Engine) IsRunning() bool <span class="cov0" title="0">{
        e.runningMux.RLock()
        defer e.runningMux.RUnlock()
        return e.isRunning
}</span>

// GetSimulationTime returns the current simulation time in seconds
func (e *Engine) GetSimulationTime() float64 <span class="cov0" title="0">{
        e.timeMux.RLock()
        defer e.timeMux.RUnlock()
        return e.simulationTime
}</span>

// AddPlatform adds a platform to the simulation
func (e *Engine) AddPlatform(platform models.Platform) error <span class="cov0" title="0">{
        e.platformsMux.Lock()
        defer e.platformsMux.Unlock()

        id := platform.GetID()
        if _, exists := e.platforms[id]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("platform with ID %s already exists", id)
        }</span>

        <span class="cov0" title="0">e.platforms[id] = platform
        logPlatformOperation("ADD", id, platform)
        return nil</span>
}

// RemovePlatform removes a platform from the simulation
func (e *Engine) RemovePlatform(id string) error <span class="cov0" title="0">{
        e.platformsMux.Lock()
        defer e.platformsMux.Unlock()

        if _, exists := e.platforms[id]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("platform with ID %s not found", id)
        }</span>

        <span class="cov0" title="0">delete(e.platforms, id)
        logPlatformOperation("REMOVE", id, nil)
        return nil</span>
}

// GetPlatform returns a platform by ID
func (e *Engine) GetPlatform(id string) (models.Platform, error) <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        platform, exists := e.platforms[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("platform with ID %s not found", id)
        }</span>

        <span class="cov0" title="0">return platform, nil</span>
}

// GetAllPlatforms returns all platforms in the simulation
func (e *Engine) GetAllPlatforms() []models.Platform <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        platforms := make([]models.Platform, 0, len(e.platforms))
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>

        <span class="cov0" title="0">return platforms</span>
}

// LoadPlatformsFromConfig loads platforms from configuration
func (e *Engine) LoadPlatformsFromConfig() error <span class="cov0" title="0">{
        if e.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration provided")
        }</span>

        // This would load platforms from the configuration
        // For now, we'll create some example platforms
        <span class="cov0" title="0">if err := e.createExamplePlatforms(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example platforms: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createExamplePlatforms creates some example platforms for testing
func (e *Engine) createExamplePlatforms() error <span class="cov0" title="0">{
        // Create example aircraft
        boeing737 := models.NewBoeing737_800Universal(
                "UA123",
                "United 123",
                models.Position{Latitude: 40.7128, Longitude: -74.0060, Altitude: 10000}, // NYC
        )
        if err := boeing737.SetDestination(models.Position{Latitude: 34.0522, Longitude: -118.2437, Altitude: 10000}); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting Boeing 737 destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(boeing737); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example ship
        <span class="cov0" title="0">destroyer := models.NewArleighBurkeDestroyerUniversal(
                "DDG-89",
                "Mustin",
                models.Position{Latitude: 36.8485, Longitude: -76.2951, Altitude: 0}, // Norfolk, VA
        )
        if err := destroyer.SetDestination(models.Position{Latitude: 25.7617, Longitude: -80.1918, Altitude: 0}); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting destroyer destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(destroyer); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example tank
        <span class="cov0" title="0">tank := models.NewM1A2AbramsUniversal(
                "ARMOR-01",
                "Alpha Company",
                models.Position{Latitude: 31.8720, Longitude: -106.3744, Altitude: 1200}, // El Paso, TX
        )
        if err := tank.SetDestination(models.Position{Latitude: 31.8800, Longitude: -106.3600, Altitude: 1250}); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting tank destination: %v", err)
        }</span>

        <span class="cov0" title="0">if err := e.AddPlatform(tank); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create example satellite
        <span class="cov0" title="0">satellite := models.NewStarlinkSatelliteUniversal(
                "STARLINK-1234",
                "1234",
                models.Position{Latitude: 0, Longitude: 0, Altitude: 550000},
        )

        if err := e.AddPlatform(satellite); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Created %d example platforms", len(e.platforms))
        return nil</span>
}

// Update performs a single simulation step
func (e *Engine) Update(deltaTime time.Duration) error <span class="cov0" title="0">{
        if !e.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("simulation is not running")
        }</span>

        <span class="cov0" title="0">e.platformsMux.RLock()
        platforms := make([]models.Platform, 0, len(e.platforms))
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                platforms = append(platforms, platform)
        }</span>
        <span class="cov0" title="0">e.platformsMux.RUnlock()

        // Update all platforms using physics engine
        for _, platform := range platforms </span><span class="cov0" title="0">{
                if err := e.physics.CalculateMovement(platform, deltaTime); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error updating platform %s: %v", platform.GetID(), err)
                }</span>
        }

        // Update simulation time
        <span class="cov0" title="0">e.timeMux.Lock()
        e.simulationTime += deltaTime.Seconds()
        e.timeMux.Unlock()

        // Performance tracking
        e.updateCount++
        e.totalUpdateTime += deltaTime
        if time.Since(e.lastPerfLog) &gt; time.Second </span><span class="cov0" title="0">{
                avgUpdateTime := e.totalUpdateTime / time.Duration(e.updateCount)
                logSimulationPerformance(int(e.updateCount), avgUpdateTime, len(e.platforms))
                e.lastPerfLog = time.Now()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// simulationLoop runs the main simulation update loop
func (e *Engine) simulationLoop() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Simulation loop panic: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">lastUpdate := time.Now()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.stopCh:<span class="cov0" title="0">
                        return</span>
                case currentTime := &lt;-e.updateTicker.C:<span class="cov0" title="0">
                        deltaTime := currentTime.Sub(lastUpdate)
                        lastUpdate = currentTime

                        if err := e.Update(deltaTime); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Simulation update error: %v", err)
                        }</span>
                }
        }
}

// SetUpdateInterval changes the simulation update frequency
func (e *Engine) SetUpdateInterval(interval time.Duration) <span class="cov0" title="0">{
        e.updateInterval = interval

        // If running, restart with new interval
        if e.IsRunning() </span><span class="cov0" title="0">{
                e.Stop()
                time.Sleep(100 * time.Millisecond) // Brief pause
                if err := e.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error restarting simulation with new interval: %v", err)
                }</span>
        }
}

// GetPlatformCount returns the number of platforms in the simulation
func (e *Engine) GetPlatformCount() int <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()
        return len(e.platforms)
}</span>

// GetPlatformsByType returns platforms filtered by type
func (e *Engine) GetPlatformsByType(platformType models.PlatformType) []models.Platform <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        var filtered []models.Platform
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        if universalPlatform.PlatformType == platformType </span><span class="cov0" title="0">{
                                filtered = append(filtered, platform)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// GetStatistics returns simulation statistics
func (e *Engine) GetStatistics() SimulationStatistics <span class="cov0" title="0">{
        e.platformsMux.RLock()
        defer e.platformsMux.RUnlock()

        stats := SimulationStatistics{
                TotalPlatforms: len(e.platforms),
                SimulationTime: e.GetSimulationTime(),
                IsRunning:      e.IsRunning(),
                UpdateInterval: e.updateInterval,
        }

        // Count by type
        for _, platform := range e.platforms </span><span class="cov0" title="0">{
                if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                        switch universalPlatform.PlatformType </span>{
                        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                                stats.AirbornePlatforms++</span>
                        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                                stats.MaritimePlatforms++</span>
                        case models.PlatformTypeLand:<span class="cov0" title="0">
                                stats.LandPlatforms++</span>
                        case models.PlatformTypeSpace:<span class="cov0" title="0">
                                stats.SpacePlatforms++</span>
                        }
                }
        }

        <span class="cov0" title="0">return stats</span>
}

// SimulationStatistics contains simulation metrics
type SimulationStatistics struct {
        TotalPlatforms    int           `json:"total_platforms"`
        AirbornePlatforms int           `json:"airborne_platforms"`
        MaritimePlatforms int           `json:"maritime_platforms"`
        LandPlatforms     int           `json:"land_platforms"`
        SpacePlatforms    int           `json:"space_platforms"`
        SimulationTime    float64       `json:"simulation_time"`
        IsRunning         bool          `json:"is_running"`
        UpdateInterval    time.Duration `json:"update_interval"`
}

// SetDestinationForPlatform sets a destination for a specific platform
func (e *Engine) SetDestinationForPlatform(id string, destination models.Position) error <span class="cov0" title="0">{
        platform, err := e.GetPlatform(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if universalPlatform, ok := platform.(*models.UniversalPlatform); ok </span><span class="cov0" title="0">{
                if err := universalPlatform.SetDestination(destination); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set destination for platform %s: %w", id, err)
                }</span>
                <span class="cov0" title="0">logPlatformOperation("SET_DESTINATION", id, destination)
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("platform %s does not support destination setting", id)</span>
}

// GetPlatformStatus returns detailed status for a platform
func (e *Engine) GetPlatformStatus(id string) (*PlatformStatus, error) <span class="cov0" title="0">{
        platform, err := e.GetPlatform(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">universalPlatform, ok := platform.(*models.UniversalPlatform)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("platform %s is not a universal platform", id)
        }</span>

        <span class="cov0" title="0">status := &amp;PlatformStatus{
                ID:            universalPlatform.ID,
                Name:          universalPlatform.Config.Name,
                Type:          string(universalPlatform.PlatformType),
                Position:      universalPlatform.State.Position,
                Velocity:      universalPlatform.State.Velocity,
                Speed:         universalPlatform.State.Speed,
                Heading:       universalPlatform.State.Heading,
                FuelRemaining: universalPlatform.FuelRemaining,
                SystemStatus:  universalPlatform.SystemStatus,
                LastUpdated:   universalPlatform.State.LastUpdated,
        }

        if universalPlatform.Destination != nil </span><span class="cov0" title="0">{
                status.Destination = universalPlatform.Destination
                status.DistanceToDestination = e.physics.CalculateGreatCircleDistance(
                        universalPlatform.State.Position,
                        *universalPlatform.Destination,
                )
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// PlatformStatus represents detailed platform status information
type PlatformStatus struct {
        ID                    string              `json:"id"`
        Name                  string              `json:"name"`
        Type                  string              `json:"type"`
        Position              models.Position     `json:"position"`
        Destination           *models.Position    `json:"destination,omitempty"`
        DistanceToDestination float64             `json:"distance_to_destination,omitempty"`
        Velocity              models.Velocity     `json:"velocity"`
        Speed                 float64             `json:"speed"`
        Heading               float64             `json:"heading"`
        FuelRemaining         float64             `json:"fuel_remaining"`
        SystemStatus          models.SystemStatus `json:"system_status"`
        LastUpdated           time.Time           `json:"last_updated"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package sim

import (
        "math"
        "time"

        "github.com/rhino11/trafficsim/internal/models"
)

// PhysicsEngine handles realistic movement calculations for all platform types
type PhysicsEngine struct {
        // Environmental constants
        EarthRadius   float64 // meters
        GravityAccel  float64 // m/s²
        AirDensity    float64 // kg/m³ (sea level)
        SeaLevelPress float64 // Pa

        // Simulation parameters
        TimeStep      time.Duration
        EnableWeather bool
        EnableTerrain bool
}

// NewPhysicsEngine creates a new physics engine with realistic constants
func NewPhysicsEngine() *PhysicsEngine <span class="cov0" title="0">{
        return &amp;PhysicsEngine{
                EarthRadius:   6371000.0, // meters
                GravityAccel:  9.81,      // m/s²
                AirDensity:    1.225,     // kg/m³
                SeaLevelPress: 101325.0,  // Pa
                TimeStep:      time.Second,
                EnableWeather: false, // Start simple
                EnableTerrain: false, // Start simple
        }
}</span>

// CalculateMovement performs physics-based movement calculation for a platform
func (pe *PhysicsEngine) CalculateMovement(platform models.Platform, deltaTime time.Duration) error <span class="cov0" title="0">{
        // Try to cast directly to UniversalPlatform for enhanced physics
        if universalPlatform, isUniversal := platform.(*models.UniversalPlatform); isUniversal </span><span class="cov0" title="0">{
                return pe.updateUniversalPlatform(universalPlatform, deltaTime)
        }</span>

        // Fallback to platform's own Update method for all platforms
        <span class="cov0" title="0">return platform.Update(deltaTime)</span>
}

// updateUniversalPlatform handles movement for the new universal platform system
func (pe *PhysicsEngine) updateUniversalPlatform(platform *models.UniversalPlatform, deltaTime time.Duration) error <span class="cov0" title="0">{
        deltaSeconds := deltaTime.Seconds()

        // Skip movement if no destination
        if platform.Destination == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Calculate distance and bearing to destination
        <span class="cov0" title="0">distance := pe.CalculateGreatCircleDistance(
                platform.State.Position,
                *platform.Destination,
        )

        // Check if we've reached the destination
        arrivalThreshold := pe.getArrivalThreshold(platform.PlatformType)
        if distance &lt; arrivalThreshold </span><span class="cov0" title="0">{
                platform.State.Position = *platform.Destination
                platform.Destination = nil
                platform.State.Speed = 0
                return nil
        }</span>

        // Calculate desired movement vector
        <span class="cov0" title="0">bearing := pe.CalculateBearing(platform.State.Position, *platform.Destination)

        // Apply platform-specific physics
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                return pe.updateAircraftPhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                return pe.updateMaritimePhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeLand:<span class="cov0" title="0">
                return pe.updateLandPhysics(platform, bearing, distance, deltaSeconds)</span>
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                return pe.updateSpacePhysics(platform, deltaSeconds)</span>
        default:<span class="cov0" title="0">
                return pe.updateGenericPhysics(platform, bearing, distance, deltaSeconds)</span>
        }
}

// updateAircraftPhysics implements realistic aircraft movement
func (pe *PhysicsEngine) updateAircraftPhysics(platform *models.UniversalPlatform, bearing, distance, deltaSeconds float64) error <span class="cov0" title="0">{
        // Get performance characteristics
        maxSpeed := platform.TypeDef.Performance.MaxSpeed
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed
        climbRate := platform.TypeDef.Performance.ClimbRate
        if climbRate == 0 </span><span class="cov0" title="0">{
                climbRate = 10.0 // Default climb rate
        }</span>

        // Calculate turning constraints
        <span class="cov0" title="0">turningRadius := platform.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                // Calculate based on speed and standard bank angle (30°)
                bankAngle := 30.0 * math.Pi / 180.0
                turningRadius = (cruiseSpeed * cruiseSpeed) / (pe.GravityAccel * math.Tan(bankAngle))
        }</span>

        // Apply heading change with turning constraints
        <span class="cov0" title="0">newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                turningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Handle altitude changes
        altitudeDiff := platform.Destination.Altitude - platform.State.Position.Altitude
        if math.Abs(altitudeDiff) &gt; 10 </span><span class="cov0" title="0">{
                maxAltChange := climbRate * deltaSeconds
                if math.Abs(altitudeDiff) &lt;= maxAltChange </span><span class="cov0" title="0">{
                        platform.State.Position.Altitude = platform.Destination.Altitude
                }</span> else<span class="cov0" title="0"> if altitudeDiff &gt; 0 </span><span class="cov0" title="0">{
                        platform.State.Position.Altitude += maxAltChange
                }</span> else<span class="cov0" title="0"> {
                        platform.State.Position.Altitude -= maxAltChange
                }</span>
        }

        // Apply speed control with acceleration limits
        <span class="cov0" title="0">targetSpeed := math.Min(cruiseSpeed, maxSpeed)
        platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                targetSpeed,
                platform.TypeDef.Performance.Acceleration,
                deltaSeconds,
        )

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateMaritimePhysics implements realistic ship movement
func (pe *PhysicsEngine) updateMaritimePhysics(platform *models.UniversalPlatform, bearing, distance, deltaSeconds float64) error <span class="cov0" title="0">{
        // Ships have different characteristics
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed

        // Ships have large turning radii
        turningRadius := platform.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius = platform.TypeDef.Physical.Length * 6 // 6x ship length
        }</span>

        // Apply heading change (ships turn slowly)
        <span class="cov0" title="0">newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                turningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Ships stay at sea level
        platform.State.Position.Altitude = 0

        // Apply acceleration (ships accelerate slowly)
        acceleration := platform.TypeDef.Performance.Acceleration
        if acceleration == 0 </span><span class="cov0" title="0">{
                acceleration = 0.3 // Default slow acceleration for ships
        }</span>

        <span class="cov0" title="0">platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                cruiseSpeed,
                acceleration,
                deltaSeconds,
        )

        // Update position
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateLandPhysics implements realistic ground vehicle movement
func (pe *PhysicsEngine) updateLandPhysics(platform *models.UniversalPlatform, bearing, distance, deltaSeconds float64) error <span class="cov0" title="0">{
        cruiseSpeed := platform.TypeDef.Performance.CruiseSpeed

        // Land vehicles have small turning radii
        turningRadius := platform.TypeDef.Performance.TurningRadius
        if turningRadius == 0 </span><span class="cov0" title="0">{
                turningRadius = platform.TypeDef.Physical.Length * 1.5 // 1.5x vehicle length
        }</span>

        // Apply heading change
        <span class="cov0" title="0">newHeading := pe.applyTurningConstraints(
                platform.State.Heading,
                bearing,
                platform.State.Speed,
                turningRadius,
                deltaSeconds,
        )
        platform.State.Heading = newHeading

        // Handle terrain constraints
        targetSpeed := cruiseSpeed
        if pe.EnableTerrain </span><span class="cov0" title="0">{
                targetSpeed = pe.applyTerrainConstraints(platform, targetSpeed)
        }</span>

        // Apply acceleration
        <span class="cov0" title="0">acceleration := platform.TypeDef.Performance.Acceleration
        if acceleration == 0 </span><span class="cov0" title="0">{
                acceleration = 2.5 // Default acceleration for land vehicles
        }</span>

        <span class="cov0" title="0">platform.State.Speed = pe.applyAcceleration(
                platform.State.Speed,
                targetSpeed,
                acceleration,
                deltaSeconds,
        )

        // Update position with terrain following
        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil</span>
}

// updateSpacePhysics implements orbital mechanics
func (pe *PhysicsEngine) updateSpacePhysics(platform *models.UniversalPlatform, deltaSeconds float64) error <span class="cov0" title="0">{
        orbitalPeriod := platform.TypeDef.Performance.OrbitalPeriod
        if orbitalPeriod &lt;= 0 </span><span class="cov0" title="0">{
                return nil // No orbital motion defined
        }</span>

        // Calculate angular velocity (radians per second)
        <span class="cov0" title="0">angularVelocity := 2 * math.Pi / orbitalPeriod
        deltaAngle := angularVelocity * deltaSeconds

        // Update longitude (eastward motion)
        currentLon := platform.State.Position.Longitude * math.Pi / 180.0
        newLon := currentLon + deltaAngle

        // Normalize longitude
        for newLon &gt; math.Pi </span><span class="cov0" title="0">{
                newLon -= 2 * math.Pi
        }</span>
        <span class="cov0" title="0">for newLon &lt; -math.Pi </span><span class="cov0" title="0">{
                newLon += 2 * math.Pi
        }</span>

        <span class="cov0" title="0">platform.State.Position.Longitude = newLon * 180.0 / math.Pi

        // Calculate latitude oscillation based on orbital inclination
        inclination := platform.TypeDef.Performance.Inclination * math.Pi / 180.0
        platform.MissionTime += time.Duration(deltaSeconds * float64(time.Second))
        timeInOrbit := platform.MissionTime.Seconds()
        latitudePhase := 2 * math.Pi * timeInOrbit / orbitalPeriod

        maxLatitude := inclination
        platform.State.Position.Latitude = maxLatitude * math.Sin(latitudePhase) * 180.0 / math.Pi

        // Maintain orbital altitude
        if platform.TypeDef.Performance.OrbitalAltitude &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Position.Altitude = platform.TypeDef.Performance.OrbitalAltitude
        }</span>

        // Set orbital velocity
        <span class="cov0" title="0">platform.State.Speed = platform.TypeDef.Performance.OrbitalVelocity
        platform.State.Heading = 90 // Generally eastward

        platform.State.LastUpdated = time.Now()
        return nil</span>
}

// updateGenericPhysics provides fallback movement calculations
func (pe *PhysicsEngine) updateGenericPhysics(platform *models.UniversalPlatform, bearing, distance, deltaSeconds float64) error <span class="cov0" title="0">{
        // Simple point-to-point movement
        platform.State.Heading = bearing
        platform.State.Speed = platform.TypeDef.Performance.CruiseSpeed

        pe.updatePosition(&amp;platform.State, deltaSeconds)
        platform.State.LastUpdated = time.Now()

        return nil
}</span>

// Physics calculation helper functions

// CalculateGreatCircleDistance calculates the distance between two positions
func (pe *PhysicsEngine) CalculateGreatCircleDistance(pos1, pos2 models.Position) float64 <span class="cov0" title="0">{
        lat1 := pos1.Latitude * math.Pi / 180.0
        lat2 := pos2.Latitude * math.Pi / 180.0
        deltaLat := (pos2.Latitude - pos1.Latitude) * math.Pi / 180.0
        deltaLon := (pos2.Longitude - pos1.Longitude) * math.Pi / 180.0

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1)*math.Cos(lat2)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        distance := pe.EarthRadius * c

        // Add altitude difference
        altDiff := pos2.Altitude - pos1.Altitude
        return math.Sqrt(distance*distance + altDiff*altDiff)
}</span>

// CalculateBearing calculates the bearing from pos1 to pos2
func (pe *PhysicsEngine) CalculateBearing(pos1, pos2 models.Position) float64 <span class="cov0" title="0">{
        lat1 := pos1.Latitude * math.Pi / 180.0
        lat2 := pos2.Latitude * math.Pi / 180.0
        deltaLon := (pos2.Longitude - pos1.Longitude) * math.Pi / 180.0

        y := math.Sin(deltaLon) * math.Cos(lat2)
        x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(deltaLon)

        bearing := math.Atan2(y, x) * 180.0 / math.Pi
        return math.Mod(bearing+360, 360) // Normalize to 0-360
}</span>

// applyTurningConstraints applies realistic turning limitations
func (pe *PhysicsEngine) applyTurningConstraints(currentHeading, desiredHeading, speed, turningRadius, deltaSeconds float64) float64 <span class="cov0" title="0">{
        if turningRadius &lt;= 0 || speed &lt;= 0 </span><span class="cov0" title="0">{
                return desiredHeading
        }</span>

        // Calculate heading difference
        <span class="cov0" title="0">headingDiff := desiredHeading - currentHeading

        // Normalize to -180 to 180
        for headingDiff &gt; 180 </span><span class="cov0" title="0">{
                headingDiff -= 360
        }</span>
        <span class="cov0" title="0">for headingDiff &lt; -180 </span><span class="cov0" title="0">{
                headingDiff += 360
        }</span>

        // Calculate maximum turn rate based on turning radius and speed
        <span class="cov0" title="0">maxTurnRate := (speed / turningRadius) * 180.0 / math.Pi // degrees per second
        maxTurnChange := maxTurnRate * deltaSeconds

        // Apply turn rate limitation
        if math.Abs(headingDiff) &lt;= maxTurnChange </span><span class="cov0" title="0">{
                return desiredHeading
        }</span> else<span class="cov0" title="0"> if headingDiff &gt; 0 </span><span class="cov0" title="0">{
                return math.Mod(currentHeading+maxTurnChange, 360)
        }</span> else<span class="cov0" title="0"> {
                return math.Mod(currentHeading-maxTurnChange+360, 360)
        }</span>
}

// applyAcceleration applies realistic acceleration constraints
func (pe *PhysicsEngine) applyAcceleration(currentSpeed, targetSpeed, acceleration, deltaSeconds float64) float64 <span class="cov0" title="0">{
        if acceleration &lt;= 0 </span><span class="cov0" title="0">{
                return targetSpeed
        }</span>

        <span class="cov0" title="0">speedDiff := targetSpeed - currentSpeed
        maxSpeedChange := acceleration * deltaSeconds

        if math.Abs(speedDiff) &lt;= maxSpeedChange </span><span class="cov0" title="0">{
                return targetSpeed
        }</span> else<span class="cov0" title="0"> if speedDiff &gt; 0 </span><span class="cov0" title="0">{
                return currentSpeed + maxSpeedChange
        }</span> else<span class="cov0" title="0"> {
                return math.Max(0, currentSpeed-maxSpeedChange)
        }</span>
}

// applyTerrainConstraints modifies speed based on terrain conditions
func (pe *PhysicsEngine) applyTerrainConstraints(platform *models.UniversalPlatform, targetSpeed float64) float64 <span class="cov0" title="0">{
        if platform.Destination == nil </span><span class="cov0" title="0">{
                return targetSpeed
        }</span>

        // Calculate gradient
        <span class="cov0" title="0">altDiff := platform.Destination.Altitude - platform.State.Position.Altitude
        horizontalDist := pe.CalculateGreatCircleDistance(
                platform.State.Position,
                models.Position{
                        Latitude:  platform.Destination.Latitude,
                        Longitude: platform.Destination.Longitude,
                        Altitude:  platform.State.Position.Altitude,
                },
        )

        if horizontalDist &gt; 0 </span><span class="cov0" title="0">{
                gradient := math.Atan(altDiff/horizontalDist) * 180.0 / math.Pi
                maxGradient := platform.TypeDef.Performance.MaxGradient
                if maxGradient == 0 </span><span class="cov0" title="0">{
                        maxGradient = 30.0 // Default max gradient
                }</span>

                <span class="cov0" title="0">if math.Abs(gradient) &gt; maxGradient </span><span class="cov0" title="0">{
                        // Reduce speed on steep gradients
                        speedReduction := math.Abs(gradient) / maxGradient
                        return targetSpeed / speedReduction
                }</span>
        }

        <span class="cov0" title="0">return targetSpeed</span>
}

// updatePosition updates the platform position based on heading and speed
func (pe *PhysicsEngine) updatePosition(state *models.PlatformState, deltaSeconds float64) <span class="cov0" title="0">{
        // Convert heading to radians (0° = North, 90° = East)
        headingRad := (90 - state.Heading) * math.Pi / 180.0

        // Calculate distance moved
        distance := state.Speed * deltaSeconds

        // Calculate position change
        deltaLat := distance * math.Cos(headingRad) / pe.EarthRadius * 180.0 / math.Pi
        deltaLon := distance * math.Sin(headingRad) / pe.EarthRadius * 180.0 / math.Pi / math.Cos(state.Position.Latitude*math.Pi/180.0)

        // Update position
        state.Position.Latitude += deltaLat
        state.Position.Longitude += deltaLon

        // Update velocity components
        state.Velocity.North = state.Speed * math.Cos(headingRad)
        state.Velocity.East = state.Speed * math.Sin(headingRad)
        state.Velocity.Up = 0 // Will be calculated separately for altitude changes
}</span>

// getArrivalThreshold returns the appropriate arrival threshold for each platform type
func (pe *PhysicsEngine) getArrivalThreshold(platformType models.PlatformType) float64 <span class="cov0" title="0">{
        switch platformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                return 100.0</span> // 100 meters for aircraft
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                return 50.0</span> // 50 meters for ships
        case models.PlatformTypeLand:<span class="cov0" title="0">
                return 10.0</span> // 10 meters for land vehicles
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                return 1000.0</span> // 1 km for satellites
        default:<span class="cov0" title="0">
                return 50.0</span>
        }
}

// Enhanced 3D Physics Methods

// UpdatePhysics3D performs comprehensive 3D physics update including rotational dynamics
func (pe *PhysicsEngine) UpdatePhysics3D(platform *models.UniversalPlatform, deltaTime time.Duration) error <span class="cov0" title="0">{
        deltaSeconds := deltaTime.Seconds()

        // Update translational motion
        if err := pe.updateTranslationalMotion(platform, deltaSeconds); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update rotational motion
        <span class="cov0" title="0">pe.updateRotationalMotion(platform, deltaSeconds)

        // Apply environmental forces
        pe.applyEnvironmentalForces(platform, deltaSeconds)

        // Update derived parameters
        pe.updateDerivedParameters(platform)

        platform.State.LastUpdated = time.Now()
        return nil</span>
}

// updateTranslationalMotion handles 3D position and velocity updates
func (pe *PhysicsEngine) updateTranslationalMotion(platform *models.UniversalPlatform, deltaSeconds float64) error <span class="cov0" title="0">{
        // Apply forces to calculate acceleration
        totalForce := pe.calculateTotalForces(platform)

        // F = ma, so a = F/m
        mass := platform.TypeDef.Physical.Mass
        if mass &lt;= 0 </span><span class="cov0" title="0">{
                mass = 1000.0 // Default mass if not specified
        }</span>

        // Update acceleration in physics state
        <span class="cov0" title="0">platform.State.Physics.Acceleration.North = totalForce.North / mass
        platform.State.Physics.Acceleration.East = totalForce.East / mass
        platform.State.Physics.Acceleration.Up = totalForce.Up / mass

        // Update velocity using acceleration
        platform.State.Physics.Velocity.North += platform.State.Physics.Acceleration.North * deltaSeconds
        platform.State.Physics.Velocity.East += platform.State.Physics.Acceleration.East * deltaSeconds
        platform.State.Physics.Velocity.Up += platform.State.Physics.Acceleration.Up * deltaSeconds

        // Apply velocity limits
        pe.applyVelocityLimits(platform)

        // Update position using velocity
        return pe.updatePositionFromVelocity(platform, deltaSeconds)</span>
}

// updateRotationalMotion handles angular velocity and orientation updates
func (pe *PhysicsEngine) updateRotationalMotion(platform *models.UniversalPlatform, deltaSeconds float64) <span class="cov0" title="0">{
        // Apply torques to calculate angular acceleration
        totalTorque := pe.calculateTotalTorques(platform)

        // Apply moment of inertia (simplified as uniform values)
        momentOfInertia := pe.calculateMomentOfInertia(platform)

        // Update angular acceleration (τ = Iα, so α = τ/I)
        platform.State.Physics.AngularAcceleration.RollAccel = totalTorque.RollAccel / momentOfInertia.RollAccel
        platform.State.Physics.AngularAcceleration.PitchAccel = totalTorque.PitchAccel / momentOfInertia.PitchAccel
        platform.State.Physics.AngularAcceleration.YawAccel = totalTorque.YawAccel / momentOfInertia.YawAccel

        // Update angular velocity
        platform.State.Physics.AngularVelocity.RollRate += platform.State.Physics.AngularAcceleration.RollAccel * deltaSeconds
        platform.State.Physics.AngularVelocity.PitchRate += platform.State.Physics.AngularAcceleration.PitchAccel * deltaSeconds
        platform.State.Physics.AngularVelocity.YawRate += platform.State.Physics.AngularAcceleration.YawAccel * deltaSeconds

        // Apply angular velocity limits
        pe.applyAngularVelocityLimits(platform)

        // Update orientation using angular velocity
        platform.State.Physics.Attitude.Roll += platform.State.Physics.AngularVelocity.RollRate * deltaSeconds
        platform.State.Physics.Attitude.Pitch += platform.State.Physics.AngularVelocity.PitchRate * deltaSeconds
        platform.State.Physics.Attitude.Yaw += platform.State.Physics.AngularVelocity.YawRate * deltaSeconds

        // Normalize angles to [-π, π]
        platform.State.Physics.Attitude.Roll = pe.normalizeAngle(platform.State.Physics.Attitude.Roll*math.Pi/180.0) * 180.0 / math.Pi
        platform.State.Physics.Attitude.Pitch = pe.normalizeAngle(platform.State.Physics.Attitude.Pitch*math.Pi/180.0) * 180.0 / math.Pi
        platform.State.Physics.Attitude.Yaw = pe.normalizeAngle(platform.State.Physics.Attitude.Yaw*math.Pi/180.0) * 180.0 / math.Pi
}</span>

// calculateTotalForces computes the net force acting on the platform
func (pe *PhysicsEngine) calculateTotalForces(platform *models.UniversalPlatform) models.Acceleration <span class="cov0" title="0">{
        var totalForce models.Acceleration

        // Thrust force (in body frame, need to convert to world frame)
        thrust := pe.calculateThrust(platform)
        worldThrust := pe.bodyToWorldForce(thrust, platform.State.Physics.Attitude)
        totalForce.North += worldThrust.North
        totalForce.East += worldThrust.East
        totalForce.Up += worldThrust.Up

        // Gravity
        mass := platform.TypeDef.Physical.Mass
        if mass &lt;= 0 </span><span class="cov0" title="0">{
                mass = 1000.0
        }</span>
        <span class="cov0" title="0">totalForce.Up -= mass * pe.GravityAccel

        // Drag forces
        drag := pe.calculateDrag(platform)
        totalForce.North -= drag.North
        totalForce.East -= drag.East
        totalForce.Up -= drag.Up

        // Environmental forces (wind, current, etc.)
        if pe.EnableWeather </span><span class="cov0" title="0">{
                envForce := pe.calculateEnvironmentalForces(platform)
                totalForce.North += envForce.North
                totalForce.East += envForce.East
                totalForce.Up += envForce.Up
        }</span>

        <span class="cov0" title="0">return totalForce</span>
}

// calculateTotalTorques computes the net torque acting on the platform
func (pe *PhysicsEngine) calculateTotalTorques(platform *models.UniversalPlatform) models.AngularAcceleration <span class="cov0" title="0">{
        var totalTorque models.AngularAcceleration

        // Control surface torques
        controlTorque := pe.calculateControlTorques(platform)
        totalTorque.RollAccel += controlTorque.RollAccel
        totalTorque.PitchAccel += controlTorque.PitchAccel
        totalTorque.YawAccel += controlTorque.YawAccel

        // Aerodynamic/hydrodynamic stability torques
        stabilityTorque := pe.calculateStabilityTorques(platform)
        totalTorque.RollAccel += stabilityTorque.RollAccel
        totalTorque.PitchAccel += stabilityTorque.PitchAccel
        totalTorque.YawAccel += stabilityTorque.YawAccel

        return totalTorque
}</span>

// Helper methods for force and torque calculations

func (pe *PhysicsEngine) calculateThrust(platform *models.UniversalPlatform) models.Acceleration <span class="cov0" title="0">{
        // Simplified thrust calculation based on desired speed
        var thrust models.Acceleration

        // Forward thrust based on throttle setting (assumed to be related to desired speed)
        maxThrust := platform.TypeDef.Performance.MaxAcceleration
        if maxThrust &lt;= 0 </span><span class="cov0" title="0">{
                maxThrust = 2.0 // Default 2 m/s² acceleration capability
        }</span>

        // Calculate desired thrust based on speed error
        <span class="cov0" title="0">desiredSpeed := platform.TypeDef.Performance.CruiseSpeed
        currentSpeed := platform.State.Speed
        speedError := desiredSpeed - currentSpeed

        // Simple proportional control
        thrustPercent := math.Max(0, math.Min(1, speedError/desiredSpeed))
        thrust.North = maxThrust * thrustPercent // Assuming forward is North for simplicity

        return thrust</span>
}

func (pe *PhysicsEngine) calculateDrag(platform *models.UniversalPlatform) models.Acceleration <span class="cov0" title="0">{
        // Simplified drag calculation: F_drag = 0.5 * ρ * v² * C_d * A
        var drag models.Acceleration

        dragCoeff := 0.3 // Default drag coefficient
        frontalArea := platform.TypeDef.Physical.Length * platform.TypeDef.Physical.Width

        // Get fluid density based on platform type and altitude
        density := pe.getFluidDensity(platform)

        // Calculate drag force in each direction
        velocityMag := math.Sqrt(
                platform.State.Velocity.North*platform.State.Velocity.North +
                        platform.State.Velocity.East*platform.State.Velocity.East +
                        platform.State.Velocity.Up*platform.State.Velocity.Up,
        )

        if velocityMag &gt; 0 </span><span class="cov0" title="0">{
                dragMagnitude := 0.5 * density * velocityMag * velocityMag * dragCoeff * frontalArea

                // Apply drag opposite to velocity direction
                drag.North = dragMagnitude * (platform.State.Velocity.North / velocityMag) / platform.TypeDef.Physical.Mass
                drag.East = dragMagnitude * (platform.State.Velocity.East / velocityMag) / platform.TypeDef.Physical.Mass
                drag.Up = dragMagnitude * (platform.State.Velocity.Up / velocityMag) / platform.TypeDef.Physical.Mass
        }</span>

        <span class="cov0" title="0">return drag</span>
}

func (pe *PhysicsEngine) calculateControlTorques(platform *models.UniversalPlatform) models.AngularAcceleration <span class="cov0" title="0">{
        // Simplified control torque calculation
        var torque models.AngularAcceleration

        // Calculate desired orientation based on movement direction
        if platform.Destination != nil </span><span class="cov0" title="0">{
                desiredHeading := pe.CalculateBearing(platform.State.Position, *platform.Destination)
                desiredYaw := desiredHeading * math.Pi / 180.0

                yawError := pe.normalizeAngle(desiredYaw - platform.State.Physics.Attitude.Yaw*math.Pi/180.0)

                // Simple proportional control for yaw
                yawGain := 1.0
                torque.YawAccel = yawGain * yawError
        }</span>

        <span class="cov0" title="0">return torque</span>
}

func (pe *PhysicsEngine) calculateStabilityTorques(platform *models.UniversalPlatform) models.AngularAcceleration <span class="cov0" title="0">{
        // Stability torques tend to return the platform to level flight
        var torque models.AngularAcceleration

        rollDamping := 1.0
        pitchDamping := 1.0
        yawDamping := 1.0

        // Apply damping proportional to angular velocity
        torque.RollAccel = -rollDamping * platform.State.Physics.AngularVelocity.RollRate
        torque.PitchAccel = -pitchDamping * platform.State.Physics.AngularVelocity.PitchRate
        torque.YawAccel = -yawDamping * platform.State.Physics.AngularVelocity.YawRate

        // Add restoring torques for roll and pitch
        torque.RollAccel -= rollDamping * platform.State.Physics.Attitude.Roll * 0.5
        torque.PitchAccel -= pitchDamping * platform.State.Physics.Attitude.Pitch * 0.5

        return torque
}</span>

// Utility methods

func (pe *PhysicsEngine) bodyToWorldForce(bodyForce models.Acceleration, orientation models.Attitude) models.Acceleration <span class="cov0" title="0">{
        // Simplified rotation transformation (assuming small angles)
        var worldForce models.Acceleration

        // For small angles, we can use simplified rotation
        yawRad := orientation.Yaw * math.Pi / 180.0
        worldForce.North = bodyForce.North*math.Cos(yawRad) - bodyForce.East*math.Sin(yawRad)
        worldForce.East = bodyForce.North*math.Sin(yawRad) + bodyForce.East*math.Cos(yawRad)
        worldForce.Up = bodyForce.Up

        return worldForce
}</span>

func (pe *PhysicsEngine) getFluidDensity(platform *models.UniversalPlatform) float64 <span class="cov0" title="0">{
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne, models.PlatformTypeSpace:<span class="cov0" title="0">
                // Air density decreases with altitude
                altitude := platform.State.Position.Altitude
                if altitude &lt; 11000 </span><span class="cov0" title="0">{ // Troposphere
                        return pe.AirDensity * math.Pow(1-0.0065*altitude/288.15, 4.255)
                }</span>
                <span class="cov0" title="0">return pe.AirDensity * 0.1</span> // Simplified for higher altitudes
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                return 1025.0</span> // Seawater density (kg/m³)
        case models.PlatformTypeLand:<span class="cov0" title="0">
                return pe.AirDensity</span> // Ground vehicles in air
        default:<span class="cov0" title="0">
                return pe.AirDensity</span>
        }
}

func (pe *PhysicsEngine) calculateMomentOfInertia(platform *models.UniversalPlatform) models.AngularAcceleration <span class="cov0" title="0">{
        // Simplified moment of inertia calculation
        mass := platform.TypeDef.Physical.Mass
        length := platform.TypeDef.Physical.Length
        width := platform.TypeDef.Physical.Width
        height := platform.TypeDef.Physical.Height

        if mass &lt;= 0 </span><span class="cov0" title="0">{
                mass = 1000.0
        }</span>
        <span class="cov0" title="0">if length &lt;= 0 </span><span class="cov0" title="0">{
                length = 10.0
        }</span>
        <span class="cov0" title="0">if width &lt;= 0 </span><span class="cov0" title="0">{
                width = 2.0
        }</span>
        <span class="cov0" title="0">if height &lt;= 0 </span><span class="cov0" title="0">{
                height = 2.0
        }</span>

        // Approximate as rectangular solid
        <span class="cov0" title="0">return models.AngularAcceleration{
                RollAccel:  mass * (height*height + length*length) / 12.0,
                PitchAccel: mass * (width*width + height*height) / 12.0,
                YawAccel:   mass * (length*length + width*width) / 12.0,
        }</span>
}

func (pe *PhysicsEngine) applyVelocityLimits(platform *models.UniversalPlatform) <span class="cov0" title="0">{
        maxSpeed := platform.TypeDef.Performance.MaxSpeed
        if maxSpeed &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate total velocity magnitude
        <span class="cov0" title="0">velMag := math.Sqrt(
                platform.State.Velocity.North*platform.State.Velocity.North +
                        platform.State.Velocity.East*platform.State.Velocity.East +
                        platform.State.Velocity.Up*platform.State.Velocity.Up,
        )

        // Scale down if exceeding max speed
        if velMag &gt; maxSpeed </span><span class="cov0" title="0">{
                scale := maxSpeed / velMag
                platform.State.Velocity.North *= scale
                platform.State.Velocity.East *= scale
                platform.State.Velocity.Up *= scale
        }</span>
}

func (pe *PhysicsEngine) applyAngularVelocityLimits(platform *models.UniversalPlatform) <span class="cov0" title="0">{
        maxRollRate := platform.TypeDef.Performance.MaxRollRate
        maxPitchRate := platform.TypeDef.Performance.MaxPitchRate
        maxYawRate := platform.TypeDef.Performance.MaxYawRate

        if maxRollRate &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Physics.AngularVelocity.RollRate = math.Max(-maxRollRate, math.Min(maxRollRate, platform.State.Physics.AngularVelocity.RollRate))
        }</span>
        <span class="cov0" title="0">if maxPitchRate &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Physics.AngularVelocity.PitchRate = math.Max(-maxPitchRate, math.Min(maxPitchRate, platform.State.Physics.AngularVelocity.PitchRate))
        }</span>
        <span class="cov0" title="0">if maxYawRate &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Physics.AngularVelocity.YawRate = math.Max(-maxYawRate, math.Min(maxYawRate, platform.State.Physics.AngularVelocity.YawRate))
        }</span>
}

func (pe *PhysicsEngine) updatePositionFromVelocity(platform *models.UniversalPlatform, deltaSeconds float64) error <span class="cov0" title="0">{
        // Convert velocity to position change
        northDistance := platform.State.Velocity.North * deltaSeconds
        eastDistance := platform.State.Velocity.East * deltaSeconds
        upDistance := platform.State.Velocity.Up * deltaSeconds

        // Convert to lat/lon changes
        deltaLat := northDistance / pe.EarthRadius * 180.0 / math.Pi
        deltaLon := eastDistance / pe.EarthRadius * 180.0 / math.Pi / math.Cos(platform.State.Position.Latitude*math.Pi/180.0)

        // Update position
        platform.State.Position.Latitude += deltaLat
        platform.State.Position.Longitude += deltaLon
        platform.State.Position.Altitude += upDistance

        // Update speed and heading for compatibility
        platform.State.Speed = math.Sqrt(
                platform.State.Velocity.North*platform.State.Velocity.North +
                        platform.State.Velocity.East*platform.State.Velocity.East,
        )

        if platform.State.Speed &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Heading = math.Atan2(platform.State.Velocity.East, platform.State.Velocity.North) * 180.0 / math.Pi
                platform.State.Heading = math.Mod(platform.State.Heading+360, 360)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Enhanced physics calculations that integrate with 3D physics state

// Calculate3DForces computes comprehensive forces for any platform type
func (pe *PhysicsEngine) Calculate3DForces(platform *models.UniversalPlatform) error <span class="cov0" title="0">{
        physics := &amp;platform.State.Physics

        // Environmental forces
        physics.Forces.Weight = physics.Mass * pe.GravityAccel

        // Platform-specific force calculations
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                return pe.calculateAerodynamicForces(platform, physics)</span>
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                return pe.calculateHydrodynamicForces(platform, physics)</span>
        case models.PlatformTypeLand:<span class="cov0" title="0">
                return pe.calculateGroundForces(platform, physics)</span>
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                return pe.calculateOrbitalForces(platform, physics)</span>
        default:<span class="cov0" title="0">
                return pe.calculateGenericForces(platform, physics)</span>
        }
}

// calculateAerodynamicForces handles aircraft-specific forces
func (pe *PhysicsEngine) calculateAerodynamicForces(platform *models.UniversalPlatform, physics *models.PhysicsState) error <span class="cov0" title="0">{
        // Air density at altitude (simplified exponential model)
        altitude := physics.Position.Altitude
        airDensity := pe.AirDensity * math.Exp(-altitude/8400) // Scale height ~8.4km

        // Current speed and velocity
        velocity := math.Sqrt(physics.Velocity.North*physics.Velocity.North +
                physics.Velocity.East*physics.Velocity.East +
                physics.Velocity.Up*physics.Velocity.Up)

        // Wing area and aerodynamic coefficients
        wingArea := platform.TypeDef.Physical.WingArea
        if wingArea == 0 </span><span class="cov0" title="0">{
                // Estimate based on mass (rule of thumb)
                wingArea = platform.TypeDef.Physical.Mass / 500 // kg/m²
        }</span>

        // Dynamic pressure
        <span class="cov0" title="0">dynamicPressure := 0.5 * airDensity * velocity * velocity

        // Lift calculation (simplified)
        angleOfAttack := physics.Attitude.Pitch * math.Pi / 180.0
        liftCoeff := 2 * math.Pi * math.Sin(angleOfAttack) // Simplified thin airfoil theory
        physics.Forces.Lift = dynamicPressure * wingArea * liftCoeff

        // Drag calculation
        inducedDragCoeff := liftCoeff * liftCoeff / (math.Pi * 8) // Simplified induced drag
        parasiteDragCoeff := 0.02                                 // Typical value
        totalDragCoeff := parasiteDragCoeff + inducedDragCoeff
        physics.Forces.Drag = dynamicPressure * wingArea * totalDragCoeff

        // Thrust calculation based on throttle setting
        maxThrust := physics.Mass * pe.GravityAccel * platform.TypeDef.Performance.MaxThrustToWeight
        if maxThrust == 0 </span><span class="cov0" title="0">{
                maxThrust = physics.Mass * pe.GravityAccel * 0.3 // Default T/W ratio
        }</span>

        // Throttle based on speed error
        <span class="cov0" title="0">targetSpeed := platform.TypeDef.Performance.CruiseSpeed
        speedError := targetSpeed - velocity
        throttle := math.Max(0, math.Min(1, 0.5+speedError/targetSpeed))
        physics.Forces.Thrust = maxThrust * throttle

        return nil</span>
}

// calculateHydrodynamicForces handles ship-specific forces
func (pe *PhysicsEngine) calculateHydrodynamicForces(platform *models.UniversalPlatform, physics *models.PhysicsState) error <span class="cov0" title="0">{
        // Water density (constant at sea level)
        waterDensity := 1025.0 // kg/m³

        velocity := math.Sqrt(physics.Velocity.North*physics.Velocity.North +
                physics.Velocity.East*physics.Velocity.East)

        // Hydrodynamic calculations
        wetArea := platform.TypeDef.Physical.WetArea
        if wetArea == 0 </span><span class="cov0" title="0">{
                // Estimate based on length and beam
                wetArea = platform.TypeDef.Physical.Length * platform.TypeDef.Physical.Width
        }</span>

        // Wave resistance (simplified Froude number calculation)
        <span class="cov0" title="0">froudeNumber := velocity / math.Sqrt(pe.GravityAccel*platform.TypeDef.Physical.Length)
        waveResistanceCoeff := 0.002 * (1 + 10*froudeNumber*froudeNumber)

        // Total drag
        viscousDragCoeff := 0.01 // Simplified
        totalDragCoeff := viscousDragCoeff + waveResistanceCoeff
        physics.Forces.Drag = 0.5 * waterDensity * velocity * velocity * wetArea * totalDragCoeff

        // Thrust from propulsion
        targetSpeed := platform.TypeDef.Performance.CruiseSpeed
        speedError := targetSpeed - velocity
        maxThrust := physics.Mass * 2.0 // Ships have high thrust capability
        throttle := math.Max(0, math.Min(1, 0.5+speedError/targetSpeed))
        physics.Forces.Thrust = maxThrust * throttle

        // Buoyancy equals weight
        physics.Forces.Normal = physics.Forces.Weight

        return nil</span>
}

// calculateGroundForces handles land vehicle forces
func (pe *PhysicsEngine) calculateGroundForces(platform *models.UniversalPlatform, physics *models.PhysicsState) error <span class="cov0" title="0">{
        velocity := math.Sqrt(physics.Velocity.North*physics.Velocity.North +
                physics.Velocity.East*physics.Velocity.East)

        // Aerodynamic drag
        frontalArea := platform.TypeDef.Physical.FrontalArea
        if frontalArea == 0 </span><span class="cov0" title="0">{
                frontalArea = platform.TypeDef.Physical.Width * platform.TypeDef.Physical.Height
        }</span>

        <span class="cov0" title="0">dragCoeff := 0.3 // Typical for vehicles
        physics.Forces.Drag = 0.5 * pe.AirDensity * velocity * velocity * frontalArea * dragCoeff

        // Rolling resistance
        rollingResistance := physics.Forces.Weight * 0.01 // 1% of weight
        physics.Forces.Drag += rollingResistance

        // Traction force from drive system
        targetSpeed := platform.TypeDef.Performance.CruiseSpeed
        speedError := targetSpeed - velocity
        maxTraction := physics.Mass * 5.0 // High traction capability
        throttle := math.Max(0, math.Min(1, 0.5+speedError/targetSpeed))
        physics.Forces.Thrust = maxTraction * throttle

        // Normal force from ground
        physics.Forces.Normal = physics.Forces.Weight

        return nil</span>
}

// calculateOrbitalForces handles space platform forces
func (pe *PhysicsEngine) calculateOrbitalForces(platform *models.UniversalPlatform, physics *models.PhysicsState) error <span class="cov0" title="0">{
        // In orbit, forces are minimal except for station keeping
        altitude := physics.Position.Altitude

        if altitude &gt; 100000 </span><span class="cov0" title="0">{ // Above atmosphere
                // Minimal atmospheric drag
                physics.Forces.Drag = 0

                // Station keeping thrusters (very small)
                physics.Forces.Thrust = 0.01 // Minimal thrust for attitude control

                // No aerodynamic lift
                physics.Forces.Lift = 0

                // Gravitational force
                r := pe.EarthRadius + altitude
                gravitationalAccel := pe.GravityAccel * (pe.EarthRadius * pe.EarthRadius) / (r * r)
                physics.Forces.Weight = physics.Mass * gravitationalAccel

                // Centrifugal force balances gravity in circular orbit
                orbitalSpeed := math.Sqrt(pe.GravityAccel * pe.EarthRadius * pe.EarthRadius / r)
                centrifugalForce := physics.Mass * orbitalSpeed * orbitalSpeed / r
                physics.Forces.Normal = centrifugalForce
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// calculateGenericForces provides fallback force calculations
func (pe *PhysicsEngine) calculateGenericForces(platform *models.UniversalPlatform, physics *models.PhysicsState) error <span class="cov0" title="0">{
        // Basic force model
        velocity := math.Sqrt(physics.Velocity.North*physics.Velocity.North +
                physics.Velocity.East*physics.Velocity.East)

        // Simple drag proportional to velocity squared
        physics.Forces.Drag = 0.5 * pe.AirDensity * velocity * velocity * 10.0

        // Simple thrust control
        targetSpeed := platform.TypeDef.Performance.CruiseSpeed
        speedError := targetSpeed - velocity
        maxThrust := physics.Mass * 3.0
        throttle := math.Max(0, math.Min(1, 0.5+speedError/targetSpeed))
        physics.Forces.Thrust = maxThrust * throttle

        return nil
}</span>

// Calculate3DTorques computes rotational forces for platform control
func (pe *PhysicsEngine) Calculate3DTorques(platform *models.UniversalPlatform) error <span class="cov0" title="0">{
        physics := &amp;platform.State.Physics

        // Control torques based on desired vs actual attitude
        desiredAttitude := pe.calculateDesiredAttitude(platform)

        // PID-like control for each axis
        rollError := desiredAttitude.Roll - physics.Attitude.Roll
        pitchError := desiredAttitude.Pitch - physics.Attitude.Pitch
        yawError := desiredAttitude.Yaw - physics.Attitude.Yaw

        // Normalize yaw error
        for yawError &gt; 180 </span><span class="cov0" title="0">{
                yawError -= 360
        }</span>
        <span class="cov0" title="0">for yawError &lt; -180 </span><span class="cov0" title="0">{
                yawError += 360
        }</span>

        // Control authority based on platform type
        <span class="cov0" title="0">var maxRollTorque, maxPitchTorque, maxYawTorque float64

        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                // Aircraft control surfaces
                maxRollTorque = physics.Mass * 10.0 // Ailerons
                maxPitchTorque = physics.Mass * 8.0 // Elevator
                maxYawTorque = physics.Mass * 5.0</span>   // Rudder
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                // Ship rudder (primarily yaw control)
                maxRollTorque = physics.Mass * 1.0
                maxPitchTorque = physics.Mass * 1.0
                maxYawTorque = physics.Mass * 3.0</span>
        case models.PlatformTypeLand:<span class="cov0" title="0">
                // Vehicle steering and suspension
                maxRollTorque = physics.Mass * 2.0
                maxPitchTorque = physics.Mass * 2.0
                maxYawTorque = physics.Mass * 8.0</span> // Steering
        case models.PlatformTypeSpace:<span class="cov0" title="0">
                // Reaction wheels and thrusters
                maxRollTorque = physics.Mass * 0.1
                maxPitchTorque = physics.Mass * 0.1
                maxYawTorque = physics.Mass * 0.1</span>
        default:<span class="cov0" title="0">
                maxRollTorque = physics.Mass * 2.0
                maxPitchTorque = physics.Mass * 2.0
                maxYawTorque = physics.Mass * 2.0</span>
        }

        // Proportional control (simplified)
        <span class="cov0" title="0">kp := 0.1
        physics.Torques.Roll = kp * rollError * maxRollTorque
        physics.Torques.Pitch = kp * pitchError * maxPitchTorque
        physics.Torques.Yaw = kp * yawError * maxYawTorque

        // Limit torques
        physics.Torques.Roll = math.Max(-maxRollTorque, math.Min(maxRollTorque, physics.Torques.Roll))
        physics.Torques.Pitch = math.Max(-maxPitchTorque, math.Min(maxPitchTorque, physics.Torques.Pitch))
        physics.Torques.Yaw = math.Max(-maxYawTorque, math.Min(maxYawTorque, physics.Torques.Yaw))

        return nil</span>
}

// calculateDesiredAttitude determines the target attitude for navigation
func (pe *PhysicsEngine) calculateDesiredAttitude(platform *models.UniversalPlatform) models.Attitude <span class="cov0" title="0">{
        if platform.Destination == nil </span><span class="cov0" title="0">{
                return platform.State.Physics.Attitude
        }</span>

        // Calculate bearing to destination
        <span class="cov0" title="0">bearing := pe.CalculateBearing(platform.State.Position, *platform.Destination)

        // Calculate desired pitch for altitude change
        altitudeDiff := platform.Destination.Altitude - platform.State.Position.Altitude
        distance := pe.CalculateGreatCircleDistance(platform.State.Position, *platform.Destination)

        desiredPitch := 0.0
        if distance &gt; 0 </span><span class="cov0" title="0">{
                pitchAngle := math.Atan(altitudeDiff/distance) * 180.0 / math.Pi

                // Limit pitch based on platform capabilities
                maxPitch := platform.TypeDef.Performance.MaxPitchAngle
                if maxPitch == 0 </span><span class="cov0" title="0">{
                        switch platform.PlatformType </span>{
                        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                                maxPitch = 15.0</span>
                        case models.PlatformTypeLand:<span class="cov0" title="0">
                                maxPitch = 30.0</span>
                        default:<span class="cov0" title="0">
                                maxPitch = 10.0</span>
                        }
                }
                <span class="cov0" title="0">desiredPitch = math.Max(-maxPitch, math.Min(maxPitch, pitchAngle))</span>
        }

        // Calculate desired roll for coordinated turns (aircraft)
        <span class="cov0" title="0">desiredRoll := 0.0
        if platform.PlatformType == models.PlatformTypeAirborne </span><span class="cov0" title="0">{
                headingError := bearing - platform.State.Physics.Attitude.Yaw
                for headingError &gt; 180 </span><span class="cov0" title="0">{
                        headingError -= 360
                }</span>
                <span class="cov0" title="0">for headingError &lt; -180 </span><span class="cov0" title="0">{
                        headingError += 360
                }</span>

                <span class="cov0" title="0">maxBank := platform.TypeDef.Performance.MaxBankAngle
                if maxBank == 0 </span><span class="cov0" title="0">{
                        maxBank = 30.0
                }</span>
                <span class="cov0" title="0">desiredRoll = math.Max(-maxBank, math.Min(maxBank, headingError/3))</span>
        }

        <span class="cov0" title="0">return models.Attitude{
                Roll:  desiredRoll,
                Pitch: desiredPitch,
                Yaw:   bearing,
        }</span>
}

// Enhanced environmental effects

// ApplyEnvironmentalEffects modifies forces based on environmental conditions
func (pe *PhysicsEngine) ApplyEnvironmentalEffects(platform *models.UniversalPlatform, weather *WeatherConditions) error <span class="cov0" title="0">{
        if !pe.EnableWeather || weather == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">physics := &amp;platform.State.Physics

        // Wind effects
        windEffect := pe.calculateWindEffect(platform, weather)
        physics.Forces.Drag += windEffect.Drag
        physics.Torques.Roll += windEffect.RollTorque
        physics.Torques.Pitch += windEffect.PitchTorque
        physics.Torques.Yaw += windEffect.YawTorque

        // Temperature effects on performance
        tempRatio := (weather.Temperature + 273.15) / 288.15 // ISA standard
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                // Engine performance varies with temperature
                physics.Forces.Thrust *= math.Sqrt(tempRatio)</span>
        }

        // Precipitation effects
        <span class="cov0" title="0">if weather.Precipitation &gt; 0 </span><span class="cov0" title="0">{
                // Increased drag due to rain/snow
                physics.Forces.Drag *= (1 + weather.Precipitation*0.1)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WeatherConditions represents environmental conditions
type WeatherConditions struct {
        WindSpeed     float64 // m/s
        WindDirection float64 // degrees
        Temperature   float64 // Celsius
        Pressure      float64 // Pa
        Humidity      float64 // %
        Precipitation float64 // mm/hr
        Visibility    float64 // meters
}

// WindEffect represents wind-induced forces and torques
type WindEffect struct {
        Drag        float64
        RollTorque  float64
        PitchTorque float64
        YawTorque   float64
}

// calculateWindEffect computes wind effects on platform
func (pe *PhysicsEngine) calculateWindEffect(platform *models.UniversalPlatform, weather *WeatherConditions) WindEffect <span class="cov0" title="0">{
        // Convert wind from meteorological to mathematical convention
        windDir := math.Mod(270-weather.WindDirection, 360) * math.Pi / 180.0

        // Wind velocity components
        windNorth := weather.WindSpeed * math.Cos(windDir)
        windEast := weather.WindSpeed * math.Sin(windDir)

        // Relative wind
        relWindNorth := windNorth - platform.State.Physics.Velocity.North
        relWindEast := windEast - platform.State.Physics.Velocity.East
        relWindSpeed := math.Sqrt(relWindNorth*relWindNorth + relWindEast*relWindEast)

        // Wind effects scale with exposed area and relative wind speed
        var exposedArea float64
        switch platform.PlatformType </span>{
        case models.PlatformTypeAirborne:<span class="cov0" title="0">
                exposedArea = platform.TypeDef.Physical.WingArea</span>
        case models.PlatformTypeMaritime:<span class="cov0" title="0">
                exposedArea = platform.TypeDef.Physical.Length * platform.TypeDef.Physical.Height</span>
        case models.PlatformTypeLand:<span class="cov0" title="0">
                exposedArea = platform.TypeDef.Physical.FrontalArea</span>
        default:<span class="cov0" title="0">
                exposedArea = platform.TypeDef.Physical.Width * platform.TypeDef.Physical.Height</span>
        }

        <span class="cov0" title="0">if exposedArea == 0 </span><span class="cov0" title="0">{
                exposedArea = 10.0 // Default
        }</span>

        // Wind drag
        <span class="cov0" title="0">windDrag := 0.5 * pe.AirDensity * relWindSpeed * relWindSpeed * exposedArea * 0.5

        // Wind-induced torques (simplified)
        leverArm := platform.TypeDef.Physical.Length / 2
        windTorque := windDrag * leverArm * 0.1

        return WindEffect{
                Drag:        windDrag,
                RollTorque:  windTorque * 0.3,
                PitchTorque: windTorque * 0.2,
                YawTorque:   windTorque * 0.5,
        }</span>
}

// Missing helper functions for physics calculations

// calculateEnvironmentalForces computes environmental forces like wind and current
func (pe *PhysicsEngine) calculateEnvironmentalForces(platform *models.UniversalPlatform) models.Acceleration <span class="cov0" title="0">{
        // Simplified environmental forces - can be expanded for weather effects
        var envForce models.Acceleration

        // For now, return zero forces - this can be enhanced with weather data
        return envForce
}</span>

// applyEnvironmentalForces applies environmental effects to the platform
func (pe *PhysicsEngine) applyEnvironmentalForces(platform *models.UniversalPlatform, deltaSeconds float64) {<span class="cov0" title="0">
        // Apply basic environmental effects like atmospheric density changes
        // This is a placeholder for more complex environmental modeling
}</span>

// updateDerivedParameters updates calculated values based on current state
func (pe *PhysicsEngine) updateDerivedParameters(platform *models.UniversalPlatform) <span class="cov0" title="0">{
        // Update speed from velocity components
        platform.State.Speed = math.Sqrt(
                platform.State.Velocity.North*platform.State.Velocity.North +
                        platform.State.Velocity.East*platform.State.Velocity.East,
        )

        // Update heading from velocity direction
        if platform.State.Speed &gt; 0 </span><span class="cov0" title="0">{
                platform.State.Heading = math.Atan2(platform.State.Velocity.East, platform.State.Velocity.North) * 180.0 / math.Pi
                platform.State.Heading = math.Mod(platform.State.Heading+360, 360)
        }</span>
}

// normalizeAngle normalizes an angle to the range [-π, π]
func (pe *PhysicsEngine) normalizeAngle(angle float64) float64 <span class="cov0" title="0">{
        for angle &gt; math.Pi </span><span class="cov0" title="0">{
                angle -= 2 * math.Pi
        }</span>
        <span class="cov0" title="0">for angle &lt; -math.Pi </span><span class="cov0" title="0">{
                angle += 2 * math.Pi
        }</span>
        <span class="cov0" title="0">return angle</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
